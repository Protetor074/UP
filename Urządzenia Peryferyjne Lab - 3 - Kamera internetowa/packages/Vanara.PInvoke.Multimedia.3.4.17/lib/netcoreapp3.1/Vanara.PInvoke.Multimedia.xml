<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Vanara.PInvoke.Multimedia</name>
    </assembly>
    <members>
        <member name="T:Vanara.PInvoke.WinMm">
            <summary>Items from the WinMm.dll</summary>
            <summary>Items from the WinMm.dll</summary>
            <summary>Items from the WinMm.dll</summary>
            <summary>Items from the WinMm.dll</summary>
            <summary>Items from the WinMm.dll</summary>
            <summary>Items from the WinMm.dll</summary>
            <summary>Items from the WinMm.dll</summary>
            <summary>Items from the WinMm.dll</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_POVBACKWARD">
            <summary>Point-of-view hat is pressed backward. The value 18,000 represents an orientation of 180.00 degrees (to the rear).</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_POVCENTERED">
            <summary>Point-of-view hat is in the neutral position. The value -1 means the point-of-view hat has no angle to report.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_POVFORWARD">
            <summary>Point-of-view hat is pressed forward. The value 0 represents an orientation of 0.00 degrees (straight ahead).</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_POVLEFT">
            <summary>
            Point-of-view hat is being pressed to the left. The value 27,000 represents an orientation of 270.00 degrees (90.00 degrees to
            the left).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_POVRIGHT">
            <summary>Point-of-view hat is pressed to the right. The value 9,000 represents an orientation of 90.00 degrees (to the right).</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.JOY_BUTTON">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON1">
            <summary>First joystick button is pressed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON2">
            <summary>Second joystick button is pressed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON3">
            <summary>Third joystick button is pressed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON4">
            <summary>Fourth joystick button is pressed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON1CHG">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON2CHG">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON3CHG">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON4CHG">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON5">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON6">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON7">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON8">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON9">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON10">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON11">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON12">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON13">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON14">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON15">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON16">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON17">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON18">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON19">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON20">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON21">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON22">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON23">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON24">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON25">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON26">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON27">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON28">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON29">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON30">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON31">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_BUTTON.JOY_BUTTON32">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.JOYCAPSF">
            <summary>Joystick capabilities</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPSF.JOYCAPS_HASZ">
            <summary>Joystick has z-coordinate information.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPSF.JOYCAPS_HASR">
            <summary>Joystick has rudder (fourth axis) information.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPSF.JOYCAPS_HASU">
            <summary>Joystick has u-coordinate (fifth axis) information.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPSF.JOYCAPS_HASV">
            <summary>Joystick has v-coordinate (sixth axis) information.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPSF.JOYCAPS_HASPOV">
            <summary>Joystick has point-of-view information.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPSF.JOYCAPS_POV4DIR">
            <summary>Joystick point-of-view supports discrete values (centered, forward, backward, left, and right).</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPSF.JOYCAPS_POVCTS">
            <summary>Joystick point-of-view supports continuous degree bearings.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.JOYINFOEXF">
            <summary>
            Flags indicating the valid information returned in this structure. Members that do not contain valid information are set to zero.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_RETURNX">
            <summary>The dwXpos member contains valid data for the x-coordinate of the joystick.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_RETURNY">
            <summary>The dwYpos member contains valid data for the y-coordinate of the joystick.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_RETURNZ">
            <summary>The dwZpos member contains valid data for the z-coordinate of the joystick.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_RETURNR">
            <summary>The dwRpos member contains valid rudder pedal data. This information represents another (fourth) axis.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_RETURNU">
            <summary>
            The dwUpos member contains valid data for a fifth axis of the joystick, if such an axis is available, or returns zero otherwise.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_RETURNV">
            <summary>
            The dwVpos member contains valid data for a sixth axis of the joystick, if such an axis is available, or returns zero otherwise.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_RETURNPOV">
            <summary>The dwPOV member contains valid information about the point-of-view control, expressed in discrete units.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_RETURNBUTTONS">
            <summary>The dwButtons member contains valid information about the state of each joystick button.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_RETURNRAWDATA">
            <summary>Data stored in this structure is uncalibrated joystick readings.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_RETURNPOVCTS">
            <summary>
            The dwPOV member contains valid information about the point-of-view control expressed in continuous, one-hundredth degree units.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_RETURNCENTERED">
            <summary>Centers the joystick neutral position to the middle value of each axis of movement.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_USEDEADZONE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_RETURNALL">
            <summary>Equivalent to setting all of the JOY_RETURN bits except JOY_RETURNRAWDATA.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_CAL_READALWAYS">
            <summary>Read the joystick port even if the driver does not detect a device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_CAL_READXYONLY">
            <summary>Reads the x- and y-coordinates and place the raw values in dwXpos and dwYpos.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_CAL_READ3">
            <summary>Read the x-, y-, and z-coordinates and store the raw values in dwXpos, dwYpos, and dwZpos.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_CAL_READ4">
            <summary>
            Read the rudder information and the x-, y-, and z-coordinates and store the raw values in dwXpos, dwYpos, dwZpos, and dwRpos.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_CAL_READXONLY">
            <summary>Read the x-coordinate and store the raw (uncalibrated) value in dwXpos.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_CAL_READYONLY">
            <summary>Reads the y-coordinate and store the raw value in dwYpos.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_CAL_READ5">
            <summary>
            Read the rudder information and the x-, y-, z-, and u-coordinates and store the raw values in dwXpos, dwYpos, dwZpos,
            dwRpos, and dwUpos.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_CAL_READ6">
            <summary>Read the raw v-axis data if a joystick mini driver is present that will provide the data. Returns zero otherwise.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_CAL_READZONLY">
            <summary>Read the z-coordinate and store the raw value in dwZpos.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_CAL_READRONLY">
            <summary>
            Read the rudder information if a joystick mini-driver is present that will provide the data and store the raw value in
            dwRpos. Return zero otherwise.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_CAL_READUONLY">
            <summary>
            Read the u-coordinate if a joystick mini-driver is present that will provide the data and store the raw value in dwUpos.
            Return zero otherwise.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEXF.JOY_CAL_READVONLY">
            <summary>
            Read the v-coordinate if a joystick mini-driver is present that will provide the data and store the raw value in dwVpos.
            Return zero otherwise.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY.JOYSTICKID1">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY.JOYSTICKID2">
            <summary>joystick driver capabilites</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.joyConfigChanged(System.UInt32)">
            <summary>
            The <c>joyConfigChanged</c> function informs the joystick driver that the configuration has changed and should be reloaded from
            the registry.
            </summary>
            <param name="dwFlags">Reserved for future use. Must equal zero.</param>
            <returns>Returns JOYERR_NOERROR if successful. Returns JOYERR_PARMS if the parameter is non-zero.</returns>
            <remarks>
            <para>
            This function causes a window message to be sent to all top-level windows. This message may be defined by applications that need
            to respond to changes in joystick calibration by using <c>RegisterWindowMessage</c> with the following message ID:
            </para>
            <para>
            <code> #define JOY_CONFIGCHANGED_MSGSTRING "MSJSTICK_VJOYD_MSGSTR"</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.joyGetDevCaps(System.Int32,Vanara.PInvoke.WinMm.JOYCAPS@,System.UInt32)">
            <summary>The <c>joyGetDevCaps</c> function queries a joystick to determine its capabilities.</summary>
            <param name="uJoyID">
            Identifier of the joystick to be queried. Valid values for uJoyID range from -1 to 15. A value of -1 enables retrieval of the
            <c>szRegKey</c> member of the JOYCAPS structure whether a device is present or not.
            </param>
            <param name="pjc">Pointer to a JOYCAPS structure to contain the capabilities of the joystick.</param>
            <param name="cbjc">Size, in bytes, of the JOYCAPS structure.</param>
            <returns>
            <para>Returns JOYERR_NOERROR if successful or one of the following error values:</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>
            The joystick driver is not present, or the specified joystick identifier is invalid. The specified joystick identifier is invalid.
            </term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>An invalid parameter was passed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Use the joyGetNumDevs function to determine the number of joystick devices supported by the driver.</para>
            <para>This method fails when passed an invalid value for the cbjc parameter.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.joyGetNumDevs">
            <summary>The <c>joyGetNumDevs</c> function queries the joystick driver for the number of joysticks it supports.</summary>
            <returns>
            The <c>joyGetNumDevs</c> function returns the number of joysticks supported by the current driver or zero if no driver is installed.
            </returns>
            <remarks>
            Use the joyGetPos function to determine whether a given joystick is physically attached to the system. If the specified joystick
            is not connected, <c>joyGetPos</c> returns a JOYERR_UNPLUGGED error value.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.joyGetPos(System.Int32,Vanara.PInvoke.WinMm.JOYINFO@)">
            <summary>The <c>joyGetPos</c> function queries a joystick for its position and button status.</summary>
            <param name="uJoyID">Identifier of the joystick to be queried. Valid values for uJoyID range from zero (JOYSTICKID1) to 15.</param>
            <param name="pji">Pointer to a JOYINFO structure that contains the position and button status of the joystick.</param>
            <returns>
            <para>Returns JOYERR_NOERROR if successful or one of the following error values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>The joystick driver is not present.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>An invalid parameter was passed.</term>
            </item>
            <item>
            <term>JOYERR_UNPLUGGED</term>
            <term>The specified joystick is not connected to the system.</term>
            </item>
            </list>
            </returns>
            <remarks>
            For devices that have four to six axes of movement, a point-of-view control, or more than four buttons, use the joyGetPosEx function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.joyGetPosEx(System.Int32,Vanara.PInvoke.WinMm.JOYINFOEX@)">
            <summary>The <c>joyGetPosEx</c> function queries a joystick for its position and button status.</summary>
            <param name="uJoyID">Identifier of the joystick to be queried. Valid values for uJoyID range from zero (JOYSTICKID1) to 15.</param>
            <param name="pji">
            Pointer to a JOYINFOEX structure that contains extended position information and button status of the joystick. You must set the
            <c>dwSize</c> and <c>dwFlags</c> members or <c>joyGetPosEx</c> will fail. The information returned from <c>joyGetPosEx</c>
            depends on the flags you specify in <c>dwFlags</c>.
            </param>
            <returns>
            <para>Returns JOYERR_NOERROR if successful or one of the following error values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>The joystick driver is not present.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>An invalid parameter was passed.</term>
            </item>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The specified joystick identifier is invalid.</term>
            </item>
            <item>
            <term>JOYERR_UNPLUGGED</term>
            <term>The specified joystick is not connected to the system.</term>
            </item>
            <item>
            <term>JOYERR_PARMS</term>
            <term>The specified joystick identifier is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            This function provides access to extended devices such as rudder pedals, point-of-view hats, devices with a large number of
            buttons, and coordinate systems using up to six axes. For joystick devices that use three axes or fewer and have fewer than four
            buttons, use the joyGetPos function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.joyGetThreshold(System.Int32,System.UInt32@)">
            <summary>The <c>joyGetThreshold</c> function queries a joystick for its current movement threshold.</summary>
            <param name="uJoyID">Identifier of the joystick. Valid values for uJoyID range from zero (JOYSTICKID1) to 15.</param>
            <param name="puThreshold">Pointer to a variable that contains the movement threshold value.</param>
            <returns>
            <para>Returns JOYERR_NOERROR if successful or one of the following error values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>The joystick driver is not present.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>An invalid parameter was passed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The movement threshold is the distance the joystick must be moved before a joystick position-change message (MM_JOY1MOVE,
            MM_JOY1ZMOVE, MM_JOY2MOVE, or MM_JOY2ZMOVE) is sent to a window that has captured the device. The threshold is initially zero.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.joyReleaseCapture(System.Int32)">
            <summary>The <c>joyReleaseCapture</c> function releases the specified captured joystick.</summary>
            <param name="uJoyID">Identifier of the joystick to be released. Valid values for uJoyID range from zero (JOYSTICKID1) to 15.</param>
            <returns>
            <para>Returns JOYERR_NOERROR if successful or one of the following error values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>The joystick driver is not present.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALIDPARAM</term>
            <term>The specified joystick device identifier uJoyID is invalid.</term>
            </item>
            <item>
            <term>JOYERR_PARMS</term>
            <term>The specified joystick device identifier uJoyID is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>This method returns JOYERR_NOERROR when passed a valid joystick identifier that has not been captured.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.joySetCapture(Vanara.PInvoke.HWND,System.Int32,System.UInt32,System.Boolean)">
            <summary>The <c>joySetCapture</c> function captures a joystick by causing its messages to be sent to the specified window.</summary>
            <param name="hwnd">Handle to the window to receive the joystick messages.</param>
            <param name="uJoyID">Identifier of the joystick to be captured. Valid values for uJoyID range from zero (JOYSTICKID1) to 15.</param>
            <param name="uPeriod">Polling frequency, in milliseconds.</param>
            <param name="fChanged">
            Change position flag. Specify <c>TRUE</c> for this parameter to send messages only when the position changes by a value greater
            than the joystick movement threshold. Otherwise, messages are sent at the polling frequency specified in uPeriod.
            </param>
            <returns>
            <para>Returns JOYERR_NOERROR if successful or one of the following error values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>The joystick driver is not present.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>Invalid joystick ID or hwnd is NULL.</term>
            </item>
            <item>
            <term>JOYERR_NOCANDO</term>
            <term>Cannot capture joystick input because a required service (such as a Windows timer) is unavailable.</term>
            </item>
            <item>
            <term>JOYERR_UNPLUGGED</term>
            <term>The specified joystick is not connected to the system.</term>
            </item>
            <item>
            <term>JOYERR_PARMS</term>
            <term>Invalid joystick ID or hwnd is NULL.</term>
            </item>
            </list>
            </returns>
            <remarks>
            If the specified joystick is currently captured, the function returns undefined behavior. Call the joyReleaseCapture function to
            release the captured joystick, or destroy the window to release the joystick automatically.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.joySetThreshold(System.Int32,System.UInt32)">
            <summary>The <c>joySetThreshold</c> function sets the movement threshold of a joystick.</summary>
            <param name="uJoyID">Identifier of the joystick. Valid values for uJoyID range from zero (JOYSTICKID1) to 15.</param>
            <param name="uThreshold">New movement threshold.</param>
            <returns>
            <para>Returns JOYERR_NOERROR if successful or one of the following error values.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>The joystick driver is not present.</term>
            </item>
            <item>
            <term>JOYERR_PARMS</term>
            <term>The specified joystick device identifier uJoyID is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The movement threshold is the distance the joystick must be moved before a joystick position-change message (MM_JOY1MOVE,
            MM_JOY1ZMOVE, MM_JOY2MOVE, or MM_JOY2ZMOVE) is sent to a window that has captured the device. The threshold is initially zero.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.JOYCAPS">
            <summary>The <c>JOYCAPS</c> structure contains information about the joystick capabilities.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wMid">
            <summary>Manufacturer identifier. Manufacturer identifiers are defined in Manufacturer and Product Identifiers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wPid">
            <summary>Product identifier. Product identifiers are defined in Manufacturer and Product Identifiers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.szPname">
            <summary>Null-terminated string containing the joystick product name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wXmin">
            <summary>Minimum X-coordinate.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wXmax">
            <summary>Maximum X-coordinate.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wYmin">
            <summary>Minimum Y-coordinate.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wYmax">
            <summary>Maximum Y-coordinate.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wZmin">
            <summary>Minimum Z-coordinate.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wZmax">
            <summary>Maximum Z-coordinate.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wNumButtons">
            <summary>Number of joystick buttons.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wPeriodMin">
            <summary>Smallest polling frequency supported when captured by the joySetCapture function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wPeriodMax">
            <summary>Largest polling frequency supported when captured by <c>joySetCapture</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wRmin">
            <summary>Minimum rudder value. The rudder is a fourth axis of movement.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wRmax">
            <summary>Maximum rudder value. The rudder is a fourth axis of movement.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wUmin">
            <summary>Minimum u-coordinate (fifth axis) values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wUmax">
            <summary>Maximum u-coordinate (fifth axis) values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wVmin">
            <summary>Minimum v-coordinate (sixth axis) values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wVmax">
            <summary>Maximum v-coordinate (sixth axis) values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wCaps">
            <summary>
            <para>Joystick capabilities The following flags define individual capabilities that a joystick might have:</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>JOYCAPS_HASZ</term>
            <term>Joystick has z-coordinate information.</term>
            </item>
            <item>
            <term>JOYCAPS_HASR</term>
            <term>Joystick has rudder (fourth axis) information.</term>
            </item>
            <item>
            <term>JOYCAPS_HASU</term>
            <term>Joystick has u-coordinate (fifth axis) information.</term>
            </item>
            <item>
            <term>JOYCAPS_HASV</term>
            <term>Joystick has v-coordinate (sixth axis) information.</term>
            </item>
            <item>
            <term>JOYCAPS_HASPOV</term>
            <term>Joystick has point-of-view information.</term>
            </item>
            <item>
            <term>JOYCAPS_POV4DIR</term>
            <term>Joystick point-of-view supports discrete values (centered, forward, backward, left, and right).</term>
            </item>
            <item>
            <term>JOYCAPS_POVCTS</term>
            <term>Joystick point-of-view supports continuous degree bearings.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wMaxAxes">
            <summary>Maximum number of axes supported by the joystick.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wNumAxes">
            <summary>Number of axes currently in use by the joystick.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.wMaxButtons">
            <summary>Maximum number of buttons supported by the joystick.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.szRegKey">
            <summary>Null-terminated string containing the registry key for the joystick.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYCAPS.szOEMVxD">
            <summary>Null-terminated string identifying the joystick driver OEM.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.JOYINFO">
            <summary>The <c>JOYINFO</c> structure contains information about the joystick position and button state.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFO.wXpos">
            <summary>Current X-coordinate.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFO.wYpos">
            <summary>Current Y-coordinate.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFO.wZpos">
            <summary>Current Z-coordinate.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFO.wButtons">
            <summary>
            <para>Current state of joystick buttons described by one or more of the following values:</para>
            <list type="table">
            <listheader>
            <term>Button</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>JOY_BUTTON1</term>
            <term>First joystick button is pressed.</term>
            </item>
            <item>
            <term>JOY_BUTTON2</term>
            <term>Second joystick button is pressed.</term>
            </item>
            <item>
            <term>JOY_BUTTON3</term>
            <term>Third joystick button is pressed.</term>
            </item>
            <item>
            <term>JOY_BUTTON4</term>
            <term>Fourth joystick button is pressed.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.JOYINFOEX">
            <summary>
            The <c>JOYINFOEX</c> structure contains extended information about the joystick position, point-of-view position, and button state.
            </summary>
            <remarks>
            <para>
            The value of the <c>dwSize</c> member is also used to identify the version number for the structure when it's passed to the
            joyGetPosEx function.
            </para>
            <para>
            Most devices with a point-of-view control have only five positions. When the JOY_RETURNPOV flag is set, these positions are
            reported by using the following constants:
            </para>
            <list type="table">
            <listheader>
            <term>Point-Of-View Flag</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>JOY_POVBACKWARD</term>
            <term>Point-of-view hat is pressed backward. The value 18,000 represents an orientation of 180.00 degrees (to the rear).</term>
            </item>
            <item>
            <term>JOY_POVCENTERED</term>
            <term>Point-of-view hat is in the neutral position. The value -1 means the point-of-view hat has no angle to report.</term>
            </item>
            <item>
            <term>JOY_POVFORWARD</term>
            <term>Point-of-view hat is pressed forward. The value 0 represents an orientation of 0.00 degrees (straight ahead).</term>
            </item>
            <item>
            <term>JOY_POVLEFT</term>
            <term>
            Point-of-view hat is being pressed to the left. The value 27,000 represents an orientation of 270.00 degrees (90.00 degrees to
            the left).
            </term>
            </item>
            <item>
            <term>JOY_POVRIGHT</term>
            <term>Point-of-view hat is pressed to the right. The value 9,000 represents an orientation of 90.00 degrees (to the right).</term>
            </item>
            </list>
            <para>
            The default joystick driver currently supports these five discrete directions. If an application can accept only the defined
            point-of-view values, it must use the JOY_RETURNPOV flag. If an application can accept other degree readings, it should use the
            JOY_RETURNPOVCTS flag to obtain continuous data if it is available. The JOY_RETURNPOVCTS flag also supports the JOY_POV
            constants used with the JOY_RETURNPOV flag.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwSize">
            <summary>Size, in bytes, of this structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwFlags">
            <summary>
            <para>
            Flags indicating the valid information returned in this structure. Members that do not contain valid information are set to
            zero. The following flags are defined:
            </para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>JOY_RETURNALL</term>
            <term>Equivalent to setting all of the JOY_RETURN bits except JOY_RETURNRAWDATA.</term>
            </item>
            <item>
            <term>JOY_RETURNBUTTONS</term>
            <term>The dwButtons member contains valid information about the state of each joystick button.</term>
            </item>
            <item>
            <term>JOY_RETURNCENTERED</term>
            <term>Centers the joystick neutral position to the middle value of each axis of movement.</term>
            </item>
            <item>
            <term>JOY_RETURNPOV</term>
            <term>The dwPOV member contains valid information about the point-of-view control, expressed in discrete units.</term>
            </item>
            <item>
            <term>JOY_RETURNPOVCTS</term>
            <term>
            The dwPOV member contains valid information about the point-of-view control expressed in continuous, one-hundredth degree units.
            </term>
            </item>
            <item>
            <term>JOY_RETURNR</term>
            <term>The dwRpos member contains valid rudder pedal data. This information represents another (fourth) axis.</term>
            </item>
            <item>
            <term>JOY_RETURNRAWDATA</term>
            <term>Data stored in this structure is uncalibrated joystick readings.</term>
            </item>
            <item>
            <term>JOY_RETURNU</term>
            <term>
            The dwUpos member contains valid data for a fifth axis of the joystick, if such an axis is available, or returns zero otherwise.
            </term>
            </item>
            <item>
            <term>JOY_RETURNV</term>
            <term>
            The dwVpos member contains valid data for a sixth axis of the joystick, if such an axis is available, or returns zero otherwise.
            </term>
            </item>
            <item>
            <term>JOY_RETURNX</term>
            <term>The dwXpos member contains valid data for the x-coordinate of the joystick.</term>
            </item>
            <item>
            <term>JOY_RETURNY</term>
            <term>The dwYpos member contains valid data for the y-coordinate of the joystick.</term>
            </item>
            <item>
            <term>JOY_RETURNZ</term>
            <term>The dwZpos member contains valid data for the z-coordinate of the joystick.</term>
            </item>
            </list>
            <para>The following flags provide data to calibrate a joystick and are intended for custom calibration applications.</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>JOY_CAL_READ3</term>
            <term>Read the x-, y-, and z-coordinates and store the raw values in dwXpos, dwYpos, and dwZpos.</term>
            </item>
            <item>
            <term>JOY_CAL_READ4</term>
            <term>
            Read the rudder information and the x-, y-, and z-coordinates and store the raw values in dwXpos, dwYpos, dwZpos, and dwRpos.
            </term>
            </item>
            <item>
            <term>JOY_CAL_READ5</term>
            <term>
            Read the rudder information and the x-, y-, z-, and u-coordinates and store the raw values in dwXpos, dwYpos, dwZpos,
            dwRpos, and dwUpos.
            </term>
            </item>
            <item>
            <term>JOY_CAL_READ6</term>
            <term>Read the raw v-axis data if a joystick mini driver is present that will provide the data. Returns zero otherwise.</term>
            </item>
            <item>
            <term>JOY_CAL_READALWAYS</term>
            <term>Read the joystick port even if the driver does not detect a device.</term>
            </item>
            <item>
            <term>JOY_CAL_READRONLY</term>
            <term>
            Read the rudder information if a joystick mini-driver is present that will provide the data and store the raw value in
            dwRpos. Return zero otherwise.
            </term>
            </item>
            <item>
            <term>JOY_CAL_READXONLY</term>
            <term>Read the x-coordinate and store the raw (uncalibrated) value in dwXpos.</term>
            </item>
            <item>
            <term>JOY_CAL_READXYONLY</term>
            <term>Reads the x- and y-coordinates and place the raw values in dwXpos and dwYpos.</term>
            </item>
            <item>
            <term>JOY_CAL_READYONLY</term>
            <term>Reads the y-coordinate and store the raw value in dwYpos.</term>
            </item>
            <item>
            <term>JOY_CAL_READZONLY</term>
            <term>Read the z-coordinate and store the raw value in dwZpos.</term>
            </item>
            <item>
            <term>JOY_CAL_READUONLY</term>
            <term>
            Read the u-coordinate if a joystick mini-driver is present that will provide the data and store the raw value in dwUpos.
            Return zero otherwise.
            </term>
            </item>
            <item>
            <term>JOY_CAL_READVONLY</term>
            <term>
            Read the v-coordinate if a joystick mini-driver is present that will provide the data and store the raw value in dwVpos.
            Return zero otherwise.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwXpos">
            <summary>Current X-coordinate.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwYpos">
            <summary>Current Y-coordinate.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwZpos">
            <summary>Current Z-coordinate.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwRpos">
            <summary>Current position of the rudder or fourth joystick axis.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwUpos">
            <summary>Current fifth axis position.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwVpos">
            <summary>Current sixth axis position.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwButtons">
            <summary>
            Current state of the 32 joystick buttons. The value of this member can be set to any combination of JOY_BUTTON n flags,
            where n is a value in the range of 1 through 32 corresponding to the button that is pressed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwButtonNumber">
            <summary>Current button number that is pressed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwPOV">
            <summary>
            Current position of the point-of-view control. Values for this member are in the range 0 through 35,900. These values
            represent the angle, in degrees, of each view multiplied by 100.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwReserved1">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYINFOEX.dwReserved2">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_POV_NUMDIRS">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.JOY_ISCAL">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_ISCAL.JOY_ISCAL_XY">
            <summary>XY are calibrated</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_ISCAL.JOY_ISCAL_Z">
            <summary>Z is calibrated</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_ISCAL.JOY_ISCAL_R">
            <summary>R is calibrated</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_ISCAL.JOY_ISCAL_U">
            <summary>U is calibrated</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_ISCAL.JOY_ISCAL_V">
            <summary>V is calibrated</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_ISCAL.JOY_ISCAL_POV">
            <summary>POV is calibrated</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.JOY_POVVAL">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_POVVAL.JOY_POVVAL_FORWARD">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_POVVAL.JOY_POVVAL_BACKWARD">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_POVVAL.JOY_POVVAL_LEFT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOY_POVVAL.JOY_POVVAL_RIGHT">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.JOYPOS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYPOS.dwX">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYPOS.dwY">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYPOS.dwZ">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYPOS.dwR">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYPOS.dwU">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYPOS.dwV">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.JOYRANGE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYRANGE.jpMin">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYRANGE.jpMax">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYRANGE.jpCenter">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.JOYREGHWVALUES">
            <summary>The <c>JOYREGHWVALUES</c> structure contains the range of values returned by the hardware (filled in by calibration).</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYREGHWVALUES.jrvHardware">
            <summary>The values returned by the hardware.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYREGHWVALUES.dwPOVValues">
            <summary>The point-of-view (POV) values returned by the hardware.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.JOYREGHWVALUES.dwCalFlags">
            <summary>What has been calibrated.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MDEVICECAPSEX">
            <summary>
            The
            <code>MDEVICECAPSEX</code>
            structure contains device capability information for Plug and Play (PnP) device drivers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MDEVICECAPSEX.cbSize">
            <summary>Specifies the size of the structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MDEVICECAPSEX.pCaps">
            <summary>Specifies the capabilities of the device. The format of this data is device specific.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIDIOPENDESC">
            <summary>
            The
            <code>MIDIOPENDESC</code>
            structure is a client-filled structure that provides information about how to open a MIDI device.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOPENDESC.hMidi">
            <summary>
            Specifies the handle that the client uses to reference the device. This handle is assigned by WINMM. Use this handle when
            you notify the client with the DriverCallback function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOPENDESC.dwCallback">
            <summary>
            Specifies either the address of a callback function, a window handle, or a task handle, depending on the flags that are
            specified in the dwParam2 parameter of the MODM_OPEN message. If this field contains a handle, it is contained in the
            low-order word.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOPENDESC.dwInstance">
            <summary>
            Specifies a pointer to a DWORD that contains instance information for the client. This instance information is returned to
            the client whenever the driver notifies the client by using the <c>DriverCallback</c> function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOPENDESC.dnDevNode">
            <summary>Specifies a device node for the MIDI output device, if it is a Plug and Play (PnP) MIDI device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOPENDESC.cIds">
            <summary>Specifies the number of stream identifiers, if a stream is open.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOPENDESC.rgIds">
            <summary>Specifies an array of device identifiers. The number of identifiers is given by the <c>cIds</c> member.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIDIOPENSTRMID">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOPENSTRMID.dwStreamID">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOPENSTRMID.uDeviceID">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.AUX_CAPS">
            <summary>Describes optional functionality supported by the auxiliary audio device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.AUX_CAPS.AUXCAPS_VOLUME">
            <summary>Supports volume control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.AUX_CAPS.AUXCAPS_LRVOLUME">
            <summary>Supports separate left and right volume control.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.auxGetDevCaps(System.UInt32,Vanara.PInvoke.WinMm.AUXCAPS@,System.UInt32)">
            <summary>The <c>auxGetDevCaps</c> function retrieves the capabilities of a given auxiliary output device.</summary>
            <param name="uDeviceID">
            <para>
            Identifier of the auxiliary output device to be queried. Specify a valid device identifier (see the following comments section),
            or use the following constant:
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AUX_MAPPER</term>
            <term>Auxiliary audio mapper. The function returns an error if no auxiliary audio mapper is installed.</term>
            </item>
            </list>
            </param>
            <param name="pac">Pointer to an AUXCAPS structure to be filled with information about the capabilities of the device.</param>
            <param name="cbac">Size, in bytes, of the AUXCAPS structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>Specified device identifier is out of range.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The device identifier in uDeviceID varies from zero to one less than the number of devices present. AUX_MAPPER may also be used.
            Use the auxGetNumDevs function to determine the number of auxiliary output devices present in the system.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.auxGetNumDevs">
            <summary>The <c>auxGetNumDevs</c> function retrieves the number of auxiliary output devices present in the system.</summary>
            <returns>Returns the number of device. A return value of zero means that no devices are present or that an error occurred.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.auxGetVolume(System.UInt32,System.UInt32@)">
            <summary>The <c>auxGetVolume</c> function retrieves the current volume setting of the specified auxiliary output device.</summary>
            <param name="uDeviceID">Identifier of the auxiliary output device to be queried.</param>
            <param name="pdwVolume">
            <para>
            Pointer to a variable to be filled with the current volume setting. The low-order word of this location contains the left
            channel volume setting, and the high-order word contains the right channel setting. A value of 0xFFFF represents full volume,
            and a value of 0x0000 is silence.
            </para>
            <para>
            If a device does not support both left and right volume control, the low-order word of the specified location contains the
            volume level.
            </para>
            <para>
            The full 16-bit setting(s) set with the auxSetVolume function are returned, regardless of whether the device supports the full
            16 bits of volume-level control.
            </para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>Specified device identifier is out of range.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Not all devices support volume control. To determine whether a device supports volume control, use the AUXCAPS_VOLUME flag to
            test the <c>dwSupport</c> member of the AUXCAPS structure (filled by the auxGetDevCaps function).
            </para>
            <para>
            To determine whether a device supports volume control on both the left and right channels, use the AUXCAPS_LRVOLUME flag to test
            the <c>dwSupport</c> member of the AUXCAPS structure (filled by auxGetDevCaps).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.auxOutMessage(System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            The <c>auxOutMessage</c> function sends a message to the given auxiliary output device. This function also performs error
            checking on the device identifier passed as part of the message.
            </summary>
            <param name="uDeviceID">Identifier of the auxiliary output device to receive the message.</param>
            <param name="uMsg">Message to send.</param>
            <param name="dw1">Message parameter.</param>
            <param name="dw2">Message parameter.</param>
            <returns>Returns the message return value.</returns>
            <remarks>
            <para>The
            <code>DRV_QUERYDEVICEINTERFACE</code>
            message queries for the device-interface name of a <c>waveIn</c>, <c>waveOut</c>, <c>midiIn</c>, <c>midiOut</c>, or <c>mixer</c> device.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACE</code>
            , dwParam1 is a pointer to a caller-allocated buffer into which the function writes a null-terminated Unicode string containing
            the device-interface name. If the device has no device interface, the string length is zero.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACE</code>
            , dwParam2 specifies the buffer size in bytes. This is an input parameter to the function. The caller should specify a size that
            is greater than or equal to the buffer size retrieved by the DRV_QUERYDEVICEINTERFACESIZE message.
            </para>
            <para>
            The DRV_QUERYDEVICEINTERFACE message is supported in Windows Me, and Windows 2000 and later. This message is valid only for the
            waveInMessage, waveOutMessage, midiInMessage, midiOutMessage, and mixerMessage functions. The system intercepts this message and
            returns the appropriate value without sending the message to the device driver. For general information about system-intercepted
            <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>The following two message constants are used together for the purpose of obtaining device interface names:</para>
            <list type="bullet">
            <item>
            <term>DRV_QUERYDEVICEINTERFACESIZE</term>
            </item>
            <item>
            <term>DRV_QUERYDEVICEINTERFACE</term>
            </item>
            </list>
            <para>
            The first message obtains the size in bytes of the buffer needed to hold the string containing the device interface name. The
            second message retrieves the name string in a buffer of the required size.
            </para>
            <para>For more information, see Obtaining a Device Interface Name.</para>
            <para>The
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            message queries for the size of the buffer required to hold the device-interface name.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            , dwParam1 is a pointer to buffer size. This parameter points to a ULONG variable into which the function writes the required
            buffer size in bytes. The size includes storage space for the name string's terminating null. The size is zero if the device ID
            identifies a device that has no device interface.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            This message is valid only for the waveInMessage, waveOutMessage, midiInMessage, midiOutMessage, and mixerMessage functions. The
            system intercepts this message and returns the appropriate value without sending the message to the device driver. For general
            information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            The buffer size retrieved by this message is expressed as a byte count. It specifies the size of the buffer needed to hold the
            null-terminated Unicode string that contains the device-interface name. The caller allocates a buffer of the specified size and
            uses the DRV_QUERYDEVICEINTERFACE message to retrieve the device-interface name string.
            </para>
            <para>For more information, see Obtaining a Device Interface Name.</para>
            <para>The
            <code>DRV_QUERYDEVNODE</code>
            message queries for the devnode number assigned to the device by the Plug and Play manager.
            </para>
            <para>For
            <code>DRV_QUERYDEVNODE</code>
            , dwParam1 is a pointer to a caller-allocated DWORD variable into which the function writes the devnode number. If no devnode is
            assigned to the device, the function sets this variable to zero.
            </para>
            <para>For
            <code>DRV_QUERYDEVNODE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            In Windows 2000 and later, the message always returns MMSYSERR_NOTSUPPORTED. This message is valid only for the waveInMessage,
            waveOutMessage, midiInMessage, midiOutMessage, and mixerMessage functions. The system intercepts this message and returns the
            appropriate value without sending the message to the device driver. For general information about system-intercepted
            <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>The
            <code>DRV_QUERYMAPPABLE</code>
            message queries for whether the specified device can be used by a mapper.
            </para>
            <para>For
            <code>DRV_QUERYMAPPABLE</code>
            , dwParam1 is unused. Set this parameter to zero.
            </para>
            <para>For
            <code>DRV_QUERYMAPPABLE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            This message is valid only for the waveInMessage, waveOutMessage, midiInMessage, midiOutMessage, mixerMessage and
            <c>auxOutMessage</c> functions. The system intercepts this message and returns the appropriate value without sending the message
            to the device driver. For general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted
            Device Messages.
            </para>
            <para>
            When an application program opens a mapper instead of a specific audio device, the system inserts a mapper between the
            application and the available devices. The mapper selects an appropriate device by mapping the application's requirements to one
            of the available devices. For more information about mappers, see the Microsoft Windows SDK documentation.
            </para>
            <para>The
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            message retrieves the device ID of the preferred voice-communications device.
            </para>
            <para>For
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            , dwParam1 is a pointer to device ID. This parameter points to a DWORD variable into which the function writes the device ID of
            the current preferred voice-communications device. The function writes the value (-1) if no device is available that qualifies
            as a preferred voice-communications device.
            </para>
            <para>For
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            , dwParam2 is a pointer to status flags. This parameter points to a DWORD variable into which the function writes the
            device-status flags. Only one flag bit is currently defined: DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY.
            </para>
            <para>
            This message is valid only for the waveInMessage and waveOutMessage functions. When a caller calls these two functions with the
            DRVM_MAPPER_CONSOLEVOICECOM_GET message, the caller must specify the device ID as WAVE_MAPPER, and then cast this value to the
            appropriate handle type. For the <c>waveInMessage</c>, <c>waveOutMessage</c>, midiInMessage, midiOutMessage, or mixerMessage
            functions, the caller must cast the device ID to a handle of type HWAVEIN, HWAVEOUT, HMIDIIN, HMIDIOUT, or HMIXER, respectively.
            Note that if the caller supplies a valid handle instead of a device ID for this parameter, the function fails and returns error
            code MMSYSERR_NOSUPPORT.
            </para>
            <para>
            The system intercepts this message and returns the appropriate value without sending the message to the device driver. For
            general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            This message provides a way to determine which device is preferred specifically for voice communications, in contrast to the
            DRVM_MAPPER_PREFERRED_GET message, which determines which device is preferred for all other audio functions.
            </para>
            <para>
            For example, the preferred <c>waveOut</c> device for voice communications might be the earpiece in a headset, but the preferred
            <c>waveOut</c> device for all other audio functions might be a set of stereo speakers.
            </para>
            <para>
            When the DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY flag bit is set in the DWORD location pointed to by dwParam2, the
            <c>waveIn</c> and <c>waveOut</c> APIs use only the current preferred voice-communications device and do not search for other
            available devices if the preferred device is unavailable. The flag that is output by either the <c>waveInMessage</c> or
            <c>waveOutMessage</c> call applies to the preferred voice-communications device for both the <c>waveIn</c> and <c>waveOut</c>
            APIs, regardless of whether the call is made to <c>waveInMessage</c> or <c>waveOutMessage</c>. For more information, see
            Preferred Voice-Communications Device ID.
            </para>
            <para>The
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            message retrieves the device ID of the preferred audio device.
            </para>
            <para>For
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            , dwParam1 is a pointer to device ID. This parameter points to a DWORD variable into which the function writes the device ID of
            the current preferred device. The function writes the value (-1) if no device is available that qualifies as a preferred device.
            </para>
            <para>For
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            , dwParam2 is a pointer to status flags. This parameter points to a DWORD variable into which the function writes the
            device-status flags. Only one flag bit is currently defined (for <c>waveInMessage</c> and <c>waveOutMessage</c> calls only): DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY.
            </para>
            <para>
            This message is valid only for the waveInMessage, waveOutMessage and midiOutMessage functions. When the caller calls these
            functions with the DRVM_MAPPER_PREFERRED_GET message, the caller must first specify the device ID as WAVE_MAPPER (for
            <c>waveInMessage</c> or <c>waveOutMessage</c>) or MIDI_MAPPER (for <c>midiOutMessage</c>), and then cast this value to the
            appropriate handle type. For the <c>waveInMessage</c>, <c>waveOutMessage</c>, or <c>midiOutMessage</c> functions, the caller
            must cast the device ID to a handle type HWAVEIN, HWAVEOUT or HMIDIOUT, respectively. Note that if the caller supplies a valid
            handle instead of a device ID for this parameter, the function fails and returns error code MMSYSERR_NOSUPPORT.
            </para>
            <para>
            The system intercepts this message and returns the appropriate value without sending the message to the device driver. For
            general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            This message provides a way to determine which device is preferred for audio functions in general, in contrast to the
            DRVM_MAPPER_CONSOLEVOICECOM_GET message, which determines which device is preferred specifically for voice communications.
            </para>
            <para>
            When the DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY flag bit is set in the DWORD location pointed to by dwParam2, the
            <c>waveIn</c> and <c>waveOut</c> APIs use only the current preferred device and do not search for other available devices if the
            preferred device is unavailable. Note that the <c>midiOutMessage</c> function does not output this flag--the <c>midiOut</c> API
            always uses only the preferred device. The flag that is output by either the <c>waveInMessage</c> or <c>waveOutMessage</c> call
            applies to the preferred device for both the <c>waveIn</c> and <c>waveOut</c> APIs, regardless of whether the call is made to
            <c>waveInMessage</c> or <c>waveOutMessage</c>.
            </para>
            <para>
            The xxxMessage functions accept this value in place of a valid device handle in order to allow an application to determine the
            default device ID without first having to open a device. For more information, see Accessing the Preferred Device ID.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.auxSetVolume(System.UInt32,System.UInt32)">
            <summary>The <c>auxSetVolume</c> function sets the volume of the specified auxiliary output device.</summary>
            <param name="uDeviceID">
            Identifier of the auxiliary output device to be queried. Device identifiers are determined implicitly from the number of devices
            present in the system. Device identifier values range from zero to one less than the number of devices present. Use the
            auxGetNumDevs function to determine the number of auxiliary devices in the system.
            </param>
            <param name="dwVolume">
            <para>
            Specifies the new volume setting. The low-order word specifies the left-channel volume setting, and the high-order word
            specifies the right-channel setting. A value of 0xFFFF represents full volume, and a value of 0x0000 is silence.
            </para>
            <para>
            If a device does not support both left and right volume control, the low-order word of dwVolume specifies the volume level, and
            the high-order word is ignored.
            </para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>Specified device identifier is out of range.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Not all devices support volume control. To determine whether the device supports volume control, use the AUXCAPS_VOLUME flag to
            test the <c>dwSupport</c> member of the AUXCAPS structure (filled by the auxGetDevCaps function).
            </para>
            <para>
            To determine whether the device supports volume control on both the left and right channels, use the AUXCAPS_LRVOLUME flag to
            test the <c>dwSupport</c> member of the AUXCAPS structure (filled by auxGetDevCaps).
            </para>
            <para>
            Most devices do not support the full 16 bits of volume-level control and will use only the high-order bits of the requested
            volume setting. For example, for a device that supports 4 bits of volume control, requested volume level values of 0x4000,
            0x4FFF, and 0x43BE will produce the same physical volume setting, 0x4000. The auxGetVolume function will return the full 16-bit
            setting set with <c>auxSetVolume</c>.
            </para>
            <para>
            Volume settings are interpreted logarithmically. This means the perceived volume increase is the same when increasing the volume
            level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.AUXCAPS">
            <summary>The <c>AUXCAPS</c> structure describes the capabilities of an auxiliary output device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.AUXCAPS.wMid">
            <summary>
            Manufacturer identifier for the device driver for the auxiliary audio device. Manufacturer identifiers are defined in
            Manufacturer and Product Identifiers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.AUXCAPS.wPid">
            <summary>
            Product identifier for the auxiliary audio device. Currently, no product identifiers are defined for auxiliary audio devices.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.AUXCAPS.vDriverVersion">
            <summary>
            Version number of the device driver for the auxiliary audio device. The high-order byte is the major version number, and the
            low-order byte is the minor version number.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.AUXCAPS.szPname">
            <summary>Product name in a null-terminated string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.AUXCAPS.wTechnology">
            <summary>
            <para>Type of the auxiliary audio output:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AUXCAPS_AUXIN</term>
            <term>Audio output from auxiliary input jacks.</term>
            </item>
            <item>
            <term>AUXCAPS_CDAUDIO</term>
            <term>Audio output from an internal CD-ROM drive.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.AUXCAPS.dwSupport">
            <summary>
            <para>Describes optional functionality supported by the auxiliary audio device.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AUXCAPS_LRVOLUME</term>
            <term>Supports separate left and right volume control.</term>
            </item>
            <item>
            <term>AUXCAPS_VOLUME</term>
            <term>Supports volume control.</term>
            </item>
            </list>
            <para>
            If a device supports volume changes, the AUXCAPS_VOLUME flag will be set. If a device supports separate volume changes on
            the left and right channels, both AUXCAPS_VOLUME and the AUXCAPS_LRVOLUME will be set.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIPATCHSIZE">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MHDR">
            <summary>Flags giving information about the buffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MHDR.MHDR_DONE">
            <summary>Set by the device driver to indicate that it is finished with the buffer and is returning it to the application.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MHDR.MHDR_PREPARED">
            <summary>
            Set by Windows to indicate that the buffer has been prepared by using the midiInPrepareHeader or midiOutPrepareHeader function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MHDR.MHDR_INQUEUE">
            <summary>Set by Windows to indicate that the buffer is queued for playback.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MHDR.MHDR_ISSTRM">
            <summary>Set to indicate that the buffer is a stream buffer.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIDI_CACHE">
            <summary>Options for the cache operation.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDI_CACHE.MIDI_CACHE_ALL">
            <summary>
            Caches all of the specified patches. If they cannot all be cached, it caches none, clears the KEYARRAY array, and returns MMSYSERR_NOMEM.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDI_CACHE.MIDI_CACHE_BESTFIT">
            <summary>
            Caches all of the specified patches. If they cannot all be cached, it caches as many patches as possible, changes the
            KEYARRAY array to reflect which patches were cached, and returns MMSYSERR_NOMEM.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDI_CACHE.MIDI_CACHE_QUERY">
            <summary>Changes the KEYARRAY array to indicate which patches are currently cached.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDI_CACHE.MIDI_UNCACHE">
            <summary>Uncaches the specified patches and clears the KEYARRAY array.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIDI_CAPS">
            <summary>Optional functionality supported by the device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDI_CAPS.MIDICAPS_VOLUME">
            <summary>Supports volume control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDI_CAPS.MIDICAPS_LRVOLUME">
            <summary>Supports separate left and right volume control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDI_CAPS.MIDICAPS_CACHE">
            <summary>Supports patch caching.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDI_CAPS.MIDICAPS_STREAM">
            <summary>Provides direct support for the midiStreamOut function.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIDIPROP">
            <summary>
            Flags that specify the action to perform and identify the appropriate property of the MIDI data stream. The
            <c>midiStreamProperty</c> function requires setting two flags in each use. One flag (either MIDIPROP_GET or MIDIPROP_SET)
            specifies an action, and the other identifies a specific property to examine or edit.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIPROP.MIDIPROP_SET">
            <summary>Sets the given property.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIPROP.MIDIPROP_GET">
            <summary>Retrieves the current setting of the given property.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIPROP.MIDIPROP_TIMEDIV">
            <summary>
            Specifies the time division property. You can get or set this property. The lppropdata parameter points to a MIDIPROPTIMEDIV
            structure. This property can be set only when the device is stopped.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIPROP.MIDIPROP_TEMPO">
            <summary>
            Retrieves the tempo property. The lppropdata parameter points to a MIDIPROPTEMPO structure. The current tempo value can be
            retrieved at any time. Output devices set the tempo by inserting MEVT_TEMPO events into the MIDI data.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MOD">
            <summary>Type of the MIDI output device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MOD.MOD_MIDIPORT">
            <summary>MIDI hardware port.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MOD.MOD_SYNTH">
            <summary>Synthesizer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MOD.MOD_SQSYNTH">
            <summary>Square wave synthesizer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MOD.MOD_FMSYNTH">
            <summary>FM synthesizer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MOD.MOD_MAPPER">
            <summary>Microsoft MIDI mapper.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MOD.MOD_WAVETABLE">
            <summary>Hardware wavetable synthesizer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MOD.MOD_SWSYNTH">
            <summary>Software synthesizer.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiConnect(Vanara.PInvoke.WinMm.HMIDI,Vanara.PInvoke.WinMm.HMIDIOUT,System.IntPtr)">
            <summary>
            The <c>midiConnect</c> function connects a MIDI input device to a MIDI thru or output device, or connects a MIDI thru device to
            a MIDI output device.
            </summary>
            <param name="hmi">
            Handle to a MIDI input device or a MIDI thru device. (For thru devices, this handle must have been returned by a call to the
            midiOutOpen function.)
            </param>
            <param name="hmo">Handle to the MIDI output or thru device.</param>
            <param name="pReserved">Reserved; must be <c>NULL</c>.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIDIERR_NOTREADY</term>
            <term>Specified input device is already connected to an output device.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            After calling this function, the MIDI input device receives event data in an MIM_DATA message whenever a message with the same
            event data is sent to the output device driver.
            </para>
            <para>
            A thru driver is a special form of MIDI output driver. The system will allow only one MIDI output device to be connected to a
            MIDI input device, but multiple MIDI output devices can be connected to a MIDI thru device. Whenever the given MIDI input device
            receives event data in an MIM_DATA message, a message with the same event data is sent to the given output device driver (or
            through the thru driver to the output drivers).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiDisconnect(Vanara.PInvoke.WinMm.HMIDI,Vanara.PInvoke.WinMm.HMIDIOUT,System.IntPtr)">
            <summary>
            The <c>midiDisconnect</c> function disconnects a MIDI input device from a MIDI thru or output device, or disconnects a MIDI thru
            device from a MIDI output device.
            </summary>
            <param name="hmi">Handle to a MIDI input device or a MIDI thru device.</param>
            <param name="hmo">Handle to the MIDI output device to be disconnected.</param>
            <param name="pReserved">Reserved; must be <c>NULL</c>.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following:.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            MIDI input, output, and thru devices can be connected by using the <c>midiConnect</c> function. Thereafter, whenever the MIDI
            input device receives event data in an MIM_DATA message, a message with the same event data is sent to the output device driver
            (or through the thru driver to the output drivers).
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInAddBuffer(Vanara.PInvoke.WinMm.HMIDIIN,Vanara.PInvoke.WinMm.MIDIHDR@,System.UInt32)">
            <summary>
            The <c>midiInAddBuffer</c> function sends an input buffer to a specified opened MIDI input device. This function is used for
            system-exclusive messages.
            </summary>
            <param name="hmi">Handle to the MIDI input device.</param>
            <param name="pmh">Pointer to a MIDIHDR structure that identifies the buffer.</param>
            <param name="cbmh">Size, in bytes, of the MIDIHDR structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIDIERR_STILLPLAYING</term>
            <term>The buffer pointed to by lpMidiInHdr is still in the queue.</term>
            </item>
            <item>
            <term>MIDIERR_UNPREPARED</term>
            <term>The buffer pointed to by lpMidiInHdr has not been prepared.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified pointer or structure is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>When the buffer is filled, it is sent back to the application.</para>
            <para>
            The buffer must be prepared by using the midiInPrepareHeader function before it is passed to the <c>midiInAddBuffer</c> function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInClose(Vanara.PInvoke.WinMm.HMIDIIN)">
            <summary>The <c>midiInClose</c> function closes the specified MIDI input device.</summary>
            <param name="hmi">
            Handle to the MIDI input device. If the function is successful, the handle is no longer valid after the call to this function.
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIDIERR_STILLPLAYING</term>
            <term>Buffers are still in the queue.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            If there are input buffers that have been sent by using the midiInAddBuffer function and have not been returned to the
            application, the close operation will fail. To return all pending buffers through the callback function, use the midiInReset function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInGetDevCaps(System.UInt32,Vanara.PInvoke.WinMm.MIDIINCAPS@,System.UInt32)">
            <summary>The <c>midiInGetDevCaps</c> function determines the capabilities of a specified MIDI input device.</summary>
            <param name="uDeviceID">
            Identifier of the MIDI input device. The device identifier varies from zero to one less than the number of devices present. This
            parameter can also be a properly cast device handle.
            </param>
            <param name="pmic">Pointer to a MIDIINCAPS structure that is filled with information about the capabilities of the device.</param>
            <param name="cbmic">
            Size, in bytes, of the MIDIINCAPS structure. Only cbMidiInCaps bytes (or less) of information is copied to the location pointed
            to by lpMidiInCaps. If cbMidiInCaps is zero, nothing is copied, and the function returns MMSYSERR_NOERROR.
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The specified device identifier is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified pointer or structure is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>The driver is not installed.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>To determine the number of MIDI input devices present on the system, use the midiInGetNumDevs function.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInGetErrorText(Vanara.PInvoke.WinMm.MMRESULT,System.Text.StringBuilder,System.UInt32)">
            <summary>
            The <c>midiInGetErrorText</c> function retrieves a textual description for an error identified by the specified error code.
            </summary>
            <param name="mmrError">Error code.</param>
            <param name="pszText">Pointer to the buffer to be filled with the textual error description.</param>
            <param name="cchText">Length, in characters, of the buffer pointed to by lpText.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADERRNUM</term>
            <term>The specified error number is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified pointer or structure is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            If the textual error description is longer than the specified buffer, the description is truncated. The returned error string is
            always null-terminated. If cchText is zero, nothing is copied, and the function returns zero. All error descriptions are less
            than MAXERRORLENGTH characters long.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInGetID(Vanara.PInvoke.WinMm.HMIDIIN,System.UInt32@)">
            <summary>
            <para>The <c>midiInGetID</c> function gets the device identifier for the given MIDI input device.</para>
            <para>
            This function is supported for backward compatibility. New applications can cast a handle of the device rather than retrieving
            the device identifier.
            </para>
            </summary>
            <param name="hmi">Handle to the MIDI input device.</param>
            <param name="puDeviceID">Pointer to a variable to be filled with the device identifier.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The hwi parameter specifies an invalid handle.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInGetNumDevs">
            <summary>The <c>midiInGetNumDevs</c> function retrieves the number of MIDI input devices in the system.</summary>
            <returns>
            Returns the number of MIDI input devices present in the system. A return value of zero means that there are no devices (not that
            there is no error).
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInMessage(Vanara.PInvoke.WinMm.HMIDIIN,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>The <c>midiInMessage</c> function sends a message to the MIDI device driver.</summary>
            <param name="hmi">
            Identifier of the MIDI device that receives the message. You must cast the device ID to the <c>HMIDIIN</c> handle type. If you
            supply a handle instead of a device ID, the function fails and returns the MMSYSERR_NOSUPPORT error code.
            </param>
            <param name="uMsg">Message to send.</param>
            <param name="dw1">Message parameter.</param>
            <param name="dw2">Message parameter.</param>
            <returns>Returns the value returned by the audio device driver.</returns>
            <remarks>
            <para>This function is used only for driver-specific messages that are not supported by the MIDI API.</para>
            <para>The
            <code>DRV_QUERYDEVICEINTERFACE</code>
            message queries for the device-interface name of a <c>waveIn</c>, <c>waveOut</c>, <c>midiIn</c>, <c>midiOut</c>, or <c>mixer</c> device.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACE</code>
            , dwParam1 is a pointer to a caller-allocated buffer into which the function writes a null-terminated Unicode string containing
            the device-interface name. If the device has no device interface, the string length is zero.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACE</code>
            , dwParam2 specifies the buffer size in bytes. This is an input parameter to the function. The caller should specify a size that
            is greater than or equal to the buffer size retrieved by the DRV_QUERYDEVICEINTERFACESIZE message.
            </para>
            <para>
            The DRV_QUERYDEVICEINTERFACE message is supported in Windows Me, and Windows 2000 and later. This message is valid only for the
            waveInMessage, waveOutMessage, <c>midiInMessage</c>, midiOutMessage, and mixerMessage functions. The system intercepts this
            message and returns the appropriate value without sending the message to the device driver. For general information about
            system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>The following two message constants are used together for the purpose of obtaining device interface names:</para>
            <list type="bullet">
            <item>
            <term>DRV_QUERYDEVICEINTERFACESIZE</term>
            </item>
            <item>
            <term>DRV_QUERYDEVICEINTERFACE</term>
            </item>
            </list>
            <para>
            The first message obtains the size in bytes of the buffer needed to hold the string containing the device interface name. The
            second message retrieves the name string in a buffer of the required size.
            </para>
            <para>For more information, see Obtaining a Device Interface Name.</para>
            <para>The
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            message queries for the size of the buffer required to hold the device-interface name.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            , dwParam1 is a pointer to buffer size. This parameter points to a ULONG variable into which the function writes the required
            buffer size in bytes. The size includes storage space for the name string's terminating null. The size is zero if the device ID
            identifies a device that has no device interface.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            This message is valid only for the waveInMessage, waveOutMessage, <c>midiInMessage</c>, midiOutMessage, and mixerMessage
            functions. The system intercepts this message and returns the appropriate value without sending the message to the device
            driver. For general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            The buffer size retrieved by this message is expressed as a byte count. It specifies the size of the buffer needed to hold the
            null-terminated Unicode string that contains the device-interface name. The caller allocates a buffer of the specified size and
            uses the DRV_QUERYDEVICEINTERFACE message to retrieve the device-interface name string.
            </para>
            <para>For more information, see Obtaining a Device Interface Name.</para>
            <para>The
            <code>DRV_QUERYDEVNODE</code>
            message queries for the devnode number assigned to the device by the Plug and Play manager.
            </para>
            <para>For
            <code>DRV_QUERYDEVNODE</code>
            , dwParam1 is a pointer to a caller-allocated DWORD variable into which the function writes the devnode number. If no devnode is
            assigned to the device, the function sets this variable to zero.
            </para>
            <para>For
            <code>DRV_QUERYDEVNODE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            In Windows 2000 and later, the message always returns MMSYSERR_NOTSUPPORTED. This message is valid only for the waveInMessage,
            waveOutMessage, <c>midiInMessage</c>, midiOutMessage, and mixerMessage functions. The system intercepts this message and returns
            the appropriate value without sending the message to the device driver. For general information about system-intercepted
            <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>The
            <code>DRV_QUERYMAPPABLE</code>
            message queries for whether the specified device can be used by a mapper.
            </para>
            <para>For
            <code>DRV_QUERYMAPPABLE</code>
            , dwParam1 is unused. Set this parameter to zero.
            </para>
            <para>For
            <code>DRV_QUERYMAPPABLE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            This message is valid only for the waveInMessage, waveOutMessage, <c>midiInMessage</c>, midiOutMessage, mixerMessage and
            auxOutMessage functions. The system intercepts this message and returns the appropriate value without sending the message to the
            device driver. For general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            When an application program opens a mapper instead of a specific audio device, the system inserts a mapper between the
            application and the available devices. The mapper selects an appropriate device by mapping the application's requirements to one
            of the available devices. For more information about mappers, see the Microsoft Windows SDK documentation.
            </para>
            <para>The
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            message retrieves the device ID of the preferred voice-communications device.
            </para>
            <para>For
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            , dwParam1 is a pointer to device ID. This parameter points to a DWORD variable into which the function writes the device ID of
            the current preferred voice-communications device. The function writes the value (-1) if no device is available that qualifies
            as a preferred voice-communications device.
            </para>
            <para>For
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            , dwParam2 is a pointer to status flags. This parameter points to a DWORD variable into which the function writes the
            device-status flags. Only one flag bit is currently defined: DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY.
            </para>
            <para>
            This message is valid only for the waveInMessage and waveOutMessage functions. When a caller calls these two functions with the
            DRVM_MAPPER_CONSOLEVOICECOM_GET message, the caller must specify the device ID as WAVE_MAPPER, and then cast this value to the
            appropriate handle type. For the <c>waveInMessage</c>, <c>waveOutMessage</c>, <c>midiInMessage</c>, midiOutMessage, or
            mixerMessage functions, the caller must cast the device ID to a handle of type HWAVEIN, HWAVEOUT, HMIDIIN, HMIDIOUT, or HMIXER,
            respectively. Note that if the caller supplies a valid handle instead of a device ID for this parameter, the function fails and
            returns error code MMSYSERR_NOSUPPORT.
            </para>
            <para>
            The system intercepts this message and returns the appropriate value without sending the message to the device driver. For
            general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            This message provides a way to determine which device is preferred specifically for voice communications, in contrast to the
            DRVM_MAPPER_PREFERRED_GET message, which determines which device is preferred for all other audio functions.
            </para>
            <para>
            For example, the preferred <c>waveOut</c> device for voice communications might be the earpiece in a headset, but the preferred
            <c>waveOut</c> device for all other audio functions might be a set of stereo speakers.
            </para>
            <para>
            When the DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY flag bit is set in the DWORD location pointed to by dwParam2, the
            <c>waveIn</c> and <c>waveOut</c> APIs use only the current preferred voice-communications device and do not search for other
            available devices if the preferred device is unavailable. The flag that is output by either the <c>waveInMessage</c> or
            <c>waveOutMessage</c> call applies to the preferred voice-communications device for both the <c>waveIn</c> and <c>waveOut</c>
            APIs, regardless of whether the call is made to <c>waveInMessage</c> or <c>waveOutMessage</c>. For more information, see
            Preferred Voice-Communications Device ID.
            </para>
            <para>The
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            message retrieves the device ID of the preferred audio device.
            </para>
            <para>For
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            , dwParam1 is a pointer to device ID. This parameter points to a DWORD variable into which the function writes the device ID of
            the current preferred device. The function writes the value (-1) if no device is available that qualifies as a preferred device.
            </para>
            <para>For
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            , dwParam2 is a pointer to status flags. This parameter points to a DWORD variable into which the function writes the
            device-status flags. Only one flag bit is currently defined (for <c>waveInMessage</c> and <c>waveOutMessage</c> calls only): DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY.
            </para>
            <para>
            This message is valid only for the waveInMessage, waveOutMessage and midiOutMessage functions. When the caller calls these
            functions with the DRVM_MAPPER_PREFERRED_GET message, the caller must first specify the device ID as WAVE_MAPPER (for
            <c>waveInMessage</c> or <c>waveOutMessage</c>) or MIDI_MAPPER (for <c>midiOutMessage</c>), and then cast this value to the
            appropriate handle type. For the <c>waveInMessage</c>, <c>waveOutMessage</c>, or <c>midiOutMessage</c> functions, the caller
            must cast the device ID to a handle type HWAVEIN, HWAVEOUT or HMIDIOUT, respectively. Note that if the caller supplies a valid
            handle instead of a device ID for this parameter, the function fails and returns error code MMSYSERR_NOSUPPORT.
            </para>
            <para>
            The system intercepts this message and returns the appropriate value without sending the message to the device driver. For
            general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            This message provides a way to determine which device is preferred for audio functions in general, in contrast to the
            DRVM_MAPPER_CONSOLEVOICECOM_GET message, which determines which device is preferred specifically for voice communications.
            </para>
            <para>
            When the DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY flag bit is set in the DWORD location pointed to by dwParam2, the
            <c>waveIn</c> and <c>waveOut</c> APIs use only the current preferred device and do not search for other available devices if the
            preferred device is unavailable. Note that the <c>midiOutMessage</c> function does not output this flag--the <c>midiOut</c> API
            always uses only the preferred device. The flag that is output by either the <c>waveInMessage</c> or <c>waveOutMessage</c> call
            applies to the preferred device for both the <c>waveIn</c> and <c>waveOut</c> APIs, regardless of whether the call is made to
            <c>waveInMessage</c> or <c>waveOutMessage</c>.
            </para>
            <para>
            The xxxMessage functions accept this value in place of a valid device handle in order to allow an application to determine the
            default device ID without first having to open a device. For more information, see Accessing the Preferred Device ID.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInOpen(Vanara.PInvoke.WinMm.HMIDIIN@,System.UInt32,System.IntPtr,System.IntPtr,Vanara.PInvoke.WinMm.CALLBACK_FLAGS)">
            <summary>The <c>midiInOpen</c> function opens a specified MIDI input device.</summary>
            <param name="phmi">
            Pointer to an <c>HMIDIIN</c> handle. This location is filled with a handle identifying the opened MIDI input device. The handle
            is used to identify the device in calls to other MIDI input functions.
            </param>
            <param name="uDeviceID">Identifier of the MIDI input device to be opened.</param>
            <param name="dwCallback">
            Pointer to a callback function, a thread identifier, or a handle of a window called with information about incoming MIDI
            messages. For more information on the callback function, see MidiInProc.
            </param>
            <param name="dwInstance">
            User instance data passed to the callback function. This parameter is not used with window callback functions or threads.
            </param>
            <param name="fdwOpen">
            <para>
            Callback flag for opening the device and, optionally, a status flag that helps regulate rapid data transfers. It can be the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>CALLBACK_FUNCTION</term>
            <term>The dwCallback parameter is a callback procedure address.</term>
            </item>
            <item>
            <term>CALLBACK_NULL</term>
            <term>There is no callback mechanism. This value is the default setting.</term>
            </item>
            <item>
            <term>CALLBACK_THREAD</term>
            <term>The dwCallback parameter is a thread identifier.</term>
            </item>
            <item>
            <term>CALLBACK_WINDOW</term>
            <term>The dwCallback parameter is a window handle.</term>
            </item>
            <item>
            <term>MIDI_IO_STATUS</term>
            <term>
            When this parameter also specifies CALLBACK_FUNCTION, MIM_MOREDATA messages are sent to the callback function as well as
            MIM_DATA messages. Or, if this parameter also specifies CALLBACK_WINDOW, MM_MIM_MOREDATA messages are sent to the window as well
            as MM_MIM_DATA messages. This flag does not affect event or thread callbacks.
            </term>
            </item>
            </list>
            <para>Most applications that use a callback mechanism will specify CALLBACK_FUNCTION for this parameter.</para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following/</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_ALLOCATED</term>
            <term>The specified resource is already allocated.</term>
            </item>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The specified device identifier is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>The flags specified by dwFlags are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified pointer or structure is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            To determine the number of MIDI input devices present in the system, use the midiInGetNumDevs function. The device identifier
            specified by wDeviceID varies from zero to one less than the number of devices present.
            </para>
            <para>
            If a window or thread is chosen to receive callback information, the following messages are sent to the window procedure or
            thread to indicate the progress of MIDI input: MM_MIM_OPEN, MM_MIM_CLOSE, MM_MIM_DATA, MM_MIM_LONGDATA, MM_MIM_ERROR,
            MM_MIM_LONGERROR, and MM_MIM_MOREDATA.
            </para>
            <para>
            If a function is chosen to receive callback information, the following messages are sent to the function to indicate the
            progress of MIDI input: MIM_OPEN, MIM_CLOSE, MIM_DATA, MIM_LONGDATA, MIM_ERROR, MIM_LONGERROR, and MIM_MOREDATA.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInPrepareHeader(Vanara.PInvoke.WinMm.HMIDIIN,Vanara.PInvoke.WinMm.MIDIHDR@,System.UInt32)">
            <summary>The <c>midiInPrepareHeader</c> function prepares a buffer for MIDI input.</summary>
            <param name="hmi">Handle to the MIDI input device. To get the device handle, call midiInOpen.</param>
            <param name="pmh">
            <para>Pointer to a MIDIHDR structure that identifies the buffer to be prepared.</para>
            <para>
            Before calling the function, set the <c>lpData</c>, <c>dwBufferLength</c>, and <c>dwFlags</c> members of the MIDIHDR structure.
            The <c>dwFlags</c> member must be set to zero.
            </para>
            </param>
            <param name="cbmh">Size, in bytes, of the MIDIHDR structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified address is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Before you pass a MIDI data block to a device driver, you must prepare the buffer by passing it to the
            <c>midiInPrepareHeader</c> function. After the header has been prepared, do not modify the buffer. After the driver is done
            using the buffer, call the midiInUnprepareHeader function.
            </para>
            <para>
            The application can re-use the same buffer, or allocate multiple buffers and call <c>midiInPrepareHeader</c> for each buffer. If
            you re-use the same buffer, it is not necessary to prepare the buffer each time. You can call <c>midiInPrepareHeader</c> once at
            the beginning and then call midiInUnprepareHeader once at the end.
            </para>
            <para>Preparing a header that has already been prepared has no effect, and the function returns zero.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInReset(Vanara.PInvoke.WinMm.HMIDIIN)">
            <summary>The <c>midiInReset</c> function stops input on a given MIDI input device.</summary>
            <param name="hmi">Handle to the MIDI input device.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            This function returns all pending input buffers to the callback function and sets the MHDR_DONE flag in the <c>dwFlags</c>
            member of the MIDIHDR structure.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInStart(Vanara.PInvoke.WinMm.HMIDIIN)">
            <summary>The <c>midiInStart</c> function starts MIDI input on the specified MIDI input device.</summary>
            <param name="hmi">Handle to the MIDI input device.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function resets the time stamp to zero; time stamp values for subsequently received messages are relative to the time that
            this function was called.
            </para>
            <para>
            All messages except system-exclusive messages are sent directly to the client when they are received. System-exclusive messages
            are placed in the buffers supplied by the midiInAddBuffer function. If there are no buffers in the queue, the system-exclusive
            data is thrown away without notification to the client and input continues. Buffers are returned to the client when they are
            full, when a complete system-exclusive message has been received, or when the midiInReset function is used. The
            <c>dwBytesRecorded</c> member of the MIDIHDR structure will contain the actual length of data received.
            </para>
            <para>Calling this function when input is already started has no effect, and the function returns zero.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInStop(Vanara.PInvoke.WinMm.HMIDIIN)">
            <summary>The <c>midiInStop</c> function stops MIDI input on the specified MIDI input device.</summary>
            <param name="hmi">Handle to the MIDI input device.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If there are any system-exclusive messages or stream buffers in the queue, the current buffer is marked as done (the
            <c>dwBytesRecorded</c> member of the MIDIHDR structure will contain the actual length of data), but any empty buffers in the
            queue remain there and are not marked as done.
            </para>
            <para>Calling this function when input is not started has no effect, and the function returns zero.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiInUnprepareHeader(Vanara.PInvoke.WinMm.HMIDIIN,Vanara.PInvoke.WinMm.MIDIHDR@,System.UInt32)">
            <summary>The <c>midiInUnprepareHeader</c> function cleans up the preparation performed by the midiInPrepareHeader function.</summary>
            <param name="hmi">Handle to the MIDI input device.</param>
            <param name="pmh">Pointer to a MIDIHDR structure identifying the buffer to be cleaned up.</param>
            <param name="cbmh">Size of the MIDIHDR structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIDIERR_STILLPLAYING</term>
            <term>The buffer pointed to by lpMidiInHdr is still in the queue.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified pointer or structure is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            This function is complementary to midiInPrepareHeader. You must use this function before freeing the buffer. After passing a
            buffer to the device driver by using the midiInAddBuffer function, you must wait until the driver is finished with the buffer
            before using <c>midiInUnprepareHeader</c>. Unpreparing a buffer that has not been prepared has no effect, and the function
            returns MMSYSERR_NOERROR.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutCacheDrumPatches(Vanara.PInvoke.WinMm.HMIDIOUT,System.UInt32,System.UInt16[],Vanara.PInvoke.WinMm.MIDI_CACHE)">
            <summary>
            The <c>midiOutCacheDrumPatches</c> function requests that an internal MIDI synthesizer device preload and cache a specified set
            of key-based percussion patches.
            </summary>
            <param name="hmo">
            Handle to the opened MIDI output device. This device should be an internal MIDI synthesizer. This parameter can also be the
            handle of a MIDI stream, cast to <c>HMIDIOUT</c>.
            </param>
            <param name="uPatch">
            Drum patch number that should be used. This parameter should be set to zero to cache the default drum patch.
            </param>
            <param name="pwkya">
            Pointer to a KEYARRAY array indicating the key numbers of the specified percussion patches to be cached or uncached.
            </param>
            <param name="fuCache">
            <para>Options for the cache operation. It can be one of the following flags.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MIDI_CACHE_ALL</term>
            <term>
            Caches all of the specified patches. If they cannot all be cached, it caches none, clears the KEYARRAY array, and returns MMSYSERR_NOMEM.
            </term>
            </item>
            <item>
            <term>MIDI_CACHE_BESTFIT</term>
            <term>
            Caches all of the specified patches. If they cannot all be cached, it caches as many patches as possible, changes the KEYARRAY
            array to reflect which patches were cached, and returns MMSYSERR_NOMEM.
            </term>
            </item>
            <item>
            <term>MIDI_CACHE_QUERY</term>
            <term>Changes the KEYARRAY array to indicate which patches are currently cached.</term>
            </item>
            <item>
            <term>MIDI_UNCACHE</term>
            <term>Uncaches the specified patches and clears the KEYARRAY array.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>The flag specified by wFlags is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The array pointed to by the lpKeyArray array is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The device does not have enough memory to cache all of the requested patches.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>The specified device does not support patch caching.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Some synthesizers are not capable of keeping all percussion patches loaded simultaneously. Caching patches ensures that the
            specified patches are available.
            </para>
            <para>
            Each element of the KEYARRAY array represents one of the 128 key-based percussion patches and has bits set for each of the 16
            MIDI channels that use the particular patch. The least-significant bit represents physical channel 0, and the most-significant
            bit represents physical channel 15. For example, if the patch on key number 60 is used by physical channels 9 and 15, element 60
            would be set to 0x8200.
            </para>
            <para>
            This function applies only to internal MIDI synthesizer devices. Not all internal synthesizers support patch caching. To see if
            a device supports patch caching, use the MIDICAPS_CACHE flag to test the <c>dwSupport</c> member of the MIDIOUTCAPS structure
            filled by the midiOutGetDevCaps function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutCachePatches(Vanara.PInvoke.WinMm.HMIDIOUT,System.UInt32,System.UInt16[],Vanara.PInvoke.WinMm.MIDI_CACHE)">
            <summary>
            The <c>midiOutCachePatches</c> function requests that an internal MIDI synthesizer device preload and cache a specified set of patches.
            </summary>
            <param name="hmo">
            Handle to the opened MIDI output device. This device must be an internal MIDI synthesizer. This parameter can also be the handle
            of a MIDI stream, cast to <c>HMIDIOUT</c>.
            </param>
            <param name="uBank">Bank of patches that should be used. This parameter should be set to zero to cache the default patch bank.</param>
            <param name="pwpa">Pointer to a PATCHARRAY array indicating the patches to be cached or uncached.</param>
            <param name="fuCache">
            <para>Options for the cache operation. It can be one of the following flags.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MIDI_CACHE_ALL</term>
            <term>
            Caches all of the specified patches. If they cannot all be cached, it caches none, clears the PATCHARRAY array, and returns MMSYSERR_NOMEM.
            </term>
            </item>
            <item>
            <term>MIDI_CACHE_BESTFIT</term>
            <term>
            Caches all of the specified patches. If they cannot all be cached, it caches as many patches as possible, changes the PATCHARRAY
            array to reflect which patches were cached, and returns MMSYSERR_NOMEM.
            </term>
            </item>
            <item>
            <term>MIDI_CACHE_QUERY</term>
            <term>Changes the PATCHARRAY array to indicate which patches are currently cached.</term>
            </item>
            <item>
            <term>MIDI_UNCACHE</term>
            <term>Uncaches the specified patches and clears the PATCHARRAY array.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>The flag specified by wFlags is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The array pointed to by lpPatchArray is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The device does not have enough memory to cache all of the requested patches.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>The specified device does not support patch caching.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Some synthesizers are not capable of keeping all patches loaded simultaneously and must load data from disk when they receive
            MIDI program change messages. Caching patches ensures that the specified patches are immediately available.
            </para>
            <para>
            Each element of the PATCHARRAY array represents one of the 128 patches and has bits set for each of the 16 MIDI channels that
            use the particular patch. The least-significant bit represents physical channel 0, and the most-significant bit represents
            physical channel 15 (0x0F). For example, if patch 0 is used by physical channels 0 and 8, element 0 would be set to 0x0101.
            </para>
            <para>
            This function applies only to internal MIDI synthesizer devices. Not all internal synthesizers support patch caching. To see if
            a device supports patch caching, use the MIDICAPS_CACHE flag to test the <c>dwSupport</c> member of the MIDIOUTCAPS structure
            filled by the midiOutGetDevCaps function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutClose(Vanara.PInvoke.WinMm.HMIDIOUT)">
            <summary>The <c>midiOutClose</c> function closes the specified MIDI output device.</summary>
            <param name="hmo">
            Handle to the MIDI output device. If the function is successful, the handle is no longer valid after the call to this function.
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIDIERR_STILLPLAYING</term>
            <term>Buffers are still in the queue.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to load mapper string description.</term>
            </item>
            </list>
            </returns>
            <remarks>
            If there are output buffers that have been sent by using the midiOutLongMsg function and have not been returned to the
            application, the close operation will fail. To mark all pending buffers as being done, use the midiOutReset function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutGetDevCaps(System.UInt32,Vanara.PInvoke.WinMm.MIDIOUTCAPS@,System.UInt32)">
            <summary>The <c>midiOutGetDevCaps</c> function queries a specified MIDI output device to determine its capabilities.</summary>
            <param name="uDeviceID">
            <para>
            Identifier of the MIDI output device. The device identifier specified by this parameter varies from zero to one less than the
            number of devices present. The MIDI_MAPPER constant is also a valid device identifier.
            </para>
            <para>This parameter can also be a properly cast device handle.</para>
            </param>
            <param name="pmoc">
            Pointer to a MIDIOUTCAPS structure. This structure is filled with information about the capabilities of the device.
            </param>
            <param name="cbmoc">
            Size, in bytes, of the MIDIOUTCAPS structure. Only cbMidiOutCaps bytes (or less) of information is copied to the location
            pointed to by lpMidiOutCaps. If cbMidiOutCaps is zero, nothing is copied, and the function returns MMSYSERR_NOERROR.
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The specified device identifier is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified pointer or structure is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>The driver is not installed.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to load mapper string description.</term>
            </item>
            </list>
            </returns>
            <remarks>To determine the number of MIDI output devices present in the system, use the midiOutGetNumDevs function.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutGetErrorText(Vanara.PInvoke.WinMm.MMRESULT,System.Text.StringBuilder,System.UInt32)">
            <summary>
            The <c>midiOutGetErrorText</c> function retrieves a textual description for an error identified by the specified error code.
            </summary>
            <param name="mmrError">Error code.</param>
            <param name="pszText">Pointer to a buffer to be filled with the textual error description.</param>
            <param name="cchText">Length, in characters, of the buffer pointed to by lpText.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADERRNUM</term>
            <term>The specified error number is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified pointer or structure is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            If the textual error description is longer than the specified buffer, the description is truncated. The returned error string is
            always null-terminated. If cchText is zero, nothing is copied, and the function returns MMSYSERR_NOERROR. All error descriptions
            are less than MAXERRORLENGTH characters long.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutGetID(Vanara.PInvoke.WinMm.HMIDIOUT,System.UInt32@)">
            <summary>
            <para>The <c>midiOutGetID</c> function retrieves the device identifier for the given MIDI output device.</para>
            <para>
            This function is supported for backward compatibility. New applications can cast a handle of the device rather than retrieving
            the device identifier.
            </para>
            </summary>
            <param name="hmo">Handle to the MIDI output device.</param>
            <param name="puDeviceID">Pointer to a variable to be filled with the device identifier.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The hmo parameter specifies an invalid handle.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutGetNumDevs">
            <summary>The <c>midiOutGetNumDevs</c> function retrieves the number of MIDI output devices present in the system.</summary>
            <returns>
            Returns the number of MIDI output devices. A return value of zero means that there are no devices (not that there is no error).
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutGetVolume(Vanara.PInvoke.WinMm.HMIDIOUT,System.UInt32@)">
            <summary>The <c>midiOutGetVolume</c> function retrieves the current volume setting of a MIDI output device.</summary>
            <param name="hmo">
            Handle to an open MIDI output device. This parameter can also contain the handle of a MIDI stream, as long as it is cast to
            <c>HMIDIOUT</c>. This parameter can also be a device identifier.
            </param>
            <param name="pdwVolume">
            <para>
            Pointer to the location to contain the current volume setting. The low-order word of this location contains the left-channel
            volume setting, and the high-order word contains the right-channel setting. A value of 0xFFFF represents full volume, and a
            value of 0x0000 is silence.
            </para>
            <para>
            If a device does not support both left and right volume control, the low-order word of the specified location contains the mono
            volume level.
            </para>
            <para>Any value set by using the midiOutSetVolume function is returned, regardless of whether the device supports that value.</para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified pointer or structure is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>The function is not supported.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If a device identifier is used, then the result of the <c>midiOutGetVolume</c> call and the information returned in lpdwVolume
            applies to all instances of the device. If a device handle is used, then the result and information returned applies only to the
            instance of the device referenced by the device handle.
            </para>
            <para>
            Not all devices support volume control. You can determine whether a device supports volume control by querying the device by
            using the midiOutGetDevCaps function and specifying the MIDICAPS_VOLUME flag.
            </para>
            <para>
            You can also determine whether the device supports volume control on both the left and right channels by querying the device by
            using the midiOutGetDevCaps function and specifying the MIDICAPS_LRVOLUME flag.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutLongMsg(Vanara.PInvoke.WinMm.HMIDIOUT,Vanara.PInvoke.WinMm.MIDIHDR@,System.UInt32)">
            <summary>The <c>midiOutLongMsg</c> function sends a system-exclusive MIDI message to the specified MIDI output device.</summary>
            <param name="hmo">Handle to the MIDI output device. This parameter can also be the handle of a MIDI stream cast to <c>HMIDIOUT</c>.</param>
            <param name="pmh">Pointer to a MIDIHDR structure that identifies the MIDI buffer.</param>
            <param name="cbmh">Size, in bytes, of the MIDIHDR structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIDIERR_NOTREADY</term>
            <term>The hardware is busy with other data.</term>
            </item>
            <item>
            <term>MIDIERR_UNPREPARED</term>
            <term>The buffer pointed to by lpMidiOutHdr has not been prepared.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified pointer or structure is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Before the buffer is passed to <c>midiOutLongMsg</c>, it must be prepared by using the midiOutPrepareHeader function. The MIDI
            output device driver determines whether the data is sent synchronously or asynchronously.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutMessage(Vanara.PInvoke.WinMm.HMIDIOUT,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            The <c>midiOutMessage</c> function sends a message to the MIDI device drivers. This function is used only for driver-specific
            messages that are not supported by the MIDI API.
            </summary>
            <param name="hmo">
            Identifier of the MIDI device that receives the message. You must cast the device ID to the <c>HMIDIOUT</c> handle type. If you
            supply a handle instead of a device ID, the function fails and returns the MMSYSERR_NOSUPPORT error code.
            </param>
            <param name="uMsg">Message to send.</param>
            <param name="dw1">Message parameter.</param>
            <param name="dw2">Message parameter.</param>
            <returns>Returns the value returned by the audio device driver.</returns>
            <remarks>
            <para>The
            <code>DRV_QUERYDEVICEINTERFACE</code>
            message queries for the device-interface name of a <c>waveIn</c>, <c>waveOut</c>, <c>midiIn</c>, <c>midiOut</c>, or <c>mixer</c> device.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACE</code>
            , dwParam1 is a pointer to a caller-allocated buffer into which the function writes a null-terminated Unicode string containing
            the device-interface name. If the device has no device interface, the string length is zero.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACE</code>
            , dwParam2 specifies the buffer size in bytes. This is an input parameter to the function. The caller should specify a size that
            is greater than or equal to the buffer size retrieved by the DRV_QUERYDEVICEINTERFACESIZE message.
            </para>
            <para>
            The DRV_QUERYDEVICEINTERFACE message is supported in Windows Me, and Windows 2000 and later. This message is valid only for the
            waveInMessage, waveOutMessage, midiInMessage, <c>midiOutMessage</c>, and mixerMessage functions. The system intercepts this
            message and returns the appropriate value without sending the message to the device driver. For general information about
            system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>The following two message constants are used together for the purpose of obtaining device interface names:</para>
            <list type="bullet">
            <item>
            <term>DRV_QUERYDEVICEINTERFACESIZE</term>
            </item>
            <item>
            <term>DRV_QUERYDEVICEINTERFACE</term>
            </item>
            </list>
            <para>
            The first message obtains the size in bytes of the buffer needed to hold the string containing the device interface name. The
            second message retrieves the name string in a buffer of the required size.
            </para>
            <para>For more information, see Obtaining a Device Interface Name.</para>
            <para>The
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            message queries for the size of the buffer required to hold the device-interface name.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            , dwParam1 is a pointer to buffer size. This parameter points to a ULONG variable into which the function writes the required
            buffer size in bytes. The size includes storage space for the name string's terminating null. The size is zero if the device ID
            identifies a device that has no device interface.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            This message is valid only for the waveInMessage, waveOutMessage, midiInMessage, <c>midiOutMessage</c>, and mixerMessage
            functions. The system intercepts this message and returns the appropriate value without sending the message to the device
            driver. For general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            The buffer size retrieved by this message is expressed as a byte count. It specifies the size of the buffer needed to hold the
            null-terminated Unicode string that contains the device-interface name. The caller allocates a buffer of the specified size and
            uses the DRV_QUERYDEVICEINTERFACE message to retrieve the device-interface name string.
            </para>
            <para>For more information, see Obtaining a Device Interface Name.</para>
            <para>The
            <code>DRV_QUERYDEVNODE</code>
            message queries for the devnode number assigned to the device by the Plug and Play manager.
            </para>
            <para>For
            <code>DRV_QUERYDEVNODE</code>
            , dwParam1 is a pointer to a caller-allocated DWORD variable into which the function writes the devnode number. If no devnode is
            assigned to the device, the function sets this variable to zero.
            </para>
            <para>For
            <code>DRV_QUERYDEVNODE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            In Windows 2000 and later, the message always returns MMSYSERR_NOTSUPPORTED. This message is valid only for the waveInMessage,
            waveOutMessage, midiInMessage, <c>midiOutMessage</c>, and mixerMessage functions. The system intercepts this message and returns
            the appropriate value without sending the message to the device driver. For general information about system-intercepted
            <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>The
            <code>DRV_QUERYMAPPABLE</code>
            message queries for whether the specified device can be used by a mapper.
            </para>
            <para>For
            <code>DRV_QUERYMAPPABLE</code>
            , dwParam1 is unused. Set this parameter to zero.
            </para>
            <para>For
            <code>DRV_QUERYMAPPABLE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            This message is valid only for the waveInMessage, waveOutMessage, midiInMessage, <c>midiOutMessage</c>, mixerMessage and
            auxOutMessage functions. The system intercepts this message and returns the appropriate value without sending the message to the
            device driver. For general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            When an application program opens a mapper instead of a specific audio device, the system inserts a mapper between the
            application and the available devices. The mapper selects an appropriate device by mapping the application's requirements to one
            of the available devices. For more information about mappers, see the Microsoft Windows SDK documentation.
            </para>
            <para>The
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            message retrieves the device ID of the preferred voice-communications device.
            </para>
            <para>For
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            , dwParam1 is a pointer to device ID. This parameter points to a DWORD variable into which the function writes the device ID of
            the current preferred voice-communications device. The function writes the value (-1) if no device is available that qualifies
            as a preferred voice-communications device.
            </para>
            <para>For
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            , dwParam2 is a pointer to status flags. This parameter points to a DWORD variable into which the function writes the
            device-status flags. Only one flag bit is currently defined: DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY.
            </para>
            <para>
            This message is valid only for the waveInMessage and waveOutMessage functions. When a caller calls these two functions with the
            DRVM_MAPPER_CONSOLEVOICECOM_GET message, the caller must specify the device ID as WAVE_MAPPER, and then cast this value to the
            appropriate handle type. For the <c>waveInMessage</c>, <c>waveOutMessage</c>, midiInMessage, <c>midiOutMessage</c>, or
            mixerMessage functions, the caller must cast the device ID to a handle of type HWAVEIN, HWAVEOUT, HMIDIIN, HMIDIOUT, or HMIXER,
            respectively. Note that if the caller supplies a valid handle instead of a device ID for this parameter, the function fails and
            returns error code MMSYSERR_NOSUPPORT.
            </para>
            <para>
            The system intercepts this message and returns the appropriate value without sending the message to the device driver. For
            general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            This message provides a way to determine which device is preferred specifically for voice communications, in contrast to the
            DRVM_MAPPER_PREFERRED_GET message, which determines which device is preferred for all other audio functions.
            </para>
            <para>
            For example, the preferred <c>waveOut</c> device for voice communications might be the earpiece in a headset, but the preferred
            <c>waveOut</c> device for all other audio functions might be a set of stereo speakers.
            </para>
            <para>
            When the DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY flag bit is set in the DWORD location pointed to by dwParam2, the
            <c>waveIn</c> and <c>waveOut</c> APIs use only the current preferred voice-communications device and do not search for other
            available devices if the preferred device is unavailable. The flag that is output by either the <c>waveInMessage</c> or
            <c>waveOutMessage</c> call applies to the preferred voice-communications device for both the <c>waveIn</c> and <c>waveOut</c>
            APIs, regardless of whether the call is made to <c>waveInMessage</c> or <c>waveOutMessage</c>. For more information, see
            Preferred Voice-Communications Device ID.
            </para>
            <para>The
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            message retrieves the device ID of the preferred audio device.
            </para>
            <para>For
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            , dwParam1 is a pointer to device ID. This parameter points to a DWORD variable into which the function writes the device ID of
            the current preferred device. The function writes the value (-1) if no device is available that qualifies as a preferred device.
            </para>
            <para>For
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            , dwParam2 is a pointer to status flags. This parameter points to a DWORD variable into which the function writes the
            device-status flags. Only one flag bit is currently defined (for <c>waveInMessage</c> and <c>waveOutMessage</c> calls only): DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY.
            </para>
            <para>
            This message is valid only for the waveInMessage, waveOutMessage and <c>midiOutMessage</c> functions. When the caller calls
            these functions with the DRVM_MAPPER_PREFERRED_GET message, the caller must first specify the device ID as WAVE_MAPPER (for
            <c>waveInMessage</c> or <c>waveOutMessage</c>) or MIDI_MAPPER (for <c>midiOutMessage</c>), and then cast this value to the
            appropriate handle type. For the <c>waveInMessage</c>, <c>waveOutMessage</c>, or <c>midiOutMessage</c> functions, the caller
            must cast the device ID to a handle type HWAVEIN, HWAVEOUT or HMIDIOUT, respectively. Note that if the caller supplies a valid
            handle instead of a device ID for this parameter, the function fails and returns error code MMSYSERR_NOSUPPORT.
            </para>
            <para>
            The system intercepts this message and returns the appropriate value without sending the message to the device driver. For
            general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            This message provides a way to determine which device is preferred for audio functions in general, in contrast to the
            DRVM_MAPPER_CONSOLEVOICECOM_GET message, which determines which device is preferred specifically for voice communications.
            </para>
            <para>
            When the DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY flag bit is set in the DWORD location pointed to by dwParam2, the
            <c>waveIn</c> and <c>waveOut</c> APIs use only the current preferred device and do not search for other available devices if the
            preferred device is unavailable. Note that the <c>midiOutMessage</c> function does not output this flag--the <c>midiOut</c> API
            always uses only the preferred device. The flag that is output by either the <c>waveInMessage</c> or <c>waveOutMessage</c> call
            applies to the preferred device for both the <c>waveIn</c> and <c>waveOut</c> APIs, regardless of whether the call is made to
            <c>waveInMessage</c> or <c>waveOutMessage</c>.
            </para>
            <para>
            The xxxMessage functions accept this value in place of a valid device handle in order to allow an application to determine the
            default device ID without first having to open a device. For more information, see Accessing the Preferred Device ID.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutOpen(Vanara.PInvoke.WinMm.HMIDIOUT@,System.UInt32,System.IntPtr,System.IntPtr,Vanara.PInvoke.WinMm.CALLBACK_FLAGS)">
            <summary>The <c>midiOutOpen</c> function opens a MIDI output device for playback.</summary>
            <param name="phmo">
            Pointer to an <c>HMIDIOUT</c> handle. This location is filled with a handle identifying the opened MIDI output device. The
            handle is used to identify the device in calls to other MIDI output functions.
            </param>
            <param name="uDeviceID">Identifier of the MIDI output device that is to be opened.</param>
            <param name="dwCallback">
            Pointer to a callback function, an event handle, a thread identifier, or a handle of a window or thread called during MIDI
            playback to process messages related to the progress of the playback. If no callback is desired, specify <c>NULL</c> for this
            parameter. For more information on the callback function, see MidiOutProc.
            </param>
            <param name="dwInstance">User instance data passed to the callback. This parameter is not used with window callbacks or threads.</param>
            <param name="fdwOpen">
            <para>Callback flag for opening the device. It can be the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>CALLBACK_EVENT</term>
            <term>The dwCallback parameter is an event handle. This callback mechanism is for output only.</term>
            </item>
            <item>
            <term>CALLBACK_FUNCTION</term>
            <term>The dwCallback parameter is a callback function address.</term>
            </item>
            <item>
            <term>CALLBACK_NULL</term>
            <term>There is no callback mechanism. This value is the default setting.</term>
            </item>
            <item>
            <term>CALLBACK_THREAD</term>
            <term>The dwCallback parameter is a thread identifier.</term>
            </item>
            <item>
            <term>CALLBACK_WINDOW</term>
            <term>The dwCallback parameter is a window handle.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIDIERR_NODEVICE</term>
            <term>No MIDI port was found. This error occurs only when the mapper is opened.</term>
            </item>
            <item>
            <term>MMSYSERR_ALLOCATED</term>
            <term>The specified resource is already allocated.</term>
            </item>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The specified device identifier is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified pointer or structure is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            To determine the number of MIDI output devices present in the system, use the midiOutGetNumDevs function. The device identifier
            specified by wDeviceID varies from zero to one less than the number of devices present. MIDI_MAPPER can also be used as the
            device identifier.
            </para>
            <para>
            If a window or thread is chosen to receive callback information, the following messages are sent to the window procedure or
            thread to indicate the progress of MIDI output: MM_MOM_OPEN, MM_MOM_CLOSE, and MM_MOM_DONE.
            </para>
            <para>
            If a function is chosen to receive callback information, the following messages are sent to the function to indicate the
            progress of MIDI output: MOM_OPEN, MOM_CLOSE, and MOM_DONE.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutPrepareHeader(Vanara.PInvoke.WinMm.HMIDIOUT,Vanara.PInvoke.WinMm.MIDIHDR@,System.UInt32)">
            <summary>The <c>midiOutPrepareHeader</c> function prepares a MIDI system-exclusive or stream buffer for output.</summary>
            <param name="hmo">
            Handle to the MIDI output device. To get the device handle, call midiOutOpen. This parameter can also be the handle of a MIDI
            stream cast to a <c>HMIDIOUT</c> type.
            </param>
            <param name="pmh">
            <para>Pointer to a MIDIHDR structure that identifies the buffer to be prepared.</para>
            <para>
            Before calling the function, set the <c>lpData</c>, <c>dwBufferLength</c>, and <c>dwFlags</c> members of the MIDIHDR structure.
            The <c>dwFlags</c> member must be set to zero.
            </para>
            </param>
            <param name="cbmh">Size, in bytes, of the MIDIHDR structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified address is invalid or the given stream buffer is greater than 64K.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Before you pass a MIDI data block to a device driver, you must prepare the buffer by passing it to the
            <c>midiOutPrepareHeader</c> function. After the header has been prepared, do not modify the buffer. After the driver is done
            using the buffer, call the midiOutUnprepareHeader function.
            </para>
            <para>
            The application can re-use the same buffer, or allocate multiple buffers and call <c>midiOutPrepareHeader</c> for each buffer.
            If you re-use the same buffer, it is not necessary to prepare the buffer each time. You can call <c>midiOutPrepareHeader</c>
            once at the beginning and then call midiOutUnprepareHeader once at the end.
            </para>
            <para>A stream buffer cannot be larger than 64K.</para>
            <para>Preparing a header that has already been prepared has no effect, and the function returns MMSYSERR_NOERROR.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutReset(Vanara.PInvoke.WinMm.HMIDIOUT)">
            <summary>The <c>midiOutReset</c> function turns off all notes on all MIDI channels for the specified MIDI output device.</summary>
            <param name="hmo">Handle to the MIDI output device. This parameter can also be the handle of a MIDI stream cast to <c>HMIDIOUT</c>.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Any pending system-exclusive or stream output buffers are returned to the callback function and the MHDR_DONE flag is set in the
            <c>dwFlags</c> member of the MIDIHDR structure.
            </para>
            <para>
            Terminating a system-exclusive message without sending an EOX (end-of-exclusive) byte might cause problems for the receiving
            device. The <c>midiOutReset</c> function does not send an EOX byte when it terminates a system-exclusive message - applications
            are responsible for doing this.
            </para>
            <para>
            To turn off all notes, a note-off message for each note in each channel is sent. In addition, the sustain controller is turned
            off for each channel.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutSetVolume(Vanara.PInvoke.WinMm.HMIDIOUT,System.UInt32)">
            <summary>The <c>midiOutSetVolume</c> function sets the volume of a MIDI output device.</summary>
            <param name="hmo">
            Handle to an open MIDI output device. This parameter can also contain the handle of a MIDI stream, as long as it is cast to
            <c>HMIDIOUT</c>. This parameter can also be a device identifier.
            </param>
            <param name="dwVolume">
            <para>
            New volume setting. The low-order word contains the left-channel volume setting, and the high-order word contains the
            right-channel setting. A value of 0xFFFF represents full volume, and a value of 0x0000 is silence.
            </para>
            <para>
            If a device does not support both left and right volume control, the low-order word of dwVolume specifies the mono volume level,
            and the high-order word is ignored.
            </para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>The function is not supported.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If a device identifier is used, then the result of the <c>midiOutSetVolume</c> call applies to all instances of the device. If a
            device handle is used, then the result applies only to the instance of the device referenced by the device handle.
            </para>
            <para>
            Not all devices support volume changes. You can determine whether a device supports it by querying the device using the
            midiOutGetDevCaps function and the MIDICAPS_VOLUME flag.
            </para>
            <para>
            You can also determine whether the device supports volume control on both the left and right channels by querying the device
            using the midiOutGetDevCaps function and the MIDICAPS_LRVOLUME flag.
            </para>
            <para>
            Devices that do not support a full 16 bits of volume-level control use the high-order bits of the requested volume setting. For
            example, a device that supports 4 bits of volume control produces the same volume setting for the following volume-level values:
            0x4000, 0x43be, and 0x4fff. The midiOutGetVolume function returns the full 16-bit value, as set by <c>midiOutSetVolume</c>,
            irrespective of the device's capabilities.
            </para>
            <para>
            Volume settings are interpreted logarithmically. This means that the perceived increase in volume is the same when increasing
            the volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutShortMsg(Vanara.PInvoke.WinMm.HMIDIOUT,System.UInt32)">
            <summary>The <c>midiOutShortMsg</c> function sends a short MIDI message to the specified MIDI output device.</summary>
            <param name="hmo">Handle to the MIDI output device. This parameter can also be the handle of a MIDI stream cast to <c>HMIDIOUT</c>.</param>
            <param name="dwMsg">
            <para>
            MIDI message. The message is packed into a <c>DWORD</c> value with the first byte of the message in the low-order byte. The
            message is packed into this parameter as follows.
            </para>
            <list type="table">
            <listheader>
            <term>Word</term>
            <term>Byte</term>
            <term>Usage</term>
            </listheader>
            <item>
            <term>High</term>
            <term>High-order</term>
            <term>Not used.</term>
            </item>
            <item>
            <term/>
            <term>Low-order</term>
            <term>The second byte of MIDI data (when needed).</term>
            </item>
            <item>
            <term>Low</term>
            <term>High-order</term>
            <term>The first byte of MIDI data (when needed).</term>
            </item>
            <item>
            <term/>
            <term>Low-order</term>
            <term>The MIDI status.</term>
            </item>
            </list>
            <para>
            The two MIDI data bytes are optional, depending on the MIDI status byte. When a series of messages have the same status byte,
            the status byte can be omitted from messages after the first one in the series, creating a running status. Pack a message for
            running status as follows:
            </para>
            <list type="table">
            <listheader>
            <term>Word</term>
            <term>Byte</term>
            <term>Usage</term>
            </listheader>
            <item>
            <term>High</term>
            <term>High-order</term>
            <term>Not used.</term>
            </item>
            <item>
            <term/>
            <term>Low-order</term>
            <term>Not used.</term>
            </item>
            <item>
            <term>Low</term>
            <term>High-order</term>
            <term>The second byte of MIDI data (when needed).</term>
            </item>
            <item>
            <term/>
            <term>Low-order</term>
            <term>The first byte of MIDI data.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following:</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIDIERR_BADOPENMODE</term>
            <term>The application sent a message without a status byte to a stream handle.</term>
            </item>
            <item>
            <term>MIDIERR_NOTREADY</term>
            <term>The hardware is busy with other data.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>This function is used to send any MIDI message except for system-exclusive or stream messages.</para>
            <para>
            This function might not return until the message has been sent to the output device. You can send short messages while streams
            are playing on the same device (although you cannot use a running status in this case).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiOutUnprepareHeader(Vanara.PInvoke.WinMm.HMIDIOUT,Vanara.PInvoke.WinMm.MIDIHDR@,System.UInt32)">
            <summary>The <c>midiOutUnprepareHeader</c> function cleans up the preparation performed by the midiOutPrepareHeader function.</summary>
            <param name="hmo">Handle to the MIDI output device. This parameter can also be the handle of a MIDI stream cast to <c>HMIDIOUT</c>.</param>
            <param name="pmh">Pointer to a MIDIHDR structure identifying the buffer to be cleaned up.</param>
            <param name="cbmh">Size, in bytes, of the MIDIHDR structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIDIERR_STILLPLAYING</term>
            <term>The buffer pointed to by lpMidiOutHdr is still in the queue.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The specified pointer or structure is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function is complementary to the midiOutPrepareHeader function. You must call <c>midiOutUnprepareHeader</c> before freeing
            the buffer. After passing a buffer to the device driver with the midiOutLongMsg function, you must wait until the device driver
            is finished with the buffer before calling <c>midiOutUnprepareHeader</c>.
            </para>
            <para>Unpreparing a buffer that has not been prepared has no effect, and the function returns MMSYSERR_NOERROR.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiStreamClose(Vanara.PInvoke.WinMm.HMIDISTRM)">
            <summary>The <c>midiStreamClose</c> function closes an open MIDI stream.</summary>
            <param name="hms">Handle to a MIDI stream, as retrieved by using the midiStreamOpen function.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiStreamOpen(Vanara.PInvoke.WinMm.HMIDISTRM@,System.UInt32@,System.UInt32,System.IntPtr,System.IntPtr,Vanara.PInvoke.WinMm.CALLBACK_FLAGS)">
            <summary>
            The <c>midiStreamOpen</c> function opens a MIDI stream for output. By default, the device is opened in paused mode. The stream
            handle retrieved by this function must be used in all subsequent references to the stream.
            </summary>
            <param name="phms">Pointer to a variable to contain the stream handle when the function returns.</param>
            <param name="puDeviceID">
            Pointer to a device identifier. The device is opened on behalf of the stream and closed again when the stream is closed.
            </param>
            <param name="cMidi">Reserved; must be 1.</param>
            <param name="dwCallback">
            Pointer to a callback function, an event handle, a thread identifier, or a handle of a window or thread called during MIDI
            playback to process messages related to the progress of the playback. If no callback mechanism is desired, specify <c>NULL</c>
            for this parameter.
            </param>
            <param name="dwInstance">Application-specific instance data that is returned to the application with every callback function.</param>
            <param name="fdwOpen">
            <para>Callback flag for opening the device. One of the following callback flags must be specified.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>CALLBACK_EVENT</term>
            <term>The dwCallback parameter is an event handle. This callback mechanism is for output only.</term>
            </item>
            <item>
            <term>CALLBACK_FUNCTION</term>
            <term>The dwCallback parameter is a callback procedure address. For the callback signature, see MidiOutProc.</term>
            </item>
            <item>
            <term>CALLBACK_NULL</term>
            <term>There is no callback mechanism. This is the default setting.</term>
            </item>
            <item>
            <term>CALLBACK_THREAD</term>
            <term>The dwCallback parameter is a thread identifier.</term>
            </item>
            <item>
            <term>CALLBACK_WINDOW</term>
            <term>The dwCallback parameter is a window handle.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The specified device identifier is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The given handle or flags parameter is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiStreamOut(Vanara.PInvoke.WinMm.HMIDISTRM,Vanara.PInvoke.WinMm.MIDIHDR@,System.UInt32)">
            <summary>The <c>midiStreamOut</c> function plays or queues a stream (buffer) of MIDI data to a MIDI output device.</summary>
            <param name="hms">
            Handle to a MIDI stream. This handle must have been returned by a call to the midiStreamOpen function. This handle identifies
            the output device.
            </param>
            <param name="pmh">Pointer to a MIDIHDR structure that identifies the MIDI buffer.</param>
            <param name="cbmh">Size, in bytes, of the MIDIHDR structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>MIDIERR_STILLPLAYING</term>
            <term>The output buffer pointed to by lpMidiHdr is still playing or is queued from a previous call to midiStreamOut.</term>
            </item>
            <item>
            <term>MIDIERR_UNPREPARED</term>
            <term>The header pointed to by lpMidiHdr has not been prepared.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The pointer specified by lpMidiHdr is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Before the buffer is passed to midiStreamOpen, it must be prepared by using the midiOutPrepareHeader function.</para>
            <para>
            Because the midiStreamOpen function opens the output device in paused mode, you must call the midiStreamRestart function before
            you can use <c>midiStreamOut</c> to start the playback.
            </para>
            <para>For the current implementation of this function, the buffer must be smaller than 64K.</para>
            <para>
            The buffer pointed to by the MIDIHDR structure contains one or more MIDI events, each of which is defined by a MIDIEVENT structure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiStreamPause(Vanara.PInvoke.WinMm.HMIDISTRM)">
            <summary>The <c>midiStreamPause</c> function pauses playback of a specified MIDI stream.</summary>
            <param name="hms">
            Handle to a MIDI stream. This handle must have been returned by a call to the MIDIEVENT function. This handle identifies the
            output device.
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The current playback position is saved when playback is paused. To resume playback from the current position, use the
            midiStreamRestart function.
            </para>
            <para>Calling this function when the output is already paused has no effect, and the function returns MMSYSERR_NOERROR.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiStreamPosition(Vanara.PInvoke.WinMm.HMIDISTRM,Vanara.PInvoke.WinMm.MMTIME@,System.UInt32)">
            <summary>The <c>midiStreamPosition</c> function retrieves the current position in a MIDI stream.</summary>
            <param name="hms">
            Handle to a MIDI stream. This handle must have been returned by a call to the midiStreamOpen function. This handle identifies
            the output device.
            </param>
            <param name="lpmmt">Pointer to an MMTIME structure.</param>
            <param name="cbmmt">Size, in bytes, of the MMTIME structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>Specified pointer or structure is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Before calling <c>midiStreamPosition</c>, set the <c>wType</c> member of the MMTIME structure to indicate the time format you
            desire. After calling <c>midiStreamPosition</c>, check the <c>wType</c> member to determine if the desired time format is
            supported. If the desired format is not supported, <c>wType</c> will specify an alternative format.
            </para>
            <para>The position is set to zero when the device is opened or reset.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiStreamProperty(Vanara.PInvoke.WinMm.HMIDISTRM,System.IntPtr,Vanara.PInvoke.WinMm.MIDIPROP)">
            <summary>
            The <c>midiStreamProperty</c> function sets or retrieves properties of a MIDI data stream associated with a MIDI output device.
            </summary>
            <param name="hms">Handle to the MIDI device that the property is associated with.</param>
            <param name="lppropdata">Pointer to the property data.</param>
            <param name="dwProperty">
            <para>
            Flags that specify the action to perform and identify the appropriate property of the MIDI data stream. The
            <c>midiStreamProperty</c> function requires setting two flags in each use. One flag (either MIDIPROP_GET or MIDIPROP_SET)
            specifies an action, and the other identifies a specific property to examine or edit.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MIDIPROP_GET</term>
            <term>Retrieves the current setting of the given property.</term>
            </item>
            <item>
            <term>MIDIPROP_SET</term>
            <term>Sets the given property.</term>
            </item>
            <item>
            <term>MIDIPROP_TEMPO</term>
            <term>
            Retrieves the tempo property. The lppropdata parameter points to a MIDIPROPTEMPO structure. The current tempo value can be
            retrieved at any time. Output devices set the tempo by inserting MEVT_TEMPO events into the MIDI data.
            </term>
            </item>
            <item>
            <term>MIDIPROP_TIMEDIV</term>
            <term>
            Specifies the time division property. You can get or set this property. The lppropdata parameter points to a MIDIPROPTIMEDIV
            structure. This property can be set only when the device is stopped.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is not a stream handle.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The given handle or flags parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            These properties are the default properties defined by the system. Driver writers can implement and document their own properties.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiStreamRestart(Vanara.PInvoke.WinMm.HMIDISTRM)">
            <summary>The <c>midiStreamRestart</c> function restarts a paused MIDI stream.</summary>
            <param name="hms">
            Handle to a MIDI stream. This handle must have been returned by a call to the midiStreamOpen function. This handle identifies
            the output device.
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>Calling this function when the output is not paused has no effect, and the function returns MMSYSERR_NOERROR.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.midiStreamStop(Vanara.PInvoke.WinMm.HMIDISTRM)">
            <summary>The <c>midiStreamStop</c> function turns off all notes on all MIDI channels for the specified MIDI output device.</summary>
            <param name="hms">
            Handle to a MIDI stream. This handle must have been returned by a call to the midiStreamOpen function. This handle identifies
            the output device.
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            When you call this function, any pending system-exclusive or stream output buffers are returned to the callback mechanism and
            the MHDR_DONE bit is set in the <c>dwFlags</c> member of the MIDIHDR structure.
            </para>
            <para>
            While the midiOutReset function turns off all notes, <c>midiStreamStop</c> turns off only those notes that have been turned on
            by a MIDI note-on message.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.HMIDI">
            <summary>Provides a handle to a MIDI input device or a MIDI thru device.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDI.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.HMIDI"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMIDI.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.WinMm.HMIDI"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMIDI.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDI.op_Explicit(Vanara.PInvoke.WinMm.HMIDI)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.WinMm.HMIDI"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDI.op_Implicit(System.IntPtr)~Vanara.PInvoke.WinMm.HMIDI">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.WinMm.HMIDIOUT"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDI.op_Inequality(Vanara.PInvoke.WinMm.HMIDI,Vanara.PInvoke.WinMm.HMIDI)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDI.op_Equality(Vanara.PInvoke.WinMm.HMIDI,Vanara.PInvoke.WinMm.HMIDI)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDI.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDI.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDI.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.HMIDIIN">
            <summary>Provides a handle to a MIDI input device.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIIN.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.HMIDIIN"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMIDIIN.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.WinMm.HMIDIIN"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMIDIIN.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIIN.op_Explicit(Vanara.PInvoke.WinMm.HMIDIIN)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.WinMm.HMIDIIN"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIIN.op_Implicit(System.IntPtr)~Vanara.PInvoke.WinMm.HMIDIIN">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.WinMm.HMIDIIN"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIIN.op_Inequality(Vanara.PInvoke.WinMm.HMIDIIN,Vanara.PInvoke.WinMm.HMIDIIN)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIIN.op_Equality(Vanara.PInvoke.WinMm.HMIDIIN,Vanara.PInvoke.WinMm.HMIDIIN)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIIN.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIIN.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIIN.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.HMIDIOUT">
            <summary>Provides a handle to a MIDI output or thru device.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIOUT.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.HMIDIOUT"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMIDIOUT.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.WinMm.HMIDIOUT"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMIDIOUT.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIOUT.op_Explicit(Vanara.PInvoke.WinMm.HMIDIOUT)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.WinMm.HMIDIOUT"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIOUT.op_Implicit(System.IntPtr)~Vanara.PInvoke.WinMm.HMIDIOUT">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.WinMm.HMIDIOUT"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIOUT.op_Inequality(Vanara.PInvoke.WinMm.HMIDIOUT,Vanara.PInvoke.WinMm.HMIDIOUT)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIOUT.op_Equality(Vanara.PInvoke.WinMm.HMIDIOUT,Vanara.PInvoke.WinMm.HMIDIOUT)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIOUT.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIOUT.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDIOUT.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.HMIDISTRM">
            <summary>Provides a handle to a MIDI stream.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDISTRM.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.HMIDISTRM"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMIDISTRM.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.WinMm.HMIDISTRM"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMIDISTRM.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDISTRM.op_Explicit(Vanara.PInvoke.WinMm.HMIDISTRM)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.WinMm.HMIDISTRM"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDISTRM.op_Implicit(System.IntPtr)~Vanara.PInvoke.WinMm.HMIDISTRM">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.WinMm.HMIDISTRM"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDISTRM.op_Inequality(Vanara.PInvoke.WinMm.HMIDISTRM,Vanara.PInvoke.WinMm.HMIDISTRM)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDISTRM.op_Equality(Vanara.PInvoke.WinMm.HMIDISTRM,Vanara.PInvoke.WinMm.HMIDISTRM)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDISTRM.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDISTRM.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIDISTRM.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIDIEVENT">
            <summary>The MIDIEVENT structure describes a MIDI event in a stream buffer.</summary>
            <remarks>
            <para>
            The high byte of <c>dwEvent</c> contains flags and an event code. Either the MEVT_F_LONG or MEVT_F_SHORT flag must be specified.
            The MEVT_F_CALLBACK flag is optional. The following table describes these flags.
            </para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MEVT_F_CALLBACK</term>
            <term>The system generates a callback when the event is about to be executed.</term>
            </item>
            <item>
            <term>MEVT_F_LONG</term>
            <term>The event is a long event. The low 24 bits of dwEvent contain the length of the event parameters included in dwParms.</term>
            </item>
            <item>
            <term>MEVT_F_SHORT</term>
            <term>The event is a short event. The event parameters are contained in the low 24 bits of dwEvent.</term>
            </item>
            </list>
            <para>The remainder of the high byte contains one of the following event codes:</para>
            <list type="table">
            <listheader>
            <term>Event Code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MEVT_COMMENT</term>
            <term>
            Long event. The event data will be ignored. This event is intended to store commentary information about the stream that might
            be useful to authoring programs or sequencers if the stream data were to be stored in a file in stream format. In a buffer of
            this data, the zero byte identifies the comment class and subsequent bytes contain the comment data.
            </term>
            </item>
            <item>
            <term>MEVT_LONGMSG</term>
            <term>
            Long event. The event data is transmitted verbatim. The event data is assumed to be system-exclusive data; that is, running
            status will be cleared when the event is executed and running status from any previous events will not be applied to any channel
            events in the event data. Using this event to send a group of channel messages at the same time is not recommended; a set of
            MEVT_SHORTMSG events with zero delta times should be used instead.
            </term>
            </item>
            <item>
            <term>MEVT_NOP</term>
            <term>
            Short event. This event is a placeholder; it does nothing. The low 24 bits are ignored. This event will still generate a
            callback if MEVT_F_CALLBACK is set in dwEvent.
            </term>
            </item>
            <item>
            <term>MEVT_SHORTMSG</term>
            <term>
            Short event. The data in the low 24 bits of dwEvent is a MIDI short message. (For a description of how a short message is packed
            into a DWORD value, see the midiOutShortMsg function.)
            </term>
            </item>
            <item>
            <term>MEVT_TEMPO</term>
            <term>
            Short event. The data in the low 24 bits of dwEvent contain the new tempo for following events. The tempo is specified in the
            same format as it is for the tempo change meta-event in a MIDI file — that is, in microseconds per quarter note. (This event
            will have no affect if the time format specified for the stream is SMPTE time.)
            </term>
            </item>
            <item>
            <term>MEVT_VERSION</term>
            <term>Long event. The event data must contain a MIDISTRMBUFFVER structure.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIEVENT.dwDeltaTime">
            <summary>
            Time, in MIDI ticks, between the previous event and the current event. The length of a tick is defined by the time format
            and possibly the tempo associated with the stream. (The definition is identical to the specification for a tick in a
            standard MIDI file.)
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIEVENT.dwStreamID">
            <summary>Reserved; must be zero.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIEVENT.dwEvent">
            <summary>
            Event code and event parameters or length. To parse this information, use the MEVT_EVENTTYPE and MEVT_EVENTPARM macros. See Remarks.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIEVENT.dwParms">
            <summary>
            <para>
            If <c>dwEvent</c> specifies MEVT_F_LONG and the length of the buffer, this member contains parameters for the event. This
            parameter data must be padded with zeros so that an integral number of <c>DWORD</c> values are stored. For example, if the
            event data is five bytes long, three pad bytes must follow the data for a total of eight bytes. In this case, the low 24
            bits of <c>dwEvent</c> would contain the value 5.
            </para>
            <para>If <c>dwEvent</c> specifies MEVT_F_SHORT, do not use this member in the stream buffer.</para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.MIDIEVENT.EventType">
            <summary>Retrieves the event type from the value specified in the dwEvent member of a MIDIEVENT structure.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.MIDIEVENT.EventParm">
            <summary>Retrieves the event parameters or length from the value specified in the dwEvent member of a MIDIEVENT structure.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIDIHDR">
            <summary>The <c>MIDIHDR</c> structure defines the header used to identify a MIDI system-exclusive or stream buffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIHDR.lpData">
            <summary>Pointer to MIDI data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIHDR.dwBufferLength">
            <summary>Size of the buffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIHDR.dwBytesRecorded">
            <summary>
            Actual amount of data in the buffer. This value should be less than or equal to the value given in the <c>dwBufferLength</c> member.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIHDR.dwUser">
            <summary>Custom user data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIHDR.dwFlags">
            <summary>
            <para>Flags giving information about the buffer.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MHDR_DONE</term>
            <term>Set by the device driver to indicate that it is finished with the buffer and is returning it to the application.</term>
            </item>
            <item>
            <term>MHDR_INQUEUE</term>
            <term>Set by Windows to indicate that the buffer is queued for playback.</term>
            </item>
            <item>
            <term>MHDR_ISSTRM</term>
            <term>Set to indicate that the buffer is a stream buffer.</term>
            </item>
            <item>
            <term>MHDR_PREPARED</term>
            <term>
            Set by Windows to indicate that the buffer has been prepared by using the midiInPrepareHeader or midiOutPrepareHeader function.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIHDR.lpNext">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIHDR.reserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIHDR.dwOffset">
            <summary>
            Offset into the buffer when a callback is performed. (This callback is generated because the MEVT_F_CALLBACK flag is set in
            the <c>dwEvent</c> member of the MIDIEVENT structure.) This offset enables an application to determine which event caused
            the callback.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIHDR.dwReserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIHDR.NativeSize">
            <summary>Gets the native size of this structure.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIDIINCAPS">
            <summary>The <c>MIDIINCAPS</c> structure describes the capabilities of a MIDI input device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIINCAPS.wMid">
            <summary>
            Manufacturer identifier of the device driver for the MIDI input device. Manufacturer identifiers are defined in Manufacturer
            and Product Identifiers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIINCAPS.wPid">
            <summary>Product identifier of the MIDI input device. Product identifiers are defined in Manufacturer and Product Identifiers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIINCAPS.vDriverVersion">
            <summary>
            Version number of the device driver for the MIDI input device. The high-order byte is the major version number, and the
            low-order byte is the minor version number.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIINCAPS.szPname">
            <summary>Product name in a null-terminated string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIINCAPS.dwSupport">
            <summary>Reserved; must be zero.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIINCAPS.NativeSize">
            <summary>Gets the native size of this structure.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIDIOUTCAPS">
            <summary>The <c>MIDIOUTCAPS</c> structure describes the capabilities of a MIDI output device.</summary>
            <remarks>
            <para>Note</para>
            <para>
            The mmeapi.h header defines MIDIOUTCAPS as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOUTCAPS.wMid">
            <summary>
            Manufacturer identifier of the device driver for the MIDI output device. Manufacturer identifiers are defined in
            Manufacturer and Product Identifiers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOUTCAPS.wPid">
            <summary>Product identifier of the MIDI output device. Product identifiers are defined in Manufacturer and Product Identifiers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOUTCAPS.vDriverVersion">
            <summary>
            Version number of the device driver for the MIDI output device. The high-order byte is the major version number, and the
            low-order byte is the minor version number.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOUTCAPS.szPname">
            <summary>Product name in a null-terminated string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOUTCAPS.wTechnology">
            <summary>
            <para>Type of the MIDI output device. This value can be one of the following:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MOD_MIDIPORT</term>
            <term>MIDI hardware port.</term>
            </item>
            <item>
            <term>MOD_SYNTH</term>
            <term>Synthesizer.</term>
            </item>
            <item>
            <term>MOD_SQSYNTH</term>
            <term>Square wave synthesizer.</term>
            </item>
            <item>
            <term>MOD_FMSYNTH</term>
            <term>FM synthesizer.</term>
            </item>
            <item>
            <term>MOD_MAPPER</term>
            <term>Microsoft MIDI mapper.</term>
            </item>
            <item>
            <term>MOD_WAVETABLE</term>
            <term>Hardware wavetable synthesizer.</term>
            </item>
            <item>
            <term>MOD_SWSYNTH</term>
            <term>Software synthesizer.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOUTCAPS.wVoices">
            <summary>
            Number of voices supported by an internal synthesizer device. If the device is a port, this member is not meaningful and is
            set to 0.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOUTCAPS.wNotes">
            <summary>
            Maximum number of simultaneous notes that can be played by an internal synthesizer device. If the device is a port, this
            member is not meaningful and is set to 0.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOUTCAPS.wChannelMask">
            <summary>
            Channels that an internal synthesizer device responds to, where the least significant bit refers to channel 0 and the most
            significant bit to channel 15. Port devices that transmit on all channels set this member to 0xFFFF.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOUTCAPS.dwSupport">
            <summary>
            <para>Optional functionality supported by the device. It can be one or more of the following:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIDICAPS_CACHE</term>
            <term>Supports patch caching.</term>
            </item>
            <item>
            <term>MIDICAPS_LRVOLUME</term>
            <term>Supports separate left and right volume control.</term>
            </item>
            <item>
            <term>MIDICAPS_STREAM</term>
            <term>Provides direct support for the midiStreamOut function.</term>
            </item>
            <item>
            <term>MIDICAPS_VOLUME</term>
            <term>Supports volume control.</term>
            </item>
            </list>
            <para>
            If a device supports volume changes, the MIDICAPS_VOLUME flag will be set for the dwSupport member. If a device supports
            separate volume changes on the left and right channels, both the MIDICAPS_VOLUME and the MIDICAPS_LRVOLUME flags will be set
            for this member.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIOUTCAPS.NativeSize">
            <summary>Gets the native size of this structure.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIDIPROPTEMPO">
            <summary>The <c>MIDIPROPTEMPO</c> structure contains the tempo property for a stream.</summary>
            <remarks>The tempo property is read or written by the midiStreamProperty function.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIPROPTEMPO.cbStruct">
            <summary>
            Length, in bytes, of this structure. This member must be filled in for both the MIDIPROP_SET and MIDIPROP_GET operations of
            the midiStreamProperty function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIPROPTEMPO.dwTempo">
            <summary>
            Tempo of the stream, in microseconds per quarter note. The tempo is honored only if the time division for the stream is
            specified in quarter note format. This member is set in a MIDIPROP_SET operation and is filled on return from a MIDIPROP_GET operation.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIDIPROPTIMEDIV">
            <summary>The <c>MIDIPROPTIMEDIV</c> structure contains the time division property for a stream.</summary>
            <remarks>The time division property is read or written by the midiStreamProperty function.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIPROPTIMEDIV.cbStruct">
            <summary>
            Length, in bytes, of this structure. This member must be filled in for both the MIDIPROP_SET and MIDIPROP_GET operations of
            the midiStreamProperty function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDIPROPTIMEDIV.dwTimeDiv">
            <summary>
            Time division for this stream, in the format specified in the Standard MIDI Files 1.0 specification. The low 16 bits of this
            <c>DWORD</c> value contain the time division. This member is set in a MIDIPROP_SET operation and is filled on return from a
            MIDIPROP_GET operation.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIDISTRMBUFFVER">
            <summary>The <c>MIDISTRMBUFFVER</c> structure contains version information for a long MIDI event of the MEVT_VERSION type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDISTRMBUFFVER.dwVersion">
            <summary>
            Version of the stream. The high 16 bits contain the major version, and the low 16 bits contain the minor version. The
            version number for the first implementation of MIDI streams should be 1.0.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDISTRMBUFFVER.dwMid">
            <summary>Manufacturer identifier. Manufacturer identifiers are defined in Manufacturer and Product Identifiers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIDISTRMBUFFVER.dwOEMVersion">
            <summary>
            OEM version of the stream. Original equipment manufacturers can use this field to version-stamp any custom events they have
            specified. If a custom event is specified, it must be the first event sent after the stream is opened.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT_CLASS_MASK">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT_SUBCLASS_MASK">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT_UNITS_MASK">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXER_OBJECTF">
            <summary>Flags for retrieving control details.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_GETCONTROLDETAILSF_VALUE">
            <summary>
            Current values for a control are retrieved. The paDetails member of the MIXERCONTROLDETAILS structure points to one or more
            details structures appropriate for the control class.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_GETCONTROLDETAILSF_LISTTEXT">
            <summary>
            The paDetails member of the MIXERCONTROLDETAILS structure points to one or more MIXERCONTROLDETAILS_LISTTEXT structures to
            receive text labels for multiple-item controls. An application must get all list text items for a multiple-item control at
            once. This flag cannot be used with MIXERCONTROL_CONTROLTYPE_CUSTOM controls.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_OBJECTF_HANDLE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_OBJECTF_MIXER">
            <summary>
            The hmxobj parameter is the identifier of a mixer device in the range of zero to one less than the number of devices
            returned by the mixerGetNumDevs function. This flag is optional.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_OBJECTF_HMIXER">
            <summary>The hmxobj parameter is a mixer device handle returned by the mixerOpen function. This flag is optional.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_OBJECTF_WAVEOUT">
            <summary>
            The hmxobj parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of
            devices returned by the waveOutGetNumDevs function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_OBJECTF_HWAVEOUT">
            <summary>The hmxobj parameter is a waveform-audio output handle returned by the waveOutOpen function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_OBJECTF_WAVEIN">
            <summary>
            The hmxobj parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of
            devices returned by the waveInGetNumDevs function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_OBJECTF_HWAVEIN">
            <summary>The hmxobj parameter is a waveform-audio input handle returned by the waveInOpen function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_OBJECTF_MIDIOUT">
            <summary>
            The hmxobj parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less
            than the number of devices returned by the midiOutGetNumDevs function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_OBJECTF_HMIDIOUT">
            <summary>
            The hmxobj parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_OBJECTF_MIDIIN">
            <summary>
            The hmxobj parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than
            the number of devices returned by the midiInGetNumDevs function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_OBJECTF_HMIDIIN">
            <summary>
            The hmxobj parameter is the handle of a MIDI (Musical Instrument Digital Interface) input device. This handle must have been
            returned by the midiInOpen function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXER_OBJECTF.MIXER_OBJECTF_AUX">
            <summary>
            The hmxobj parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned
            by the auxGetNumDevs function.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERCONTROL_CONTROLF">
            <summary>Status and support flags for the audio line control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CONTROLF.MIXERCONTROL_CONTROLF_UNIFORM">
            <summary>
            The control acts on all channels of a multichannel line in a uniform fashion. For example, a control that mutes both
            channels of a stereo line would set this flag. Most MIXERCONTROL_CONTROLTYPE_MUX and MIXERCONTROL_CONTROLTYPE_MIXER controls
            also specify the MIXERCONTROL_CONTROLF_UNIFORM flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CONTROLF.MIXERCONTROL_CONTROLF_MULTIPLE">
            <summary>
            The control has two or more settings per channel. An equalizer, for example, requires this flag because each frequency band
            can be set to a different value. An equalizer that affects both channels of a stereo line in a uniform fashion will also
            specify the MIXERCONTROL_CONTROLF_UNIFORM flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CONTROLF.MIXERCONTROL_CONTROLF_DISABLED">
            <summary>
            The control is disabled, perhaps due to other settings for the mixer hardware, and cannot be used. An application can read
            current settings from a disabled control, but it cannot apply settings.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERCONTROL_CT">
            <summary>
            Class of the control for which the identifier is specified in <c>dwControlID</c>. An application must use this information to
            display the appropriate control for input from the user. An application can also display tailored graphics based on the control
            class or search for a particular control class on a specific line. If an application does not know about a control class, this
            control must be ignored.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_CLASS_CUSTOM">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_CLASS_METER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_CLASS_SWITCH">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_CLASS_NUMBER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_CLASS_SLIDER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_CLASS_FADER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_CLASS_TIME">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_CLASS_LIST">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_SC_SWITCH_BOOLEAN">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_SC_SWITCH_BUTTON">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_SC_METER_POLLED">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_SC_TIME_MICROSECS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_SC_TIME_MILLISECS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_SC_LIST_SINGLE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_SC_LIST_MULTIPLE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_UNITS_CUSTOM">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_UNITS_BOOLEAN">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_UNITS_SIGNED">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_UNITS_UNSIGNED">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_UNITS_DECIBELS">
            <summary>in 10ths</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CT_UNITS_PERCENT">
            <summary>in 10ths</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_CUSTOM">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_BOOLEANMETER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_SIGNEDMETER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_PEAKMETER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_BOOLEAN">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_ONOFF">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_MUTE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_MONO">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_LOUDNESS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_STEREOENH">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_BASS_BOOST">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_BUTTON">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_DECIBELS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_SIGNED">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_UNSIGNED">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_PERCENT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_SLIDER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_PAN">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_QSOUNDPAN">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_FADER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_VOLUME">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_BASS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_TREBLE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_EQUALIZER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_SINGLESELECT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_MUX">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_MIXER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_MICROTIME">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL_CT.MIXERCONTROL_CONTROLTYPE_MILLITIME">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE">
            <summary>
            Component type for this audio line. An application can use this information to display tailored graphics or to search for a
            particular component.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_DST_UNDEFINED">
            <summary>
            Audio line is a destination that cannot be defined by one of the standard component types. A mixer device is required to use
            this component type for line component types that have not been defined by Microsoft Corporation.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_DST_DIGITAL">
            <summary>Audio line is a digital destination (for example, digital input to a DAT or CD audio device).</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_DST_LINE">
            <summary>
            Audio line is a line level destination (for example, line level input from a CD audio device) that will be the final
            recording source for the analog-to-digital converter (ADC). Because most audio cards for personal computers provide some
            sort of gain for the recording audio source line, the mixer device will use the MIXERLINE_COMPONENTTYPE_DST_WAVEIN type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_DST_MONITOR">
            <summary>Audio line is a destination used for a monitor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_DST_SPEAKERS">
            <summary>
            Audio line is an adjustable (gain and/or attenuation) destination intended to drive speakers. This is the typical component
            type for the audio output of audio cards for personal computers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_DST_HEADPHONES">
            <summary>
            Audio line is an adjustable (gain and/or attenuation) destination intended to drive headphones. Most audio cards use the
            same audio destination line for speakers and headphones, in which case the mixer device simply uses the
            MIXERLINE_COMPONENTTYPE_DST_SPEAKERS type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_DST_TELEPHONE">
            <summary>Audio line is a destination that will be routed to a telephone line.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_DST_WAVEIN">
            <summary>
            Audio line is a destination that will be the final recording source for the waveform-audio input (ADC). This line typically
            provides some sort of gain or attenuation. This is the typical component type for the recording line of most audio cards for
            personal computers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_DST_VOICEIN">
            <summary>
            Audio line is a destination that will be the final recording source for voice input. This component type is exactly like
            MIXERLINE_COMPONENTTYPE_DST_WAVEIN but is intended specifically for settings used during voice recording/recognition.
            Support for this line is optional for a mixer device. Many mixer devices provide only MIXERLINE_COMPONENTTYPE_DST_WAVEIN.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED">
            <summary>
            Audio line is a source that cannot be defined by one of the standard component types. A mixer device is required to use this
            component type for line component types that have not been defined by Microsoft Corporation.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_SRC_DIGITAL">
            <summary>Audio line is a digital source (for example, digital output from a DAT or audio CD).</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_SRC_LINE">
            <summary>
            Audio line is a line-level source (for example, line-level input from an external stereo) that can be used as an optional
            recording source. Because most audio cards for personal computers provide some sort of gain for the recording source line,
            the mixer device will use the MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE">
            <summary>
            Audio line is a microphone recording source. Most audio cards for personal computers provide at least two types of recording
            sources: an auxiliary audio line and microphone input. A microphone audio line typically provides some sort of gain. Audio
            cards that use a single input for use with a microphone or auxiliary audio line should use the
            MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE component type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER">
            <summary>
            Audio line is a source originating from the output of an internal synthesizer. Most audio cards for personal computers
            provide some sort of MIDI synthesizer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC">
            <summary>
            Audio line is a source originating from the output of an internal audio CD. This component type is provided for audio cards
            that provide an audio source line intended to be connected to an audio CD (or CD-ROM playing an audio CD).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE">
            <summary>Audio line is a source originating from an incoming telephone line.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER">
            <summary>
            Audio line is a source originating from personal computer speaker. Several audio cards for personal computers provide the
            ability to mix what would typically be played on the internal speaker with the output of an audio card. Some audio cards
            support the ability to use this output as a recording source.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT">
            <summary>
            Audio line is a source originating from the waveform-audio output digital-to-analog converter (DAC). Most audio cards for
            personal computers provide this component type as a source to the MIXERLINE_COMPONENTTYPE_DST_SPEAKERS destination. Some
            cards also allow this source to be routed to the MIXERLINE_COMPONENTTYPE_DST_WAVEIN destination.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY">
            <summary>
            Audio line is a source originating from the auxiliary audio line. This line type is intended as a source with gain or
            attenuation that can be routed to the MIXERLINE_COMPONENTTYPE_DST_SPEAKERS destination and/or recorded from the
            MIXERLINE_COMPONENTTYPE_DST_WAVEIN destination.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_COMPONENTTYPE.MIXERLINE_COMPONENTTYPE_SRC_ANALOG">
            <summary>Audio line is an analog source (for example, analog output from a video-cassette tape).</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERLINE_LINEF">
            <summary>Status and support flags for the audio line.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_LINEF.MIXERLINE_LINEF_ACTIVE">
            <summary>Audio line is active. An active line indicates that a signal is probably passing through the line.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_LINEF.MIXERLINE_LINEF_DISCONNECTED">
            <summary>
            Audio line is disconnected. A disconnected line's associated controls can still be modified, but the changes have no effect
            until the line is connected.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE_LINEF.MIXERLINE_LINEF_SOURCE">
            <summary>
            Audio line is an audio source line associated with a single audio destination line. If this flag is not set, this line is an
            audio destination line associated with zero or more audio source lines.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mixerClose(Vanara.PInvoke.WinMm.HMIXER)">
            <summary>The <c>mixerClose</c> function closes the specified mixer device.</summary>
            <param name="hmx">
            Handle to the mixer device. This handle must have been returned successfully by the mixerOpen function. If <c>mixerClose</c> is
            successful, hmx is no longer valid.
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mixerGetControlDetails(Vanara.PInvoke.WinMm.HMIXEROBJ,Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS@,Vanara.PInvoke.WinMm.MIXER_OBJECTF)">
            <summary>The <c>mixerGetControlDetails</c> function retrieves details about a single control associated with an audio line.</summary>
            <param name="hmxobj">Handle to the mixer device object being queried.</param>
            <param name="pmxcd">Pointer to a MIXERCONTROLDETAILS structure, which is filled with state information about the control.</param>
            <param name="fdwDetails">
            <para>Flags for retrieving control details. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MIXER_GETCONTROLDETAILSF_LISTTEXT</term>
            <term>
            The paDetails member of the MIXERCONTROLDETAILS structure points to one or more MIXERCONTROLDETAILS_LISTTEXT structures to
            receive text labels for multiple-item controls. An application must get all list text items for a multiple-item control at once.
            This flag cannot be used with MIXERCONTROL_CONTROLTYPE_CUSTOM controls.
            </term>
            </item>
            <item>
            <term>MIXER_GETCONTROLDETAILSF_VALUE</term>
            <term>
            Current values for a control are retrieved. The paDetails member of the MIXERCONTROLDETAILS structure points to one or more
            details structures appropriate for the control class.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_AUX</term>
            <term>
            The hmxobj parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned by
            the auxGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIDIIN</term>
            <term>
            The hmxobj parameter is the handle of a MIDI (Musical Instrument Digital Interface) input device. This handle must have been
            returned by the midiInOpen function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIDIOUT</term>
            <term>The hmxobj parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIXER</term>
            <term>The hmxobj parameter is a mixer device handle returned by the mixerOpen function. This flag is optional.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HWAVEIN</term>
            <term>The hmxobj parameter is a waveform-audio input handle returned by the waveInOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HWAVEOUT</term>
            <term>The hmxobj parameter is a waveform-audio output handle returned by the waveOutOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIDIIN</term>
            <term>
            The hmxobj parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than the
            number of devices returned by the midiInGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIDIOUT</term>
            <term>
            The hmxobj parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less than
            the number of devices returned by the midiOutGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIXER</term>
            <term>
            The hmxobj parameter is the identifier of a mixer device in the range of zero to one less than the number of devices returned by
            the mixerGetNumDevs function. This flag is optional.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_WAVEIN</term>
            <term>
            The hmxobj parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of
            devices returned by the waveInGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_WAVEOUT</term>
            <term>
            The hmxobj parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of
            devices returned by the waveOutGetNumDevs function.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIXERR_INVALCONTROL</term>
            <term>The control reference is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The hmxobj parameter specifies an invalid device identifier.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>One or more flags are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The hmxobj parameter specifies an invalid handle.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>One or more parameters are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No mixer device is available for the object specified by hmxobj.</term>
            </item>
            </list>
            </returns>
            <remarks>All members of the MIXERCONTROLDETAILS structure must be initialized before calling this function.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mixerGetDevCaps(System.UInt32,Vanara.PInvoke.WinMm.MIXERCAPS@,System.UInt32)">
            <summary>The <c>mixerGetDevCaps</c> function queries a specified mixer device to determine its capabilities.</summary>
            <param name="uMxId">Identifier or handle of an open mixer device.</param>
            <param name="pmxcaps">Pointer to a MIXERCAPS structure that receives information about the capabilities of the device.</param>
            <param name="cbmxcaps">Size, in bytes, of the MIXERCAPS structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The specified device identifier is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The mixer device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>One or more parameters are invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Use the mixerGetNumDevs function to determine the number of mixer devices present in the system. The device identifier specified
            by uMxId varies from zero to one less than the number of mixer devices present.
            </para>
            <para>
            Only the number of bytes (or less) of information specified in cbmxcaps is copied to the location pointed to by pmxcaps. If
            cbmxcaps is zero, nothing is copied, and the function returns successfully.
            </para>
            <para>
            This function also accepts a mixer device handle returned by the mixerOpen function as the uMxId parameter. The application
            should cast the <c>HMIXER</c> handle to a <c>UINT</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mixerGetID(Vanara.PInvoke.WinMm.HMIXEROBJ,System.UInt32@,Vanara.PInvoke.WinMm.MIXER_OBJECTF)">
            <summary>
            The <c>mixerGetID</c> function retrieves the device identifier for a mixer device associated with a specified device handle.
            </summary>
            <param name="hmxobj">Handle to the audio mixer object to map to a mixer device identifier.</param>
            <param name="puMxId">
            Pointer to a variable that receives the mixer device identifier. If no mixer device is available for the hmxobj object, the
            value -1 is placed in this location and the MMSYSERR_NODRIVER error value is returned.
            </param>
            <param name="fdwId">
            <para>Flags for mapping the mixer object hmxobj. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MIXER_OBJECTF_AUX</term>
            <term>
            The hmxobj parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned by
            the auxGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIDIIN</term>
            <term>The hmxobj parameter is the handle of a MIDI input device. This handle must have been returned by the midiInOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIDIOUT</term>
            <term>The hmxobj parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIXER</term>
            <term>The hmxobj parameter is a mixer device handle returned by the mixerOpen function. This flag is optional.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HWAVEIN</term>
            <term>The hmxobj parameter is a waveform-audio input handle returned by the waveInOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HWAVEOUT</term>
            <term>The hmxobj parameter is a waveform-audio output handle returned by the waveOutOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIDIIN</term>
            <term>
            The hmxobj parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than the
            number of devices returned by the midiInGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIDIOUT</term>
            <term>
            The hmxobj parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less than
            the number of devices returned by the midiOutGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIXER</term>
            <term>
            The hmxobj parameter is the identifier of a mixer device in the range of zero to one less than the number of devices returned by
            the mixerGetNumDevs function. This flag is optional.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_WAVEIN</term>
            <term>
            The hmxobj parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of
            devices returned by the waveInGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_WAVEOUT</term>
            <term>
            The hmxobj parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of
            devices returned by the waveOutGetNumDevs function.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The hmxobj parameter specifies an invalid device identifier.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>One or more flags are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The hmxobj parameter specifies an invalid handle.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>One or more parameters are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>
            No audio mixer device is available for the object specified by hmxobj. The location referenced by puMxId also contains the value -1.
            </term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mixerGetLineControls(Vanara.PInvoke.WinMm.HMIXEROBJ,Vanara.PInvoke.WinMm.MIXERLINECONTROLS@,Vanara.PInvoke.WinMm.MIXER_OBJECTF)">
            <summary>The <c>mixerGetLineControls</c> function retrieves one or more controls associated with an audio line.</summary>
            <param name="hmxobj">Handle to the mixer device object that is being queried.</param>
            <param name="pmxlc">
            Pointer to a MIXERLINECONTROLS structure. This structure is used to reference one or more MIXERCONTROL structures to be filled
            with information about the controls associated with an audio line. The <c>cbStruct</c> member of the <c>MIXERLINECONTROLS</c>
            structure must always be initialized to be the size, in bytes, of the <c>MIXERLINECONTROLS</c> structure.
            </param>
            <param name="fdwControls">
            <para>Flags for retrieving information about one or more controls associated with an audio line. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MIXER_GETLINECONTROLSF_ALL</term>
            <term>
            The pmxlc parameter references a list of MIXERCONTROL structures that will receive information on all controls associated with
            the audio line identified by the dwLineID member of the MIXERLINECONTROLS structure. The cControls member must be initialized to
            the number of controls associated with the line. This number is retrieved from the cControls member of the MIXERLINE structure
            returned by the mixerGetLineInfo function. The cbmxctrl member must be initialized to the size, in bytes, of a single
            MIXERCONTROL structure. The pamxctrl member must point to the first MIXERCONTROL structure to be filled. The dwControlID and
            dwControlType members are ignored for this query.
            </term>
            </item>
            <item>
            <term>MIXER_GETLINECONTROLSF_ONEBYID</term>
            <term>
            The pmxlc parameter references a single MIXERCONTROL structure that will receive information on the control identified by the
            dwControlID member of the MIXERLINECONTROLS structure. The cControls member must be initialized to 1. The cbmxctrl member must
            be initialized to the size, in bytes, of a single MIXERCONTROL structure. The pamxctrl member must point to a MIXERCONTROL
            structure to be filled. The dwLineID and dwControlType members are ignored for this query. This query is usually used to refresh
            a control after receiving a MM_MIXM_CONTROL_CHANGE control change notification message by the user-defined callback (see mixerOpen).
            </term>
            </item>
            <item>
            <term>MIXER_GETLINECONTROLSF_ONEBYTYPE</term>
            <term>
            The mixerGetLineControls function retrieves information about the first control of a specific class for the audio line that is
            being queried. The pmxlc parameter references a single MIXERCONTROL structure that will receive information about the specific
            control. The audio line is identified by the dwLineID member. The control class is specified in the dwControlType member of the
            MIXERLINECONTROLS structure.The dwControlID member is ignored for this query. This query can be used by an application to get
            information on a single control associated with a line. For example, you might want your application to use a peak meter only
            from a waveform-audio output line.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_AUX</term>
            <term>
            The hmxobj parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned by
            the auxGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIDIIN</term>
            <term>The hmxobj parameter is the handle of a MIDI input device. This handle must have been returned by the midiInOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIDIOUT</term>
            <term>The hmxobj parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIXER</term>
            <term>The hmxobj parameter is a mixer device handle returned by the mixerOpen function. This flag is optional.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HWAVEIN</term>
            <term>The hmxobj parameter is a waveform-audio input handle returned by the waveInOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HWAVEOUT</term>
            <term>The hmxobj parameter is a waveform-audio output handle returned by the waveOutOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIDIIN</term>
            <term>
            The hmxobj parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than the
            number of devices returned by the midiInGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIDIOUT</term>
            <term>
            The hmxobj parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less than
            the number of devices returned by the midiOutGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIXER</term>
            <term>
            The hmxobj parameter is the identifier of a mixer device in the range of zero to one less than the number of devices returned by
            the mixerGetNumDevs function. This flag is optional.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_WAVEIN</term>
            <term>
            The hmxobj parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of
            devices returned by the waveInGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_WAVEOUT</term>
            <term>
            The hmxobj parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of
            devices returned by the waveOutGetNumDevs function.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIXERR_INVALCONTROL</term>
            <term>The control reference is invalid.</term>
            </item>
            <item>
            <term>MIXERR_INVALLINE</term>
            <term>The audio line reference is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The hmxobj parameter specifies an invalid device identifier.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>One or more flags are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The hmxobj parameter specifies an invalid handle.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>One or more parameters are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No mixer device is available for the object specified by hmxobj.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mixerGetLineInfo(Vanara.PInvoke.WinMm.HMIXEROBJ,Vanara.PInvoke.WinMm.MIXERLINE@,Vanara.PInvoke.WinMm.MIXER_OBJECTF)">
            <summary>The <c>mixerGetLineInfo</c> function retrieves information about a specific line of a mixer device.</summary>
            <param name="hmxobj">Handle to the mixer device object that controls the specific audio line.</param>
            <param name="pmxl">
            Pointer to a MIXERLINE structure. This structure is filled with information about the audio line for the mixer device. The
            <c>cbStruct</c> member must always be initialized to be the size, in bytes, of the <c>MIXERLINE</c> structure.
            </param>
            <param name="fdwInfo">
            <para>Flags for retrieving information about an audio line. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MIXER_GETLINEINFOF_COMPONENTTYPE</term>
            <term>
            The pmxl parameter will receive information about the first audio line of the type specified in the dwComponentType member of
            the MIXERLINE structure. This flag is used to retrieve information about an audio line of a specific component type. Remaining
            structure members except cbStruct require no further initialization.
            </term>
            </item>
            <item>
            <term>MIXER_GETLINEINFOF_DESTINATION</term>
            <term>
            The pmxl parameter will receive information about the destination audio line specified by the dwDestination member of the
            MIXERLINE structure. This index ranges from zero to one less than the value in the cDestinations member of the MIXERCAPS
            structure. All remaining structure members except cbStruct require no further initialization.
            </term>
            </item>
            <item>
            <term>MIXER_GETLINEINFOF_LINEID</term>
            <term>
            The pmxl parameter will receive information about the audio line specified by the dwLineID member of the MIXERLINE structure.
            This is usually used to retrieve updated information about the state of an audio line. All remaining structure members except
            cbStruct require no further initialization.
            </term>
            </item>
            <item>
            <term>MIXER_GETLINEINFOF_SOURCE</term>
            <term>
            The pmxl parameter will receive information about the source audio line specified by the dwDestination and dwSource members of
            the MIXERLINE structure. The index specified by dwDestination ranges from zero to one less than the value in the cDestinations
            member of the MIXERCAPS structure. The index specified by dwSource ranges from zero to one less than the value in the
            cConnections member of the MIXERLINE structure returned for the audio line stored in the dwDestination member. All remaining
            structure members except cbStruct require no further initialization.
            </term>
            </item>
            <item>
            <term>MIXER_GETLINEINFOF_TARGETTYPE</term>
            <term>
            The pmxl parameter will receive information about the audio line that is for the dwType member of the Target structure, which is
            a member of the MIXERLINE structure. This flag is used to retrieve information about an audio line that handles the target type
            (for example, MIXERLINE_TARGETTYPE_WAVEOUT). The application must initialize the dwType, wMid, wPid, vDriverVersion and szPname
            members of the MIXERLINE structure before calling mixerGetLineInfo. All of these values can be retrieved from the device
            capabilities structures for all media devices. Remaining structure members except cbStruct require no further initialization.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_AUX</term>
            <term>
            The hmxobj parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned by
            the auxGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIDIIN</term>
            <term>The hmxobj parameter is the handle of a MIDI input device. This handle must have been returned by the midiInOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIDIOUT</term>
            <term>The hmxobj parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIXER</term>
            <term>The hmxobj parameter is a mixer device handle returned by the mixerOpen function. This flag is optional.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HWAVEIN</term>
            <term>The hmxobj parameter is a waveform-audio input handle returned by the waveInOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HWAVEOUT</term>
            <term>The hmxobj parameter is a waveform-audio output handle returned by the waveOutOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIDIIN</term>
            <term>
            The hmxobj parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than the
            number of devices returned by the midiInGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIDIOUT</term>
            <term>
            The hmxobj parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less than
            the number of devices returned by the midiOutGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIXER</term>
            <term>
            The hmxobj parameter is a mixer device identifier in the range of zero to one less than the number of devices returned by the
            mixerGetNumDevs function. This flag is optional.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_WAVEIN</term>
            <term>
            The hmxobj parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of
            devices returned by the waveInGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_WAVEOUT</term>
            <term>
            The hmxobj parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of
            devices returned by the waveOutGetNumDevs function.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIXERR_INVALLINE</term>
            <term>The audio line reference is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The hmxobj parameter specifies an invalid device identifier.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>One or more flags are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The hmxobj parameter specifies an invalid handle.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>One or more parameters are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No mixer device is available for the object specified by hmxobj.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mixerGetNumDevs">
            <summary>The <c>mixerGetNumDevs</c> function retrieves the number of mixer devices present in the system.</summary>
            <returns>Returns the number of mixer devices or zero if no mixer devices are available.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mixerMessage(Vanara.PInvoke.WinMm.HMIXER,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>The <c>mixerMessage</c> function sends a custom mixer driver message directly to a mixer driver.</summary>
            <param name="hmx">
            Identifier of the mixer that receives the message. You must cast the device ID to the <c>HMIXER</c> handle type. If you supply a
            handle instead of a device ID, the function fails and returns the MMSYSERR_NOSUPPORT error code.
            </param>
            <param name="uMsg">
            Custom mixer driver message to send to the mixer driver. This message must be above or equal to the MXDM_USER constant.
            </param>
            <param name="dwParam1">Parameter associated with the message being sent.</param>
            <param name="dwParam2">Parameter associated with the message being sent.</param>
            <returns>
            <para>Returns a value that is specific to the custom mixer driver message. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The uMsg parameter specified in the MXDM_USER message is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOSUPPORT</term>
            <term>The deviceID parameter must be a valid device ID.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>The mixer device did not process the message.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            User-defined messages must be sent only to a mixer driver that supports the messages. The application should verify that the
            mixer driver is the driver that supports the message by retrieving the mixer capabilities and checking the <c>wMid</c>,
            <c>wPid</c>, <c>vDriverVersion</c>, and <c>szPname</c> members of the MIXERCAPS structure.
            </para>
            <para>The
            <code>DRV_QUERYDEVICEINTERFACE</code>
            message queries for the device-interface name of a <c>waveIn</c>, <c>waveOut</c>, <c>midiIn</c>, <c>midiOut</c>, or <c>mixer</c> device.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACE</code>
            , dwParam1 is a pointer to a caller-allocated buffer into which the function writes a null-terminated Unicode string containing
            the device-interface name. If the device has no device interface, the string length is zero.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACE</code>
            , dwParam2 specifies the buffer size in bytes. This is an input parameter to the function. The caller should specify a size that
            is greater than or equal to the buffer size retrieved by the DRV_QUERYDEVICEINTERFACESIZE message.
            </para>
            <para>
            The DRV_QUERYDEVICEINTERFACE message is supported in Windows Me, and Windows 2000 and later. This message is valid only for the
            waveInMessage, waveOutMessage, midiInMessage, midiOutMessage, and <c>mixerMessage</c> functions. The system intercepts this
            message and returns the appropriate value without sending the message to the device driver. For general information about
            system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>The following two message constants are used together for the purpose of obtaining device interface names:</para>
            <list type="bullet">
            <item>
            <term>DRV_QUERYDEVICEINTERFACESIZE</term>
            </item>
            <item>
            <term>DRV_QUERYDEVICEINTERFACE</term>
            </item>
            </list>
            <para>
            The first message obtains the size in bytes of the buffer needed to hold the string containing the device interface name. The
            second message retrieves the name string in a buffer of the required size.
            </para>
            <para>For more information, see Obtaining a Device Interface Name.</para>
            <para>The
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            message queries for the size of the buffer required to hold the device-interface name.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            , dwParam1 is a pointer to buffer size. This parameter points to a ULONG variable into which the function writes the required
            buffer size in bytes. The size includes storage space for the name string's terminating null. The size is zero if the device ID
            identifies a device that has no device interface.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            This message is valid only for the waveInMessage, waveOutMessage, midiInMessage, midiOutMessage, and <c>mixerMessage</c>
            functions. The system intercepts this message and returns the appropriate value without sending the message to the device
            driver. For general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            The buffer size retrieved by this message is expressed as a byte count. It specifies the size of the buffer needed to hold the
            null-terminated Unicode string that contains the device-interface name. The caller allocates a buffer of the specified size and
            uses the DRV_QUERYDEVICEINTERFACE message to retrieve the device-interface name string.
            </para>
            <para>For more information, see Obtaining a Device Interface Name.</para>
            <para>The
            <code>DRV_QUERYDEVNODE</code>
            message queries for the devnode number assigned to the device by the Plug and Play manager.
            </para>
            <para>For
            <code>DRV_QUERYDEVNODE</code>
            , dwParam1 is a pointer to a caller-allocated DWORD variable into which the function writes the devnode number. If no devnode is
            assigned to the device, the function sets this variable to zero.
            </para>
            <para>For
            <code>DRV_QUERYDEVNODE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            In Windows 2000 and later, the message always returns MMSYSERR_NOTSUPPORTED. This message is valid only for the waveInMessage,
            waveOutMessage, midiInMessage, midiOutMessage, and <c>mixerMessage</c> functions. The system intercepts this message and returns
            the appropriate value without sending the message to the device driver. For general information about system-intercepted
            <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>The
            <code>DRV_QUERYMAPPABLE</code>
            message queries for whether the specified device can be used by a mapper.
            </para>
            <para>For
            <code>DRV_QUERYMAPPABLE</code>
            , dwParam1 is unused. Set this parameter to zero.
            </para>
            <para>For
            <code>DRV_QUERYMAPPABLE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            This message is valid only for the waveInMessage, waveOutMessage, midiInMessage, midiOutMessage, <c>mixerMessage</c> and
            auxOutMessage functions. The system intercepts this message and returns the appropriate value without sending the message to the
            device driver. For general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            When an application program opens a mapper instead of a specific audio device, the system inserts a mapper between the
            application and the available devices. The mapper selects an appropriate device by mapping the application's requirements to one
            of the available devices. For more information about mappers, see the Microsoft Windows SDK documentation.
            </para>
            <para>The
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            message retrieves the device ID of the preferred voice-communications device.
            </para>
            <para>For
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            , dwParam1 is a pointer to device ID. This parameter points to a DWORD variable into which the function writes the device ID of
            the current preferred voice-communications device. The function writes the value (-1) if no device is available that qualifies
            as a preferred voice-communications device.
            </para>
            <para>For
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            , dwParam2 is a pointer to status flags. This parameter points to a DWORD variable into which the function writes the
            device-status flags. Only one flag bit is currently defined: DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY.
            </para>
            <para>
            This message is valid only for the waveInMessage and waveOutMessage functions. When a caller calls these two functions with the
            DRVM_MAPPER_CONSOLEVOICECOM_GET message, the caller must specify the device ID as WAVE_MAPPER, and then cast this value to the
            appropriate handle type. For the <c>waveInMessage</c>, <c>waveOutMessage</c>, midiInMessage, midiOutMessage, or
            <c>mixerMessage</c> functions, the caller must cast the device ID to a handle of type HWAVEIN, HWAVEOUT, HMIDIIN, HMIDIOUT, or
            HMIXER, respectively. Note that if the caller supplies a valid handle instead of a device ID for this parameter, the function
            fails and returns error code MMSYSERR_NOSUPPORT.
            </para>
            <para>
            The system intercepts this message and returns the appropriate value without sending the message to the device driver. For
            general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            This message provides a way to determine which device is preferred specifically for voice communications, in contrast to the
            DRVM_MAPPER_PREFERRED_GET message, which determines which device is preferred for all other audio functions.
            </para>
            <para>
            For example, the preferred <c>waveOut</c> device for voice communications might be the earpiece in a headset, but the preferred
            <c>waveOut</c> device for all other audio functions might be a set of stereo speakers.
            </para>
            <para>
            When the DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY flag bit is set in the DWORD location pointed to by dwParam2, the
            <c>waveIn</c> and <c>waveOut</c> APIs use only the current preferred voice-communications device and do not search for other
            available devices if the preferred device is unavailable. The flag that is output by either the <c>waveInMessage</c> or
            <c>waveOutMessage</c> call applies to the preferred voice-communications device for both the <c>waveIn</c> and <c>waveOut</c>
            APIs, regardless of whether the call is made to <c>waveInMessage</c> or <c>waveOutMessage</c>. For more information, see
            Preferred Voice-Communications Device ID.
            </para>
            <para>The
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            message retrieves the device ID of the preferred audio device.
            </para>
            <para>For
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            , dwParam1 is a pointer to device ID. This parameter points to a DWORD variable into which the function writes the device ID of
            the current preferred device. The function writes the value (-1) if no device is available that qualifies as a preferred device.
            </para>
            <para>For
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            , dwParam2 is a pointer to status flags. This parameter points to a DWORD variable into which the function writes the
            device-status flags. Only one flag bit is currently defined (for <c>waveInMessage</c> and <c>waveOutMessage</c> calls only): DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY.
            </para>
            <para>
            This message is valid only for the waveInMessage, waveOutMessage and midiOutMessage functions. When the caller calls these
            functions with the DRVM_MAPPER_PREFERRED_GET message, the caller must first specify the device ID as WAVE_MAPPER (for
            <c>waveInMessage</c> or <c>waveOutMessage</c>) or MIDI_MAPPER (for <c>midiOutMessage</c>), and then cast this value to the
            appropriate handle type. For the <c>waveInMessage</c>, <c>waveOutMessage</c>, or <c>midiOutMessage</c> functions, the caller
            must cast the device ID to a handle type HWAVEIN, HWAVEOUT or HMIDIOUT, respectively. Note that if the caller supplies a valid
            handle instead of a device ID for this parameter, the function fails and returns error code MMSYSERR_NOSUPPORT.
            </para>
            <para>
            The system intercepts this message and returns the appropriate value without sending the message to the device driver. For
            general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            This message provides a way to determine which device is preferred for audio functions in general, in contrast to the
            DRVM_MAPPER_CONSOLEVOICECOM_GET message, which determines which device is preferred specifically for voice communications.
            </para>
            <para>
            When the DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY flag bit is set in the DWORD location pointed to by dwParam2, the
            <c>waveIn</c> and <c>waveOut</c> APIs use only the current preferred device and do not search for other available devices if the
            preferred device is unavailable. Note that the <c>midiOutMessage</c> function does not output this flag--the <c>midiOut</c> API
            always uses only the preferred device. The flag that is output by either the <c>waveInMessage</c> or <c>waveOutMessage</c> call
            applies to the preferred device for both the <c>waveIn</c> and <c>waveOut</c> APIs, regardless of whether the call is made to
            <c>waveInMessage</c> or <c>waveOutMessage</c>.
            </para>
            <para>
            The xxxMessage functions accept this value in place of a valid device handle in order to allow an application to determine the
            default device ID without first having to open a device. For more information, see Accessing the Preferred Device ID.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mixerOpen(Vanara.PInvoke.WinMm.HMIXER,System.UInt32,System.IntPtr,System.IntPtr,Vanara.PInvoke.WinMm.MIXER_OBJECTF)">
            <summary>
            The <c>mixerOpen</c> function opens a specified mixer device and ensures that the device will not be removed until the
            application closes the handle.
            </summary>
            <param name="phmx">
            Pointer to a variable that will receive a handle identifying the opened mixer device. Use this handle to identify the device
            when calling other audio mixer functions. This parameter cannot be <c>NULL</c>.
            </param>
            <param name="uMxId">
            Identifier of the mixer device to open. Use a valid device identifier or any <c>HMIXEROBJ</c> (see the mixerGetID function for a
            description of mixer object handles). A "mapper" for audio mixer devices does not currently exist, so a mixer device identifier
            of -1 is not valid.
            </param>
            <param name="dwCallback">
            Handle to a window called when the state of an audio line and/or control associated with the device being opened is changed.
            Specify <c>NULL</c> for this parameter if no callback mechanism is to be used.
            </param>
            <param name="dwInstance">Reserved. Must be zero.</param>
            <param name="fdwOpen">
            <para>Flags for opening the device. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>CALLBACK_WINDOW</term>
            <term>The dwCallback parameter is assumed to be a window handle (HWND).</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_AUX</term>
            <term>
            The uMxId parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned by
            the auxGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIDIIN</term>
            <term>The uMxId parameter is the handle of a MIDI input device. This handle must have been returned by the midiInOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIDIOUT</term>
            <term>The uMxId parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIXER</term>
            <term>The uMxId parameter is a mixer device handle returned by the mixerOpen function. This flag is optional.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HWAVEIN</term>
            <term>The uMxId parameter is a waveform-audio input handle returned by the waveInOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HWAVEOUT</term>
            <term>The uMxId parameter is a waveform-audio output handle returned by the waveOutOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIDIIN</term>
            <term>
            The uMxId parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than the
            number of devices returned by the midiInGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIDIOUT</term>
            <term>
            The uMxId parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less than the
            number of devices returned by the midiOutGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIXER</term>
            <term>
            The uMxId parameter is a mixer device identifier in the range of zero to one less than the number of devices returned by the
            mixerGetNumDevs function. This flag is optional.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_WAVEIN</term>
            <term>
            The uMxId parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of
            devices returned by the waveInGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_WAVEOUT</term>
            <term>
            The uMxId parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of
            devices returned by the waveOutGetNumDevs function.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns <c>MMSYSERR_NOERROR</c> if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_ALLOCATED</term>
            <term>The specified resource is already allocated by the maximum number of clients possible.</term>
            </item>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The uMxId parameter specifies an invalid device identifier.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>One or more flags are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The uMxId parameter specifies an invalid handle.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>One or more parameters are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>
            No mixer device is available for the object specified by uMxId. Note that the location referenced by uMxId will also contain the
            value –1.
            </term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate resources.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Use the mixerGetNumDevs function to determine the number of audio mixer devices present in the system. The device identifier
            specified by uMxId varies from zero to one less than the number of devices present.
            </para>
            <para>
            If a window is chosen to receive callback information, the MM_MIXM_LINE_CHANGE and MM_MIXM_CONTROL_CHANGE messages are sent to
            the window procedure function to indicate when an audio line or control state changes. For both messages, the wParam parameter
            is the handle of the mixer device. The lParam parameter is the line identifier for <c>MM_MIXM_LINE_CHANGE</c> or the control
            identifier for <c>MM_MIXM_CONTROL_CHANGE</c> that changed state.
            </para>
            <para>To query for audio mixer support or a media device, use the mixerGetID function.</para>
            <para>
            On 64-bit systems, this function may not work as expected in situations where you pass a 64-bit <c>LPHWAVEOUT</c> pointer in the
            uMxId parameter, because the uMxId parameter is truncated to 32 bits.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mixerSetControlDetails(Vanara.PInvoke.WinMm.HMIXEROBJ,Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS@,Vanara.PInvoke.WinMm.MIXER_OBJECTF)">
            <summary>The <c>mixerSetControlDetails</c> function sets properties of a single control associated with an audio line.</summary>
            <param name="hmxobj">Handle to the mixer device object for which properties are being set.</param>
            <param name="pmxcd">
            Pointer to a MIXERCONTROLDETAILS structure. This structure is used to reference control detail structures that contain the
            desired state for the control.
            </param>
            <param name="fdwDetails">
            <para>Flags for setting properties for a control. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MIXER_OBJECTF_AUX</term>
            <term>
            The hmxobj parameter is an auxiliary device identifier in the range of zero to one less than the number of devices returned by
            the auxGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIDIIN</term>
            <term>The hmxobj parameter is the handle of a MIDI input device. This handle must have been returned by the midiInOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIDIOUT</term>
            <term>The hmxobj parameter is the handle of a MIDI output device. This handle must have been returned by the midiOutOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HMIXER</term>
            <term>The hmxobj parameter is a mixer device handle returned by the mixerOpen function. This flag is optional.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HWAVEIN</term>
            <term>The hmxobj parameter is a waveform-audio input handle returned by the waveInOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_HWAVEOUT</term>
            <term>The hmxobj parameter is a waveform-audio output handle returned by the waveOutOpen function.</term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIDIIN</term>
            <term>
            The hmxobj parameter is the identifier of a MIDI input device. This identifier must be in the range of zero to one less than the
            number of devices returned by the midiInGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIDIOUT</term>
            <term>
            The hmxobj parameter is the identifier of a MIDI output device. This identifier must be in the range of zero to one less than
            the number of devices returned by the midiOutGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_MIXER</term>
            <term>
            The hmxobj parameter is a mixer device identifier in the range of zero to one less than the number of devices returned by the
            mixerGetNumDevs function. This flag is optional.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_WAVEIN</term>
            <term>
            The hmxobj parameter is the identifier of a waveform-audio input device in the range of zero to one less than the number of
            devices returned by the waveInGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_OBJECTF_WAVEOUT</term>
            <term>
            The hmxobj parameter is the identifier of a waveform-audio output device in the range of zero to one less than the number of
            devices returned by the waveOutGetNumDevs function.
            </term>
            </item>
            <item>
            <term>MIXER_SETCONTROLDETAILSF_CUSTOM</term>
            <term>
            A custom dialog box for the specified custom mixer control is displayed. The mixer device gathers the required information from
            the user and returns the data in the specified buffer. The handle for the owning window is specified in the hwndOwner member of
            the MIXERCONTROLDETAILS structure. (This handle can be set to NULL.) The application can then save the data from the dialog box
            and use it later to reset the control to the same state by using the MIXER_SETCONTROLDETAILSF_VALUE flag.
            </term>
            </item>
            <item>
            <term>MIXER_SETCONTROLDETAILSF_VALUE</term>
            <term>
            The current value(s) for a control are set. The paDetails member of the MIXERCONTROLDETAILS structure points to one or more
            mixer-control details structures of the appropriate class for the control.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIXERR_INVALCONTROL</term>
            <term>The control reference is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>The hmxobj parameter specifies an invalid device identifier.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>One or more flags are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The hmxobj parameter specifies an invalid handle.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>One or more parameters are invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No mixer device is available for the object specified by hmxobj.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>All members of the MIXERCONTROLDETAILS structure must be initialized before calling <c>mixerSetControlDetails</c>.</para>
            <para>
            If an application needs to retrieve only the current state of a custom mixer control and not display a dialog box, then
            mixerGetControlDetails can be used with the MIXER_GETCONTROLDETAILSF_VALUE flag.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.HMIXER">
            <summary>Provides a handle to a mixer device.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXER.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.HMIXER"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMIXER.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.WinMm.HMIXER"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMIXER.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXER.op_Explicit(Vanara.PInvoke.WinMm.HMIXER)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.WinMm.HMIXER"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXER.op_Implicit(System.IntPtr)~Vanara.PInvoke.WinMm.HMIXER">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.WinMm.HMIXER"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXER.op_Inequality(Vanara.PInvoke.WinMm.HMIXER,Vanara.PInvoke.WinMm.HMIXER)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXER.op_Equality(Vanara.PInvoke.WinMm.HMIXER,Vanara.PInvoke.WinMm.HMIXER)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXER.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXER.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXER.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.HMIXEROBJ">
            <summary>Provides a handle to a mixer device object.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXEROBJ.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.HMIXEROBJ"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMIXEROBJ.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.WinMm.HMIXEROBJ"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMIXEROBJ.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXEROBJ.op_Explicit(Vanara.PInvoke.WinMm.HMIXEROBJ)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.WinMm.HMIXEROBJ"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXEROBJ.op_Implicit(System.IntPtr)~Vanara.PInvoke.WinMm.HMIXEROBJ">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.WinMm.HMIXEROBJ"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXEROBJ.op_Inequality(Vanara.PInvoke.WinMm.HMIXEROBJ,Vanara.PInvoke.WinMm.HMIXEROBJ)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXEROBJ.op_Equality(Vanara.PInvoke.WinMm.HMIXEROBJ,Vanara.PInvoke.WinMm.HMIXEROBJ)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXEROBJ.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXEROBJ.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMIXEROBJ.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERCAPS">
            <summary>The <c>MIXERCAPS</c> structure describes the capabilities of a mixer device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCAPS.wMid">
            <summary>
            A manufacturer identifier for the mixer device driver. Manufacturer identifiers are defined in Manufacturer and Product Identifiers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCAPS.wPid">
            <summary>
            A product identifier for the mixer device driver. Product identifiers are defined in Manufacturer and Product Identifiers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCAPS.vDriverVersion">
            <summary>
            Version number of the mixer device driver. The high-order byte is the major version number, and the low-order byte is the
            minor version number.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCAPS.szPname">
            <summary>
            Name of the product. If the mixer device driver supports multiple cards, this string must uniquely and easily identify
            (potentially to a user) the specific card.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCAPS.fdwSupport">
            <summary>Various support information for the mixer device driver. No extended support bits are currently defined.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCAPS.cDestinations">
            <summary>
            The number of audio line destinations available through the mixer device. All mixer devices must support at least one
            destination line, so this member cannot be zero. Destination indexes used in the <c>dwDestination</c> member of the
            MIXERLINE structure range from zero to the value specified in the <c>cDestinations</c> member minus one.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCAPS.NativeSize">
            <summary>Gets the native size of this structure.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERCONTROL">
            <summary>The <c>MIXERCONTROL</c> structure describes the state and metrics of a single control for an audio line.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL.cbStruct">
            <summary>Size, in bytes, of the <c>MIXERCONTROL</c> structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL.dwControlID">
            <summary>
            Audio mixer-defined identifier that uniquely refers to the control described by the <c>MIXERCONTROL</c> structure. This
            identifier can be in any format supported by the mixer device. An application should use this identifier only as an abstract
            handle. No two controls for a single mixer device can ever have the same control identifier.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL.dwControlType">
            <summary>
            <para>
            Class of the control for which the identifier is specified in <c>dwControlID</c>. An application must use this information
            to display the appropriate control for input from the user. An application can also display tailored graphics based on the
            control class or search for a particular control class on a specific line. If an application does not know about a control
            class, this control must be ignored. There are eight control class classifications, each with one or more standard control types:
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Descriptions</term>
            </listheader>
            <item>
            <term>MIXERCONTROL_CT_CLASS_CUSTOM</term>
            <term>MIXERCONTROL_CONTROLTYPE_CUSTOM</term>
            </item>
            <item>
            <term>MIXERCONTROL_CT_CLASS_FADER</term>
            <term>
            MIXERCONTROL_CONTROLTYPE_BASS MIXERCONTROL_CONTROLTYPE_EQUALIZER MIXERCONTROL_CONTROLTYPE_FADER
            MIXERCONTROL_CONTROLTYPE_TREBLE MIXERCONTROL_CONTROLTYPE_VOLUME
            </term>
            </item>
            <item>
            <term>MIXERCONTROL_CT_CLASS_LIST</term>
            <term>MIXERCONTROL_CONTROLTYPE_MIXER MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT MIXERCONTROL_CONTROLTYPE_MUX MIXERCONTROL_CONTROLTYPE_SINGLESELECT</term>
            </item>
            <item>
            <term>MIXERCONTROL_CT_CLASS_METER</term>
            <term>MIXERCONTROL_CONTROLTYPE_BOOLEANMETER MIXERCONTROL_CONTROLTYPE_PEAKMETER MIXERCONTROL_CONTROLTYPE_SIGNEDMETER MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER</term>
            </item>
            <item>
            <term>MIXERCONTROL_CT_CLASS_NUMBER</term>
            <term>MIXERCONTROL_CONTROLTYPE_DECIBELS MIXERCONTROL_CONTROLTYPE_PERCENT MIXERCONTROL_CONTROLTYPE_SIGNED MIXERCONTROL_CONTROLTYPE_UNSIGNED</term>
            </item>
            <item>
            <term>MIXERCONTROL_CT_CLASS_SLIDER</term>
            <term>MIXERCONTROL_CONTROLTYPE_PAN MIXERCONTROL_CONTROLTYPE_QSOUNDPAN MIXERCONTROL_CONTROLTYPE_SLIDER</term>
            </item>
            <item>
            <term>MIXERCONTROL_CT_CLASS_SWITCH</term>
            <term>
            MIXERCONTROL_CONTROLTYPE_BOOLEAN MIXERCONTROL_CONTROLTYPE_BUTTON MIXERCONTROL_CONTROLTYPE_LOUDNESS
            MIXERCONTROL_CONTROLTYPE_MONO MIXERCONTROL_CONTROLTYPE_MUTE MIXERCONTROL_CONTROLTYPE_ONOFF MIXERCONTROL_CONTROLTYPE_STEREOENH
            </term>
            </item>
            <item>
            <term>MIXERCONTROL_CT_CLASS_TIME</term>
            <term>MIXERCONTROL_CONTROLTYPE_MICROTIME MIXERCONTROL_CONTROLTYPE_MILLITIME</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL.fdwControl">
            <summary>
            <para>Status and support flags for the audio line control. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIXERCONTROL_CONTROLF_DISABLED</term>
            <term>
            The control is disabled, perhaps due to other settings for the mixer hardware, and cannot be used. An application can read
            current settings from a disabled control, but it cannot apply settings.
            </term>
            </item>
            <item>
            <term>MIXERCONTROL_CONTROLF_MULTIPLE</term>
            <term>
            The control has two or more settings per channel. An equalizer, for example, requires this flag because each frequency band
            can be set to a different value. An equalizer that affects both channels of a stereo line in a uniform fashion will also
            specify the MIXERCONTROL_CONTROLF_UNIFORM flag.
            </term>
            </item>
            <item>
            <term>MIXERCONTROL_CONTROLF_UNIFORM</term>
            <term>
            The control acts on all channels of a multichannel line in a uniform fashion. For example, a control that mutes both
            channels of a stereo line would set this flag. Most MIXERCONTROL_CONTROLTYPE_MUX and MIXERCONTROL_CONTROLTYPE_MIXER controls
            also specify the MIXERCONTROL_CONTROLF_UNIFORM flag.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL.cMultipleItems">
            <summary>
            Number of items per channel that make up a MIXERCONTROL_CONTROLF_MULTIPLE control. This number is always two or greater for
            multiple-item controls. If the control is not a multiple-item control, do not use this member; it will be zero.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL.szShortName">
            <summary>
            Short string that describes the audio line control specified by <c>dwControlID</c>. This description should be appropriate
            to use as a concise label for the control.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL.szName">
            <summary>
            String that describes the audio line control specified by <c>dwControlID</c>. This description should be appropriate to use
            as a complete description for the control.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL.Bounds">
            <summary>Union of boundary types.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERCONTROL.BOUNDS">
            <summary>Union of boundary types.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL.BOUNDS.lMinimum">
            <summary>
            Minimum signed value for a control that has a signed boundary nature. This member cannot be used in conjunction with <c>dwMinimum</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL.BOUNDS.lMaximum">
            <summary>
            Maximum signed value for a control that has a signed boundary nature. This member cannot be used in conjunction with <c>dwMaximum</c>.
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.MIXERCONTROL.BOUNDS.dwMinimum">
            <summary>
            Minimum unsigned value for a control that has an unsigned boundary nature. This member cannot be used in conjunction
            with <c>lMinimum</c>.
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.MIXERCONTROL.BOUNDS.dwMaximum">
            <summary>
            Maximum unsigned value for a control that has an unsigned boundary nature. This member cannot be used in conjunction
            with <c>lMaximum</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL.Metrics">
            <summary>Union of boundary metrics.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERCONTROL.METRICS">
            <summary>Union of boundary metrics.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROL.METRICS.cSteps">
            <summary>
            Number of discrete ranges within the union specified for a control specified by the <c>Bounds</c> member. This member
            overlaps with the other members of the <c>Metrics</c> structure member and cannot be used in conjunction with those members.
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.MIXERCONTROL.METRICS.cbCustomData">
            <summary>
            Size, in bytes, required to contain the state of a custom control class. This member is appropriate only for the
            MIXERCONTROL_CONTROLTYPE_CUSTOM control class.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS">
            <summary>
            The <c>MIXERCONTROLDETAILS</c> structure refers to control-detail structures, retrieving or setting state information of an
            audio mixer control. All members of this structure must be initialized before calling the mixerGetControlDetails and
            mixerSetControlDetails functions.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS.cbStruct">
            <summary>
            Size, in bytes, of the <c>MIXERCONTROLDETAILS</c> structure. The size must be large enough to contain the base
            <c>MIXERCONTROLDETAILS</c> structure. When mixerGetControlDetails returns, this member contains the actual size of the
            information returned. The returned information will not exceed the requested size, nor will it be smaller than the base
            <c>MIXERCONTROLDETAILS</c> structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS.dwControlID">
            <summary>Control identifier on which to get or set properties.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS.cChannels">
            <summary>
            <para>Number of channels on which to get or set control properties. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>0</term>
            <term>Use this value when the control is a MIXERCONTROL_CONTROLTYPE_CUSTOM control.</term>
            </item>
            <item>
            <term>1</term>
            <term>
            Use this value when the control is a MIXERCONTROL_CONTROLF_UNIFORM control or when an application needs to get and set all
            channels as if they were uniform.
            </term>
            </item>
            <item>
            <term>MIXERLINE cChannels</term>
            <term>Use this value when the properties for the control are expected on all channels for a line.</term>
            </item>
            </list>
            <para>
            An application cannot specify a value that falls between 1 and the number of channels for the audio line. For example,
            specifying 2 or 3 for a four-channel line is not valid. This member cannot be 0 for noncustom control types.
            </para>
            <para>This member cannot be 0 for noncustom control types.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS.hwndOwner">
            <summary>
            Handle to the window that owns a custom dialog box for a mixer control. This member is used when the
            MIXER_SETCONTROLDETAILSF_CUSTOM flag is specified in the mixerSetControlDetails function.
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS.cMultipleItems">
            <summary>
            <para>Number of multiple items per channel on which to get or set properties. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>0</term>
            <term>Use this value for all controls except for a MIXERCONTROL_CONTROLF_MULTIPLE or a MIXERCONTROL_CONTROLTYPE_CUSTOM control.</term>
            </item>
            <item>
            <term>MIXERCONTROL cMultipleItems member</term>
            <term>Use this value when the control class is MIXERCONTROL_CONTROLF_MULTIPLE.</term>
            </item>
            <item>
            <term>MIXERCONTROLDETAILS hwndOwner member</term>
            <term>
            Use this value when the control is a MIXERCONTROL_CONTROLTYPE_CUSTOM control and the MIXER_SETCONTROLDETAILSF_CUSTOM flag is
            specified for the mixerSetControlDetails function. In this case, the hwndOwner member overlaps with cMultipleItems,
            providing the value of the window handle.
            </term>
            </item>
            </list>
            <para>
            When using a MIXERCONTROL_CONTROLTYPE_CUSTOM control without the MIXERCONTROL_CONTROLTYPE_CUSTOM flag, specify zero for this member.
            </para>
            <para>
            An application cannot specify any value other than the value specified in the cMultipleItems member of the MIXERCONTROL
            structure for a MIXERCONTROL_CONTROLF_MULTIPLE control.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS.cbDetails">
            <summary>
            <para>Size, in bytes, of one of the following details structures being used:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIXERCONTROLDETAILS_BOOLEAN</term>
            <term>Boolean value for an audio line control.</term>
            </item>
            <item>
            <term>MIXERCONTROLDETAILS_LISTTEXT</term>
            <term>
            List text buffer for an audio line control. For information about the appropriate details structure for a specific control,
            see Control Types.
            </term>
            </item>
            <item>
            <term>MIXERCONTROLDETAILS_SIGNED</term>
            <term>Signed value for an audio line control.</term>
            </item>
            <item>
            <term>MIXERCONTROLDETAILS_UNSIGNED</term>
            <term>Unsigned value for an audio line control.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS.paDetails">
            <summary>
            <para>Pointer to an array of one or more structures in which properties for the specified control are retrieved or set.</para>
            <para>
            For MIXERCONTROL_CONTROLF_MULTIPLE controls, the size of this buffer should be the product of the <c>cChannels</c>,
            <c>cMultipleItems</c> and <c>cbDetails</c> members of the <c>MIXERCONTROLDETAILS</c> structure. For controls other than
            MIXERCONTROL_CONTROLF_MULTIPLE types, the size of this buffer is the product of the <c>cChannels</c> and <c>cbDetails</c>
            members of the <c>MIXERCONTROLDETAILS</c> structure.
            </para>
            <para>
            For controls other than MIXERCONTROL_CONTROLF_MULTIPLE types, the size of this buffer is the product of the <c>cChannels</c>
            and <c>cbDetails</c> members of the <c>MIXERCONTROLDETAILS</c> structure. For controls other than
            MIXERCONTROL_CONTROLF_MULTIPLE types, the size of this buffer is the product of the <c>cChannels</c> and <c>cbDetails</c>
            members of the <c>MIXERCONTROLDETAILS</c> structure.
            </para>
            <para>
            For controls that are MIXERCONTROL_CONTROLF_MULTIPLE types, the array can be treated as a two-dimensional array that is
            channel major. That is, all multiple items for the left channel are given, then all multiple items for the right channel,
            and so on.
            </para>
            <para>
            For controls other than MIXERCONTROL_CONTROLF_MULTIPLE types, each element index is equivalent to the zero-based channel
            that it affects. That is, paDetails[0] is for the left channel and paDetails[1] is for the right channel.
            </para>
            <para>
            If the control is a MIXERCONTROL_CONTROLTYPE_CUSTOM control, this member must point to a buffer that is at least large
            enough to contain the size, in bytes, specified by the cbCustomData member of the MIXERCONTROL structure.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS_BOOLEAN">
            <summary>
            The <c>MIXERCONTROLDETAILS_BOOLEAN</c> structure retrieves and sets Boolean control properties for an audio mixer control
            </summary>
            <remarks>
            <para>The following standard control types use this structure for retrieving and setting properties.</para>
            <para>Meter controls:</para>
            <para>MIXERCONTROL_CONTROLTYPE_BOOLEANMETER</para>
            <para>Switch controls:</para>
            <para>MIXERCONTROL_CONTROLTYPE_BOOLEAN</para>
            <para>MIXERCONTROL_CONTROLTYPE_BUTTON</para>
            <para>MIXERCONTROL_CONTROLTYPE_LOUDNESS</para>
            <para>MIXERCONTROL_CONTROLTYPE_MONO</para>
            <para>MIXERCONTROL_CONTROLTYPE_MUTE</para>
            <para>MIXERCONTROL_CONTROLTYPE_ONOFF</para>
            <para>MIXERCONTROL_CONTROLTYPE_STEREOENH</para>
            <para>List controls:</para>
            <para>MIXERCONTROL_CONTROLTYPE_MIXER</para>
            <para>MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT</para>
            <para>MIXERCONTROL_CONTROLTYPE_MUX</para>
            <para>MIXERCONTROL_CONTROLTYPE_SINGLESELECT</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS_BOOLEAN.fValue">
            <summary>
            Boolean value for a single item or channel. This value is assumed to be zero for a FALSE state (such as off or disabled),
            and nonzero for a TRUE state (such as on or enabled).
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS_LISTTEXT">
            <summary>
            The MIXERCONTROLDETAILS_LISTTEXT structure retrieves list text, label text, and/or band-range information for multiple-item
            controls. This structure is used when the MIXER_GETCONTROLDETAILSF_LISTTEXT flag is specified in the mixerGetControlDetails function.
            </summary>
            <remarks>
            <para>The following standard control types use this structure for retrieving the item text descriptions on multiple-item controls:</para>
            <para>Fader control:</para>
            <para>MIXERCONTROL_CONTROLTYPE_EQUALIZER</para>
            <para>List controls:</para>
            <para>MIXERCONTROL_CONTROLTYPE_MIXER</para>
            <para>MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT</para>
            <para>MIXERCONTROL_CONTROLTYPE_MUX</para>
            <para>MIXERCONTROL_CONTROLTYPE_SINGLESELECT</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS_LISTTEXT.dwParam1">
            <summary>
            <para>Control class-specific values. The following control types are listed with their corresponding values:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>EQUALIZER</term>
            <term>MIXERCONTROL. Bounds dwMinimum member.</term>
            </item>
            <item>
            <term>MIXER and MUX</term>
            <term>MIXERLINEdwLineID member.</term>
            </item>
            <item>
            <term>MULTIPLESELECT and SINGLESELECT</term>
            <term>Undefined; must be zero</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS_LISTTEXT.dwParam2">
            <summary>See dwParam1.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS_LISTTEXT.szName">
            <summary>
            Name describing a single item in a multiple-item control. This text can be used as a label or item text, depending on the
            control class.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS_SIGNED">
            <summary>The MIXERCONTROLDETAILS_SIGNED structure retrieves and sets signed type control properties for an audio mixer control.</summary>
            <remarks>
            <para>The following standard control types use this structure for retrieving and setting properties:</para>
            <para>Meter controls:</para>
            <para>MIXERCONTROL_CONTROLTYPE_PEAKMETER</para>
            <para>MIXERCONTROL_CONTROLTYPE_SIGNEDMETER</para>
            <para>Member controls:</para>
            <para>MIXERCONTROL_CONTROLTYPE_SIGNED</para>
            <para>Number controls:</para>
            <para>MIXERCONTROL_CONTROLTYPE_DECIBELS</para>
            <para>Slider controls:</para>
            <para>MIXERCONTROL_CONTROLTYPE_PAN</para>
            <para>MIXERCONTROL_CONTROLTYPE_QSOUNDPAN</para>
            <para>MIXERCONTROL_CONTROLTYPE_SLIDER</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS_SIGNED.lValue">
            <summary>
            Signed integer value for a single item or channel. This value must be inclusively within the bounds given in the Bounds
            member of this structure for signed integer controls.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS_UNSIGNED">
            <summary>
            The MIXERCONTROLDETAILS_UNSIGNED structure retrieves and sets unsigned type control properties for an audio mixer control.
            </summary>
            <remarks>
            <para>The following standard control types use this structure for retrieving and setting properties:</para>
            <para>Meter control:</para>
            <para>MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER</para>
            <para>Number control:</para>
            <para>MIXERCONTROL_CONTROLTYPE_UNSIGNED</para>
            <para>Fader controls:</para>
            <para>MIXERCONTROL_CONTROLTYPE_BASS</para>
            <para>MIXERCONTROL_CONTROLTYPE_EQUALIZER</para>
            <para>MIXERCONTROL_CONTROLTYPE_FADER</para>
            <para>MIXERCONTROL_CONTROLTYPE_TREBLE</para>
            <para>MIXERCONTROL_CONTROLTYPE_VOLUME</para>
            <para>Time controls:</para>
            <para>MIXERCONTROL_CONTROLTYPE_MICROTIME</para>
            <para>MIXERCONTROL_CONTROLTYPE_MILLITIME</para>
            <para>MIXERCONTROL_CONTROLTYPE_PERCENT</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERCONTROLDETAILS_UNSIGNED.dwValue">
            <summary>
            Unsigned integer value for a single item or channel. This value must be inclusively within the bounds given in the Bounds
            structure member of the MIXERCONTROL structure for unsigned integer controls.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERLINE">
            <summary>The <c>MIXERLINE</c> structure describes the state and metrics of an audio line.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.cbStruct">
            <summary>
            Size, in bytes, of the <c>MIXERLINE</c> structure. This member must be initialized before calling the mixerGetLineInfo
            function. The size specified in this member must be large enough to contain the <c>MIXERLINE</c> structure. When
            <c>mixerGetLineInfo</c> returns, this member contains the actual size of the information returned. The returned information
            will not exceed the requested size.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.dwDestination">
            <summary>
            Destination line index. This member ranges from zero to one less than the value specified in the <c>cDestinations</c> member
            of the MIXERCAPS structure retrieved by the mixerGetDevCaps function. When the mixerGetLineInfo function is called with the
            MIXER_GETLINEINFOF_DESTINATION flag, properties for the destination line are returned. (The <c>dwSource</c> member must be
            set to zero in this case.) When called with the MIXER_GETLINEINFOF_SOURCE flag, the properties for the source given by the
            <c>dwSource</c> member that is associated with the <c>dwDestination</c> member are returned.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.dwSource">
            <summary>
            Index for the audio source line associated with the <c>dwDestination</c> member. That is, this member specifies the nth
            audio source line associated with the specified audio destination line. This member is not used for destination lines and
            must be set to zero when MIXER_GETLINEINFOF_DESTINATION is specified in the mixerGetLineInfo function. When the
            MIXER_GETLINEINFOF_SOURCE flag is specified, this member ranges from zero to one less than the value specified in the
            <c>cConnections</c> member for the audio destination line given in the <c>dwDestination</c> member.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.dwLineID">
            <summary>
            An identifier defined by the mixer device that uniquely refers to the audio line described by the <c>MIXERLINE</c>
            structure. This identifier is unique for each mixer device and can be in any format. An application should use this
            identifier only as an abstract handle.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.fdwLine">
            <summary>
            <para>Status and support flags for the audio line. This member is always returned to the application and requires no initialization.</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIXERLINE_LINEF_ACTIVE</term>
            <term>Audio line is active. An active line indicates that a signal is probably passing through the line.</term>
            </item>
            <item>
            <term>MIXERLINE_LINEF_DISCONNECTED</term>
            <term>
            Audio line is disconnected. A disconnected line's associated controls can still be modified, but the changes have no effect
            until the line is connected.
            </term>
            </item>
            <item>
            <term>MIXERLINE_LINEF_SOURCE</term>
            <term>
            Audio line is an audio source line associated with a single audio destination line. If this flag is not set, this line is an
            audio destination line associated with zero or more audio source lines.
            </term>
            </item>
            </list>
            <para>
            If an application is not using a waveform-audio output device, the audio line associated with that device would not be
            active (that is, the MIXERLINE_LINEF_ACTIVE flag would not be set).
            </para>
            <para>
            If the waveform-audio output device is opened, then the audio line is considered active and the MIXERLINE_LINEF_ACTIVE flag
            will be set.
            </para>
            <para>
            A paused or starved waveform-audio output device is still considered active. In other words, if the waveform-audio output
            device is opened by an application regardless of whether data is being played, the associated audio line is considered active.
            </para>
            <para>If a line cannot be strictly defined as active, the mixer device will always set the MIXERLINE_LINEF_ACTIVE flag.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.dwUser">
            <summary>
            Instance data defined by the audio device for the line. This member is intended for custom mixer applications designed
            specifically for the mixer device returning this information. Other applications should ignore this data.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.dwComponentType">
            <summary>
            <para>
            Component type for this audio line. An application can use this information to display tailored graphics or to search for a
            particular component. If an application does not use component types, this member should be ignored. This member can be one
            of the following values:
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_DST_DIGITAL</term>
            <term>Audio line is a digital destination (for example, digital input to a DAT or CD audio device).</term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_DST_HEADPHONES</term>
            <term>
            Audio line is an adjustable (gain and/or attenuation) destination intended to drive headphones. Most audio cards use the
            same audio destination line for speakers and headphones, in which case the mixer device simply uses the
            MIXERLINE_COMPONENTTYPE_DST_SPEAKERS type.
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_DST_LINE</term>
            <term>
            Audio line is a line level destination (for example, line level input from a CD audio device) that will be the final
            recording source for the analog-to-digital converter (ADC). Because most audio cards for personal computers provide some
            sort of gain for the recording audio source line, the mixer device will use the MIXERLINE_COMPONENTTYPE_DST_WAVEIN type.
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_DST_MONITOR</term>
            <term>Audio line is a destination used for a monitor.</term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_DST_SPEAKERS</term>
            <term>
            Audio line is an adjustable (gain and/or attenuation) destination intended to drive speakers. This is the typical component
            type for the audio output of audio cards for personal computers.
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_DST_TELEPHONE</term>
            <term>Audio line is a destination that will be routed to a telephone line.</term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_DST_UNDEFINED</term>
            <term>
            Audio line is a destination that cannot be defined by one of the standard component types. A mixer device is required to use
            this component type for line component types that have not been defined by Microsoft Corporation.
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_DST_VOICEIN</term>
            <term>
            Audio line is a destination that will be the final recording source for voice input. This component type is exactly like
            MIXERLINE_COMPONENTTYPE_DST_WAVEIN but is intended specifically for settings used during voice recording/recognition.
            Support for this line is optional for a mixer device. Many mixer devices provide only MIXERLINE_COMPONENTTYPE_DST_WAVEIN.
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_DST_WAVEIN</term>
            <term>
            Audio line is a destination that will be the final recording source for the waveform-audio input (ADC). This line typically
            provides some sort of gain or attenuation. This is the typical component type for the recording line of most audio cards for
            personal computers.
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_SRC_ANALOG</term>
            <term>Audio line is an analog source (for example, analog output from a video-cassette tape).</term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY</term>
            <term>
            Audio line is a source originating from the auxiliary audio line. This line type is intended as a source with gain or
            attenuation that can be routed to the MIXERLINE_COMPONENTTYPE_DST_SPEAKERS destination and/or recorded from the
            MIXERLINE_COMPONENTTYPE_DST_WAVEIN destination.
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC</term>
            <term>
            Audio line is a source originating from the output of an internal audio CD. This component type is provided for audio cards
            that provide an audio source line intended to be connected to an audio CD (or CD-ROM playing an audio CD).
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_SRC_DIGITAL</term>
            <term>Audio line is a digital source (for example, digital output from a DAT or audio CD).</term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_SRC_LINE</term>
            <term>
            Audio line is a line-level source (for example, line-level input from an external stereo) that can be used as an optional
            recording source. Because most audio cards for personal computers provide some sort of gain for the recording source line,
            the mixer device will use the MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY type.
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE</term>
            <term>
            Audio line is a microphone recording source. Most audio cards for personal computers provide at least two types of recording
            sources: an auxiliary audio line and microphone input. A microphone audio line typically provides some sort of gain. Audio
            cards that use a single input for use with a microphone or auxiliary audio line should use the
            MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE component type.
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER</term>
            <term>
            Audio line is a source originating from personal computer speaker. Several audio cards for personal computers provide the
            ability to mix what would typically be played on the internal speaker with the output of an audio card. Some audio cards
            support the ability to use this output as a recording source.
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER</term>
            <term>
            Audio line is a source originating from the output of an internal synthesizer. Most audio cards for personal computers
            provide some sort of MIDI synthesizer.
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE</term>
            <term>Audio line is a source originating from an incoming telephone line.</term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED</term>
            <term>
            Audio line is a source that cannot be defined by one of the standard component types. A mixer device is required to use this
            component type for line component types that have not been defined by Microsoft Corporation.
            </term>
            </item>
            <item>
            <term>MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT</term>
            <term>
            Audio line is a source originating from the waveform-audio output digital-to-analog converter (DAC). Most audio cards for
            personal computers provide this component type as a source to the MIXERLINE_COMPONENTTYPE_DST_SPEAKERS destination. Some
            cards also allow this source to be routed to the MIXERLINE_COMPONENTTYPE_DST_WAVEIN destination.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.cChannels">
            <summary>
            <para>
            Maximum number of separate channels that can be manipulated independently for the audio line. The minimum value for this
            field is 1 because a line must have at least one channel.
            </para>
            <para>Most modern audio cards for personal computers are stereo devices; for them, the value of this member is 2.</para>
            <para>Channel 1 is assumed to be the left channel; channel 2 is assumed to be the right channel.</para>
            <para>
            A multichannel line might have one or more uniform controls (controls that affect all channels of a line uniformly)
            associated with it.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.cConnections">
            <summary>
            Number of connections that are associated with the audio line. This member is used only for audio destination lines and
            specifies the number of audio source lines that are associated with it. This member is always zero for source lines and for
            destination lines that do not have any audio source lines associated with them.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.cControls">
            <summary>
            Number of controls associated with the audio line. This value can be zero. If no controls are associated with the line, the
            line is likely to be a source that might be selected in a MIXERCONTROL_CONTROLTYPE_MUX or MIXERCONTROL_CONTROLTYPE_MIXER but
            allows no manipulation of the signal.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.szShortName">
            <summary>
            Short string that describes the audio mixer line specified in the <c>dwLineID</c> member. This description should be
            appropriate as a concise label for the line.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.szName">
            <summary>
            String that describes the audio mixer line specified in the <c>dwLineID</c> member. This description should be appropriate
            as a complete description for the line.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.Target">
            <summary>Target media information.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERLINE.TARGET">
            <summary>Target media information.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.TARGET.dwType">
            <summary>
            <para>
            Target media device type associated with the audio line described in the <c>MIXERLINE</c> structure. An application must
            ignore target information for media device types it does not use. The following values are defined:
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MIXERLINE_TARGETTYPE_AUX</term>
            <term>
            The audio line described by the MIXERLINE structure is strictly bound to the auxiliary device detailed in the remaining
            members of the Target structure member of the MIXERLINE structure.
            </term>
            </item>
            <item>
            <term>MIXERLINE_TARGETTYPE_MIDIIN</term>
            <term>
            The audio line described by the MIXERLINE structure is strictly bound to the MIDI input device detailed in the remaining
            members of the Target structure member of the MIXERLINE structure.
            </term>
            </item>
            <item>
            <term>MIXERLINE_TARGETTYPE_MIDIOUT</term>
            <term>
            The audio line described by the MIXERLINE structure is strictly bound to the MIDI output device detailed in the
            remaining members of the Target structure member of the MIXERLINE structure.
            </term>
            </item>
            <item>
            <term>MIXERLINE_TARGETTYPE_UNDEFINED</term>
            <term>
            The audio line described by the MIXERLINE structure is not strictly bound to a defined media type. All remaining Target
            structure members of the MIXERLINE structure should be ignored. An application cannot use the
            MIXERLINE_TARGETTYPE_UNDEFINED target type when calling the mixerGetLineInfo function with the
            MIXER_GETLINEINFOF_TARGETTYPE flag.
            </term>
            </item>
            <item>
            <term>MIXERLINE_TARGETTYPE_WAVEIN</term>
            <term>
            The audio line described by the MIXERLINE structure is strictly bound to the waveform-audio input device detailed in the
            remaining members of the Target structure member of the MIXERLINE structure.
            </term>
            </item>
            <item>
            <term>MIXERLINE_TARGETTYPE_WAVEOUT</term>
            <term>
            The audio line described by the MIXERLINE structure is strictly bound to the waveform-audio output device detailed in
            the remaining members of the Target structure member of the MIXERLINE structure.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.TARGET.dwDeviceID">
            <summary>
            Current device identifier of the target media device when the <c>dwType</c> member is a target type other than
            MIXERLINE_TARGETTYPE_UNDEFINED. This identifier is identical to the current media device index of the associated media
            device. When calling the mixerGetLineInfo function with the MIXER_GETLINEINFOF_TARGETTYPE flag, this member is ignored
            on input and will be returned to the caller by the audio mixer manager.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.TARGET.wMid">
            <summary>
            Manufacturer identifier of the target media device when the <c>dwType</c> member is a target type other than
            MIXERLINE_TARGETTYPE_UNDEFINED. This identifier is identical to the <c>wMid</c> member of the device-capabilities
            structure for the associated media. Manufacturer identifiers are defined in Manufacturer and Product Identifiers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.TARGET.wPid">
            <summary>
            Product identifier of the target media device when the <c>dwType</c> member is a target type other than
            MIXERLINE_TARGETTYPE_UNDEFINED. This identifier is identical to the <c>wPid</c> member of the device-capabilities
            structure for the associated media. Product identifiers are defined in Manufacturer and Product Identifiers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.TARGET.vDriverVersion">
            <summary>
            Driver version of the target media device when the <c>dwType</c> member is a target type other than
            MIXERLINE_TARGETTYPE_UNDEFINED. This version is identical to the <c>vDriverVersion</c> member of the device-capabilities
            structure for the associated media.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINE.TARGET.szPname">
            <summary>
            Product name of the target media device when the <c>dwType</c> member is a target type other than
            MIXERLINE_TARGETTYPE_UNDEFINED. This name is identical to the <c>szPname</c> member of the device-capabilities structure
            for the associated media.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MIXERLINECONTROLS">
            <summary>The <c>MIXERLINECONTROLS</c> structure contains information about the controls of an audio line.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINECONTROLS.cbStruct">
            <summary>
            Size, in bytes, of the <c>MIXERLINECONTROLS</c> structure. This member must be initialized before calling the
            mixerGetLineControls function. The size specified in this member must be large enough to contain the
            <c>MIXERLINECONTROLS</c> structure. When <c>mixerGetLineControls</c> returns, this member contains the actual size of the
            information returned. The returned information will not exceed the requested size, nor will it be smaller than the
            <c>MIXERLINECONTROLS</c> structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINECONTROLS.dwLineID">
            <summary>
            Line identifier for which controls are being queried. This member is not used if the MIXER_GETLINECONTROLSF_ONEBYID flag is
            specified for the mixerGetLineControls function, but the mixer device still returns this member in this case. The
            <c>dwControlID</c> and <c>dwControlType</c> members are not used when MIXER_GETLINECONTROLSF_ALL is specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINECONTROLS.dwControlID">
            <summary>
            Control identifier of the desired control. This member is used with the MIXER_GETLINECONTROLSF_ONEBYID flag for the
            mixerGetLineControls function to retrieve the control information of the specified control. Note that the <c>dwLineID</c>
            member of the <c>MIXERLINECONTROLS</c> structure will be returned by the mixer device and is not required as an input
            parameter. This member overlaps with the <c>dwControlType</c> member and cannot be used in conjunction with the
            MIXER_GETLINECONTROLSF_ONEBYTYPE query type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINECONTROLS.dwControlType">
            <summary>
            Class of the desired Control Types. This member is used with the MIXER_GETLINECONTROLSF_ONEBYTYPE flag for the
            mixerGetLineControls function to retrieve the first control of the specified class on the line specified by the
            <c>dwLineID</c> member of the <c>MIXERLINECONTROLS</c> structure. This member overlaps with the <c>dwControlID</c> member
            and cannot be used in conjunction with the MIXER_GETLINECONTROLSF_ONEBYID query type. See dwControlType member description
            in MIXERCONTROL.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINECONTROLS.cControls">
            <summary>
            Number of MIXERCONTROL structure elements to retrieve. This member must be initialized by the application before calling the
            mixerGetLineControls function. This member can be 1 only if MIXER_GETLINECONTROLSF_ONEBYID or
            MIXER_GETLINECONTROLSF_ONEBYTYPE is specified or the value returned in the <c>cControls</c> member of the MIXERLINE
            structure returned for an audio line. This member cannot be zero. If an audio line specifies that it has no controls,
            <c>mixerGetLineControls</c> should not be called.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINECONTROLS.cbmxctrl">
            <summary>
            Size, in bytes, of a single MIXERCONTROL structure. The size specified in this member must be at least large enough to
            contain the base <c>MIXERCONTROL</c> structure. The total size, in bytes, required for the buffer pointed to by the
            <c>pamxctrl</c> member is the product of the <c>cbmxctrl</c> and <c>cControls</c> members of the <c>MIXERLINECONTROLS</c> structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MIXERLINECONTROLS.pamxctrl">
            <summary>
            Pointer to one or more MIXERCONTROL structures to receive the properties of the requested audio line controls. This member
            cannot be <c>NULL</c> and must be initialized before calling the mixerGetLineControls function. Each element of the array of
            controls must be at least large enough to contain a base <c>MIXERCONTROL</c> structure. The <c>cbmxctrl</c> member must
            specify the size, in bytes, of each element in this array. No initialization of the buffer pointed to by this member is
            required by the application. All members are filled in by the mixer device (including the <c>cbStruct</c> member of each
            <c>MIXERCONTROL</c> structure) upon returning successfully.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.WAVE_OPEN">
            <summary>Flags for opening the device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_OPEN.WAVE_FORMAT_QUERY">
            <term>The function queries the device to determine whether it supports the given format, but it does not open the device.</term>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_OPEN.WAVE_ALLOWSYNC">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_OPEN.WAVE_MAPPED">
            <term>The uDeviceID parameter specifies a waveform-audio device to be mapped to by the wave mapper.</term>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_OPEN.WAVE_FORMAT_DIRECT">
            <term>If this flag is specified, the ACM driver does not perform conversions on the audio data.</term>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_OPEN.WAVE_FORMAT_DIRECT_QUERY">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_OPEN.WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE">
            <term>
            If this flag is specified and the uDeviceID parameter is WAVE_MAPPER, the function opens the default communication device.
            This flag applies only when uDeviceID equals WAVE_MAPPER.
            </term>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_OPEN.CALLBACK_NULL">
            <summary>No callback mechanism. This is the default setting.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_OPEN.CALLBACK_WINDOW">
            <summary>The dwCallback parameter is a window handle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_OPEN.CALLBACK_TASK">
            <summary>The dwCallback parameter is a task handle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_OPEN.CALLBACK_FUNCTION">
            <summary>The dwCallback parameter is a callback procedure address. See <see cref="T:Vanara.PInvoke.WinMm.DRVCALLBACK"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_OPEN.CALLBACK_THREAD">
            <summary>The dwCallback parameter is a thread identifier.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_OPEN.CALLBACK_EVENT">
            <summary>The dwCallback parameter is an event handle.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.WAVECAPS">
            <summary>Optional functionality supported by the device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVECAPS.WAVECAPS_PITCH">
            <summary>Supports pitch control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVECAPS.WAVECAPS_PLAYBACKRATE">
            <summary>Supports playback rate control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVECAPS.WAVECAPS_VOLUME">
            <summary>Supports volume control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVECAPS.WAVECAPS_LRVOLUME">
            <summary>Supports separate left and right volume control.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVECAPS.WAVECAPS_SYNC">
            <summary>The driver is synchronous and will block while playing a buffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVECAPS.WAVECAPS_SAMPLEACCURATE">
            <summary>Returns sample-accurate position information.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.WHDR">
            <summary>Flags for WAVEHDR.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WHDR.WHDR_DONE">
            <summary>Set by the device driver to indicate that it is finished with the buffer and is returning it to the application.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WHDR.WHDR_PREPARED">
            <summary>
            Set by Windows to indicate that the buffer has been prepared with the waveInPrepareHeader or waveOutPrepareHeader function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WHDR.WHDR_BEGINLOOP">
            <summary>This buffer is the first buffer in a loop. This flag is used only with output buffers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WHDR.WHDR_ENDLOOP">
            <summary>This buffer is the last buffer in a loop. This flag is used only with output buffers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WHDR.WHDR_INQUEUE">
            <summary>Set by Windows to indicate that the buffer is queued for playback.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInAddBuffer(Vanara.PInvoke.WinMm.HWAVEIN,Vanara.PInvoke.WinMm.WAVEHDR@,System.UInt32)">
            <summary>
            The <c>waveInAddBuffer</c> function sends an input buffer to the given waveform-audio input device. When the buffer is filled,
            the application is notified.
            </summary>
            <param name="hwi">Handle to the waveform-audio input device.</param>
            <param name="pwh">Pointer to a WAVEHDR structure that identifies the buffer.</param>
            <param name="cbwh">Size, in bytes, of the <c>WAVEHDR</c> structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>WAVERR_UNPREPARED</term>
            <term>The buffer pointed to by the pwh parameter hasn't been prepared.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>When the buffer is filled, the WHDR_DONE bit is set in the <c>dwFlags</c> member of the <c>WAVEHDR</c> structure.</para>
            <para>The buffer must be prepared with the <c>waveInPrepareHeader</c> function before it is passed to this function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInClose(Vanara.PInvoke.WinMm.HWAVEIN)">
            <summary>The <c>waveInClose</c> function closes the given waveform-audio input device.</summary>
            <param name="hwi">
            Handle to the waveform-audio input device. If the function succeeds, the handle is no longer valid after this call.
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>WAVERR_STILLPLAYING</term>
            <term>There are still buffers in the queue.</term>
            </item>
            </list>
            </returns>
            <remarks>
            If there are input buffers that have been sent with the <c>waveInAddBuffer</c> function and that haven't been returned to the
            application, the close operation will fail. Call the <c>waveInReset</c> function to mark all pending buffers as done.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInGetDevCaps(System.UInt32,Vanara.PInvoke.WinMm.WAVEINCAPS@,System.UInt32)">
            <summary>The <c>waveInGetDevCaps</c> function retrieves the capabilities of a given waveform-audio input device.</summary>
            <param name="uDeviceID">
            Identifier of the waveform-audio output device. It can be either a device identifier or a handle of an open waveform-audio input device.
            </param>
            <param name="pwic">Pointer to a WAVEINCAPS structure to be filled with information about the capabilities of the device.</param>
            <param name="cbwic">Size, in bytes, of the <c>WAVEINCAPS</c> structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>Specified device identifier is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Use this function to determine the number of waveform-audio input devices present in the system. If the value specified by the
            uDeviceID parameter is a device identifier, it can vary from zero to one less than the number of devices present. The
            WAVE_MAPPER constant can also be used as a device identifier. Only cbwic bytes (or less) of information is copied to the
            location pointed to by pwic. If cbwic is zero, nothing is copied and the function returns zero.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInGetErrorText(Vanara.PInvoke.WinMm.MMRESULT,System.Text.StringBuilder,System.UInt32)">
            <summary>
            The <c>waveInGetErrorText</c> function retrieves a textual description of the error identified by the given error number.
            </summary>
            <param name="mmrError">Error number.</param>
            <param name="pszText">Pointer to the buffer to be filled with the textual error description.</param>
            <param name="cchText">Size, in characters, of the buffer pointed to by pszText.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADERRNUM</term>
            <term>Specified error number is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            If the textual error description is longer than the specified buffer, the description is truncated. The returned error string is
            always null-terminated. If cchText is zero, nothing is copied and the function returns zero. All error descriptions are less
            than MAXERRORLENGTH characters long.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInGetID(Vanara.PInvoke.WinMm.HWAVEIN,System.UInt32@)">
            <summary>
            <para>The <c>waveInGetID</c> function gets the device identifier for the given waveform-audio input device.</para>
            <para>
            This function is supported for backward compatibility. New applications can cast a handle of the device rather than retrieving
            the device identifier.
            </para>
            </summary>
            <param name="hwi">Handle to the waveform-audio input device.</param>
            <param name="puDeviceID">Pointer to a variable to be filled with the device identifier.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The hwi parameter specifies an invalid handle.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInGetNumDevs">
            <summary>The <c>waveInGetNumDevs</c> function returns the number of waveform-audio input devices present in the system.</summary>
            <returns>Returns the number of devices. A return value of zero means that no devices are present or that an error occurred.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInGetPosition(Vanara.PInvoke.WinMm.HWAVEIN,Vanara.PInvoke.WinMm.MMTIME@,System.UInt32)">
            <summary>
            <para>[ <c>waveInGetPosition</c> is no longer supported for use as of Windows Vista. Instead, use IAudioClock::GetPosition.]</para>
            <para>The <c>waveInGetPosition</c> function retrieves the current input position of the given waveform-audio input device.</para>
            </summary>
            <param name="hwi">Handle to the waveform-audio input device.</param>
            <param name="pmmt">Pointer to an MMTIME structure.</param>
            <param name="cbmmt">Size, in bytes, of the MMTIME structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Before calling this function, set the <c>wType</c> member of the MMTIME structure to indicate the time format you want. After
            calling this function, check <c>wType</c> to determine whether the desired time format is supported. If the format is not
            supported, the member will specify an alternative format.
            </para>
            <para>The position is set to zero when the device is opened or reset.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInMessage(Vanara.PInvoke.WinMm.HWAVEIN,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>The <c>waveInMessage</c> function sends messages to the waveform-audio input device drivers.</summary>
            <param name="hwi">
            Identifier of the waveform device that receives the message. You must cast the device ID to the <c>HWAVEIN</c> handle type. If
            you supply a handle instead of a device ID, the function fails and returns the MMSYSERR_NOSUPPORT error code.
            </param>
            <param name="uMsg">Message to send.</param>
            <param name="dw1">Message parameter.</param>
            <param name="dw2">Message parameter.</param>
            <returns>Returns the value returned from the driver.</returns>
            <remarks>
            <para>The
            <code>DRV_QUERYDEVICEINTERFACE</code>
            message queries for the device-interface name of a <c>waveIn</c>, <c>waveOut</c>, <c>midiIn</c>, <c>midiOut</c>, or <c>mixer</c> device.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACE</code>
            , dwParam1 is a pointer to a caller-allocated buffer into which the function writes a null-terminated Unicode string containing
            the device-interface name. If the device has no device interface, the string length is zero.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACE</code>
            , dwParam2 specifies the buffer size in bytes. This is an input parameter to the function. The caller should specify a size that
            is greater than or equal to the buffer size retrieved by the DRV_QUERYDEVICEINTERFACESIZE message.
            </para>
            <para>
            The DRV_QUERYDEVICEINTERFACE message is supported in Windows Me, and Windows 2000 and later. This message is valid only for the
            <c>waveInMessage</c>, waveOutMessage, midiInMessage, midiOutMessage, and mixerMessage functions. The system intercepts this
            message and returns the appropriate value without sending the message to the device driver. For general information about
            system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>The following two message constants are used together for the purpose of obtaining device interface names:</para>
            <list type="bullet">
            <item>
            <term>DRV_QUERYDEVICEINTERFACESIZE</term>
            </item>
            <item>
            <term>DRV_QUERYDEVICEINTERFACE</term>
            </item>
            </list>
            <para>
            The first message obtains the size in bytes of the buffer needed to hold the string containing the device interface name. The
            second message retrieves the name string in a buffer of the required size.
            </para>
            <para>For more information, see Obtaining a Device Interface Name.</para>
            <para>The
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            message queries for the size of the buffer required to hold the device-interface name.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            , dwParam1 is a pointer to buffer size. This parameter points to a ULONG variable into which the function writes the required
            buffer size in bytes. The size includes storage space for the name string's terminating null. The size is zero if the device ID
            identifies a device that has no device interface.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            This message is valid only for the <c>waveInMessage</c>, waveOutMessage, midiInMessage, midiOutMessage, and mixerMessage
            functions. The system intercepts this message and returns the appropriate value without sending the message to the device
            driver. For general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            The buffer size retrieved by this message is expressed as a byte count. It specifies the size of the buffer needed to hold the
            null-terminated Unicode string that contains the device-interface name. The caller allocates a buffer of the specified size and
            uses the DRV_QUERYDEVICEINTERFACE message to retrieve the device-interface name string.
            </para>
            <para>For more information, see Obtaining a Device Interface Name.</para>
            <para>The
            <code>DRV_QUERYDEVNODE</code>
            message queries for the devnode number assigned to the device by the Plug and Play manager.
            </para>
            <para>For
            <code>DRV_QUERYDEVNODE</code>
            , dwParam1 is a pointer to a caller-allocated DWORD variable into which the function writes the devnode number. If no devnode is
            assigned to the device, the function sets this variable to zero.
            </para>
            <para>For
            <code>DRV_QUERYDEVNODE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            In Windows 2000 and later, the message always returns MMSYSERR_NOTSUPPORTED. This message is valid only for the
            <c>waveInMessage</c>, waveOutMessage, midiInMessage, midiOutMessage, and mixerMessage functions. The system intercepts this
            message and returns the appropriate value without sending the message to the device driver. For general information about
            system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>The
            <code>DRV_QUERYMAPPABLE</code>
            message queries for whether the specified device can be used by a mapper.
            </para>
            <para>For
            <code>DRV_QUERYMAPPABLE</code>
            , dwParam1 is unused. Set this parameter to zero.
            </para>
            <para>For
            <code>DRV_QUERYMAPPABLE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            This message is valid only for the <c>waveInMessage</c>, waveOutMessage, midiInMessage, midiOutMessage, mixerMessage and
            auxOutMessage functions. The system intercepts this message and returns the appropriate value without sending the message to the
            device driver. For general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            When an application program opens a mapper instead of a specific audio device, the system inserts a mapper between the
            application and the available devices. The mapper selects an appropriate device by mapping the application's requirements to one
            of the available devices. For more information about mappers, see the Microsoft Windows SDK documentation.
            </para>
            <para>The
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            message retrieves the device ID of the preferred voice-communications device.
            </para>
            <para>For
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            , dwParam1 is a pointer to device ID. This parameter points to a DWORD variable into which the function writes the device ID of
            the current preferred voice-communications device. The function writes the value (-1) if no device is available that qualifies
            as a preferred voice-communications device.
            </para>
            <para>For
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            , dwParam2 is a pointer to status flags. This parameter points to a DWORD variable into which the function writes the
            device-status flags. Only one flag bit is currently defined: DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY.
            </para>
            <para>
            This message is valid only for the <c>waveInMessage</c> and waveOutMessage functions. When a caller calls these two functions
            with the DRVM_MAPPER_CONSOLEVOICECOM_GET message, the caller must specify the device ID as WAVE_MAPPER, and then cast this value
            to the appropriate handle type. For the <c>waveInMessage</c>, <c>waveOutMessage</c>, midiInMessage, midiOutMessage, or
            mixerMessage functions, the caller must cast the device ID to a handle of type HWAVEIN, HWAVEOUT, HMIDIIN, HMIDIOUT, or HMIXER,
            respectively. Note that if the caller supplies a valid handle instead of a device ID for this parameter, the function fails and
            returns error code MMSYSERR_NOSUPPORT.
            </para>
            <para>
            The system intercepts this message and returns the appropriate value without sending the message to the device driver. For
            general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            This message provides a way to determine which device is preferred specifically for voice communications, in contrast to the
            DRVM_MAPPER_PREFERRED_GET message, which determines which device is preferred for all other audio functions.
            </para>
            <para>
            For example, the preferred <c>waveOut</c> device for voice communications might be the earpiece in a headset, but the preferred
            <c>waveOut</c> device for all other audio functions might be a set of stereo speakers.
            </para>
            <para>
            When the DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY flag bit is set in the DWORD location pointed to by dwParam2, the
            <c>waveIn</c> and <c>waveOut</c> APIs use only the current preferred voice-communications device and do not search for other
            available devices if the preferred device is unavailable. The flag that is output by either the <c>waveInMessage</c> or
            <c>waveOutMessage</c> call applies to the preferred voice-communications device for both the <c>waveIn</c> and <c>waveOut</c>
            APIs, regardless of whether the call is made to <c>waveInMessage</c> or <c>waveOutMessage</c>. For more information, see
            Preferred Voice-Communications Device ID.
            </para>
            <para>The
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            message retrieves the device ID of the preferred audio device.
            </para>
            <para>For
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            , dwParam1 is a pointer to device ID. This parameter points to a DWORD variable into which the function writes the device ID of
            the current preferred device. The function writes the value (-1) if no device is available that qualifies as a preferred device.
            </para>
            <para>For
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            , dwParam2 is a pointer to status flags. This parameter points to a DWORD variable into which the function writes the
            device-status flags. Only one flag bit is currently defined (for <c>waveInMessage</c> and <c>waveOutMessage</c> calls only): DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY.
            </para>
            <para>
            This message is valid only for the <c>waveInMessage</c>, waveOutMessage and midiOutMessage functions. When the caller calls
            these functions with the DRVM_MAPPER_PREFERRED_GET message, the caller must first specify the device ID as WAVE_MAPPER (for
            <c>waveInMessage</c> or <c>waveOutMessage</c>) or MIDI_MAPPER (for <c>midiOutMessage</c>), and then cast this value to the
            appropriate handle type. For the <c>waveInMessage</c>, <c>waveOutMessage</c>, or <c>midiOutMessage</c> functions, the caller
            must cast the device ID to a handle type HWAVEIN, HWAVEOUT or HMIDIOUT, respectively. Note that if the caller supplies a valid
            handle instead of a device ID for this parameter, the function fails and returns error code MMSYSERR_NOSUPPORT.
            </para>
            <para>
            The system intercepts this message and returns the appropriate value without sending the message to the device driver. For
            general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            This message provides a way to determine which device is preferred for audio functions in general, in contrast to the
            DRVM_MAPPER_CONSOLEVOICECOM_GET message, which determines which device is preferred specifically for voice communications.
            </para>
            <para>
            When the DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY flag bit is set in the DWORD location pointed to by dwParam2, the
            <c>waveIn</c> and <c>waveOut</c> APIs use only the current preferred device and do not search for other available devices if the
            preferred device is unavailable. Note that the <c>midiOutMessage</c> function does not output this flag--the <c>midiOut</c> API
            always uses only the preferred device. The flag that is output by either the <c>waveInMessage</c> or <c>waveOutMessage</c> call
            applies to the preferred device for both the <c>waveIn</c> and <c>waveOut</c> APIs, regardless of whether the call is made to
            <c>waveInMessage</c> or <c>waveOutMessage</c>.
            </para>
            <para>
            The xxxMessage functions accept this value in place of a valid device handle in order to allow an application to determine the
            default device ID without first having to open a device. For more information, see Accessing the Preferred Device ID.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInOpen(Vanara.PInvoke.WinMm.SafeHWAVEIN@,System.UInt32,Vanara.PInvoke.WinMm.WAVEFORMATEX@,System.IntPtr,System.IntPtr,Vanara.PInvoke.WinMm.WAVE_OPEN)">
            <summary>The <c>waveInOpen</c> function opens the given waveform-audio input device for recording.</summary>
            <param name="phwi">
            Pointer to a buffer that receives a handle identifying the open waveform-audio input device. Use this handle to identify the
            device when calling other waveform-audio input functions. This parameter can be <c>NULL</c> if <c>WAVE_FORMAT_QUERY</c> is
            specified for fdwOpen.
            </param>
            <param name="uDeviceID">
            <para>
            Identifier of the waveform-audio input device to open. It can be either a device identifier or a handle of an open
            waveform-audio input device. You can use the following flag instead of a device identifier.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WAVE_MAPPER</term>
            <term>The function selects a waveform-audio input device capable of recording in the specified format.</term>
            </item>
            </list>
            </param>
            <param name="pwfx">
            Pointer to a WAVEFORMATEX structure that identifies the desired format for recording waveform-audio data. You can free this
            structure immediately after <c>waveInOpen</c> returns.
            </param>
            <param name="dwCallback">
            Pointer to a fixed callback function, an event handle, a handle to a window, or the identifier of a thread to be called during
            waveform-audio recording to process messages related to the progress of recording. If no callback function is required, this
            value can be zero. For more information on the callback function, see waveInProc.
            </param>
            <param name="dwInstance">
            User-instance data passed to the callback mechanism. This parameter is not used with the window callback mechanism.
            </param>
            <param name="fdwOpen">
            <para>Flags for opening the device. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>CALLBACK_EVENT</term>
            <term>The dwCallback parameter is an event handle.</term>
            </item>
            <item>
            <term>CALLBACK_FUNCTION</term>
            <term>The dwCallback parameter is a callback procedure address.</term>
            </item>
            <item>
            <term>CALLBACK_NULL</term>
            <term>No callback mechanism. This is the default setting.</term>
            </item>
            <item>
            <term>CALLBACK_THREAD</term>
            <term>The dwCallback parameter is a thread identifier.</term>
            </item>
            <item>
            <term>CALLBACK_WINDOW</term>
            <term>The dwCallback parameter is a window handle.</term>
            </item>
            <item>
            <term>WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE</term>
            <term>
            If this flag is specified and the uDeviceID parameter is WAVE_MAPPER, the function opens the default communication device. This
            flag applies only when uDeviceID equals WAVE_MAPPER.
            </term>
            </item>
            <item>
            <term>WAVE_FORMAT_DIRECT</term>
            <term>If this flag is specified, the ACM driver does not perform conversions on the audio data.</term>
            </item>
            <item>
            <term>WAVE_FORMAT_QUERY</term>
            <term>The function queries the device to determine whether it supports the given format, but it does not open the device.</term>
            </item>
            <item>
            <term>WAVE_MAPPED</term>
            <term>The uDeviceID parameter specifies a waveform-audio device to be mapped to by the wave mapper.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns <c>MMSYSERR_NOERROR</c> if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_ALLOCATED</term>
            <term>Specified resource is already allocated.</term>
            </item>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>Specified device identifier is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>WAVERR_BADFORMAT</term>
            <term>Attempted to open with an unsupported waveform-audio format.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Use the waveInGetNumDevs function to determine the number of waveform-audio input devices present on the system. The device
            identifier specified by uDeviceID varies from zero to one less than the number of devices present. The WAVE_MAPPER constant can
            also be used as a device identifier.
            </para>
            <para>
            If you choose to have a window or thread receive callback information, the following messages are sent to the window procedure
            or thread to indicate the progress of waveform-audio input: MM_WIM_OPEN, MM_WIM_CLOSE, and MM_WIM_DATA.
            </para>
            <para>
            If you choose to have a function receive callback information, the following messages are sent to the function to indicate the
            progress of waveform-audio input: WIM_OPEN, WIM_CLOSE, and WIM_DATA.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInPrepareHeader(Vanara.PInvoke.WinMm.HWAVEIN,Vanara.PInvoke.WinMm.WAVEHDR@,System.UInt32)">
            <summary>The <c>waveInPrepareHeader</c> function prepares a buffer for waveform-audio input.</summary>
            <param name="hwi">Handle to the waveform-audio input device.</param>
            <param name="pwh">Pointer to a WAVEHDR structure that identifies the buffer to be prepared.</param>
            <param name="cbwh">Size, in bytes, of the <c>WAVEHDR</c> structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The <c>lpData</c>, <c>dwBufferLength</c>, and <c>dwFlags</c> members of the <c>WAVEHDR</c> structure must be set before calling
            this function ( <c>dwFlags</c> must be zero).
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInReset(Vanara.PInvoke.WinMm.HWAVEIN)">
            <summary>
            The <c>waveInReset</c> function stops input on the given waveform-audio input device and resets the current position to zero.
            All pending buffers are marked as done and returned to the application.
            </summary>
            <param name="hwi">Handle to the waveform-audio input device.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInStart(Vanara.PInvoke.WinMm.HWAVEIN)">
            <summary>The <c>waveInStart</c> function starts input on the given waveform-audio input device.</summary>
            <param name="hwi">Handle to the waveform-audio input device.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Buffers are returned to the application when full or when the <c>waveInReset</c> function is called (the <c>dwBytesRecorded</c>
            member in the header will contain the length of data). If there are no buffers in the queue, the data is thrown away without
            notifying the application, and input continues.
            </para>
            <para>Calling this function when input is already started has no effect, and the function returns zero.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInStop(Vanara.PInvoke.WinMm.HWAVEIN)">
            <summary>The <c>waveInStop</c> function stops waveform-audio input.</summary>
            <param name="hwi">Handle to the waveform-audio input device.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If there are any buffers in the queue, the current buffer will be marked as done (the <c>dwBytesRecorded</c> member in the
            header will contain the length of data), but any empty buffers in the queue will remain there.
            </para>
            <para>Calling this function when input is not started has no effect, and the function returns zero.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveInUnprepareHeader(Vanara.PInvoke.WinMm.HWAVEIN,Vanara.PInvoke.WinMm.WAVEHDR@,System.UInt32)">
            <summary>
            The <c>waveInUnprepareHeader</c> function cleans up the preparation performed by the waveInPrepareHeader function. This function
            must be called after the device driver fills a buffer and returns it to the application. You must call this function before
            freeing the buffer.
            </summary>
            <param name="hwi">Handle to the waveform-audio input device.</param>
            <param name="pwh">Pointer to a WAVEHDR structure identifying the buffer to be cleaned up.</param>
            <param name="cbwh">Size, in bytes, of the <c>WAVEHDR</c> structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>WAVERR_STILLPLAYING</term>
            <term>The buffer pointed to by the pwh parameter is still in the queue.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>This function complements the <c>waveInPrepareHeader</c> function.</para>
            <para>
            You must call this function before freeing the buffer. After passing a buffer to the device driver with the
            <c>waveInAddBuffer</c> function, you must wait until the driver is finished with the buffer before calling
            <c>waveInUnprepareHeader</c>. Unpreparing a buffer that has not been prepared has no effect, and the function returns zero.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutBreakLoop(Vanara.PInvoke.WinMm.HWAVEOUT)">
            <summary>
            The <c>waveOutBreakLoop</c> function breaks a loop on the given waveform-audio output device and allows playback to continue
            with the next block in the driver list.
            </summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The blocks making up the loop are played to the end before the loop is terminated.</para>
            <para>Calling this function when nothing is playing or looping has no effect, and the function returns zero.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutClose(Vanara.PInvoke.WinMm.HWAVEOUT)">
            <summary>The <c>waveOutClose</c> function closes the given waveform-audio output device.</summary>
            <param name="hwo">
            Handle to the waveform-audio output device. If the function succeeds, the handle is no longer valid after this call.
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>WAVERR_STILLPLAYING</term>
            <term>There are still buffers in the queue.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The close operation fails if the device is still playing a waveform-audio buffer that was previously sent by calling
            <c>waveOutWrite</c>. Before calling <c>waveOutClose</c>, the application must wait for all buffers to finish playing or call the
            <c>waveOutReset</c> function to terminate playback.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutGetDevCaps(System.UInt32,Vanara.PInvoke.WinMm.WAVEOUTCAPS@,System.UInt32)">
            <summary>The <c>waveOutGetDevCaps</c> function retrieves the capabilities of a given waveform-audio output device.</summary>
            <param name="uDeviceID">
            Identifier of the waveform-audio output device. It can be either a device identifier or a handle of an open waveform-audio
            output device.
            </param>
            <param name="pwoc">Pointer to a WAVEOUTCAPS structure to be filled with information about the capabilities of the device.</param>
            <param name="cbwoc">Size, in bytes, of the <c>WAVEOUTCAPS</c> structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>Specified device identifier is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Use the <c>waveOutGetNumDevs</c> function to determine the number of waveform-audio output devices present in the system. If the
            value specified by the uDeviceID parameter is a device identifier, it can vary from zero to one less than the number of devices
            present. The WAVE_MAPPER constant can also be used as a device identifier. Only cbwoc bytes (or less) of information is copied
            to the location pointed to by pwoc. If cbwoc is zero, nothing is copied and the function returns zero.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutGetErrorText(Vanara.PInvoke.WinMm.MMRESULT,System.Text.StringBuilder,System.UInt32)">
            <summary>
            The <c>waveOutGetErrorText</c> function retrieves a textual description of the error identified by the given error number.
            </summary>
            <param name="mmrError">Error number.</param>
            <param name="pszText">Pointer to a buffer to be filled with the textual error description.</param>
            <param name="cchText">Size, in characters, of the buffer pointed to by pszText.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_BADERRNUM</term>
            <term>Specified error number is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            If the textual error description is longer than the specified buffer, the description is truncated. The returned error string is
            always null-terminated. If cchText is zero, nothing is copied and the function returns zero. All error descriptions are less
            than MAXERRORLENGTH characters long.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutGetID(Vanara.PInvoke.WinMm.HWAVEOUT,System.UInt32@)">
            <summary>
            <para>The <c>waveOutGetID</c> function retrieves the device identifier for the given waveform-audio output device.</para>
            <para>
            This function is supported for backward compatibility. New applications can cast a handle of the device rather than retrieving
            the device identifier.
            </para>
            </summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <param name="puDeviceID">Pointer to a variable to be filled with the device identifier.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The hwo parameter specifies an invalid handle.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutGetNumDevs">
            <summary>The <c>waveOutGetNumDevs</c> function retrieves the number of waveform-audio output devices present in the system.</summary>
            <returns>Returns the number of devices. A return value of zero means that no devices are present or that an error occurred.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutGetPitch(Vanara.PInvoke.WinMm.HWAVEOUT,System.UInt32@)">
            <summary>
            The <c>waveOutGetPitch</c> function retrieves the current pitch setting for the specified waveform-audio output device.
            </summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <param name="pdwPitch">
            <para>
            Pointer to a variable to be filled with the current pitch multiplier setting. The pitch multiplier indicates the current change
            in pitch from the original authored setting. The pitch multiplier must be a positive value.
            </para>
            <para>
            The pitch multiplier is specified as a fixed-point value. The high-order word of the variable contains the signed integer part
            of the number, and the low-order word contains the fractional part. A value of 0x8000 in the low-order word represents one-half,
            and 0x4000 represents one-quarter. For example, the value 0x00010000 specifies a multiplier of 1.0 (no pitch change), and a
            value of 0x000F8000 specifies a multiplier of 15.5.
            </para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>Function isn't supported.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Changing the pitch does not change the playback rate, sample rate, or playback time. Not all devices support pitch changes. To
            determine whether the device supports pitch control, use the WAVECAPS_PITCH flag to test the <c>dwSupport</c> member of the
            <c>WAVEOUTCAPS</c> structure (filled by the <c>waveOutGetDevCaps</c> function).
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutGetPlaybackRate(Vanara.PInvoke.WinMm.HWAVEOUT,System.UInt32@)">
            <summary>
            The <c>waveOutGetPlaybackRate</c> function retrieves the current playback rate for the specified waveform-audio output device.
            </summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <param name="pdwRate">
            <para>
            Pointer to a variable to be filled with the current playback rate. The playback rate setting is a multiplier indicating the
            current change in playback rate from the original authored setting. The playback rate multiplier must be a positive value.
            </para>
            <para>
            The rate is specified as a fixed-point value. The high-order word of the variable contains the signed integer part of the
            number, and the low-order word contains the fractional part. A value of 0x8000 in the low-order word represents one-half, and
            0x4000 represents one-quarter. For example, the value 0x00010000 specifies a multiplier of 1.0 (no playback rate change), and a
            value of 0x000F8000 specifies a multiplier of 15.5.
            </para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>Function isn't supported.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Changing the playback rate does not change the sample rate but does change the playback time. Not all devices support playback
            rate changes. To determine whether a device supports playback rate changes, use the WAVECAPS_PLAYBACKRATE flag to test the
            <c>dwSupport</c> member of the <c>WAVEOUTCAPS</c> structure (filled by the <c>waveOutGetDevCaps</c> function).
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutGetPosition(Vanara.PInvoke.WinMm.HWAVEOUT,Vanara.PInvoke.WinMm.MMTIME@,System.UInt32)">
            <summary>
            The <c>waveOutGetPosition</c> function retrieves the current playback position of the given waveform-audio output device.
            </summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <param name="pmmt">Pointer to an MMTIME structure.</param>
            <param name="cbmmt">Size, in bytes, of the <c>MMTIME</c> structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Before calling this function, set the <c>wType</c> member of the <c>MMTIME</c> structure to indicate the time format you want.
            After calling this function, check <c>wType</c> to determine whether the time format is supported. If the format is not
            supported, <c>wType</c> will specify an alternative format.
            </para>
            <para>The position is set to zero when the device is opened or reset.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutGetVolume(Vanara.PInvoke.WinMm.HWAVEOUT,System.UInt32@)">
            <summary>The <c>waveOutGetVolume</c> function retrieves the current volume level of the specified waveform-audio output device.</summary>
            <param name="hwo">Handle to an open waveform-audio output device. This parameter can also be a device identifier.</param>
            <param name="pdwVolume">
            <para>
            Pointer to a variable to be filled with the current volume setting. The low-order word of this location contains the
            left-channel volume setting, and the high-order word contains the right-channel setting. A value of 0xFFFF represents full
            volume, and a value of 0x0000 is silence.
            </para>
            <para>
            If a device does not support both left and right volume control, the low-order word of the specified location contains the mono
            volume level.
            </para>
            <para>
            The full 16-bit setting(s) set with the waveOutSetVolume function is returned, regardless of whether the device supports the
            full 16 bits of volume-level control.
            </para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>Function isn't supported.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If a device identifier is used, then the result of the <c>waveOutGetVolume</c> call and the information returned in pdwVolume
            applies to all instances of the device. If a device handle is used, then the result and information returned applies only to the
            instance of the device referenced by the device handle.
            </para>
            <para>
            Not all devices support volume changes. To determine whether the device supports volume control, use the WAVECAPS_VOLUME flag to
            test the <c>dwSupport</c> member of the <c>WAVEOUTCAPS</c> structure (filled by the <c>waveOutGetDevCaps</c> function).
            </para>
            <para>
            To determine whether the device supports left- and right-channel volume control, use the WAVECAPS_LRVOLUME flag to test the
            <c>dwSupport</c> member of the <c>WAVEOUTCAPS</c> structure (filled by <c>waveOutGetDevCaps</c>).
            </para>
            <para>
            Volume settings are interpreted logarithmically. This means the perceived increase in volume is the same when increasing the
            volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutMessage(Vanara.PInvoke.WinMm.HWAVEOUT,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>The <c>waveOutMessage</c> function sends messages to the waveform-audio output device drivers.</summary>
            <param name="hwo">
            Identifier of the waveform device that receives the message. You must cast the device ID to the <c>HWAVEOUT</c> handle type. If
            you supply a handle instead of a device ID, the function fails and returns the MMSYSERR_NOSUPPORT error code.
            </param>
            <param name="uMsg">Message to send.</param>
            <param name="dw1">Message parameter.</param>
            <param name="dw2">Message parameter.</param>
            <returns>Returns the value returned from the driver.</returns>
            <remarks>
            <para>The
            <code>DRV_QUERYDEVICEINTERFACE</code>
            message queries for the device-interface name of a <c>waveIn</c>, <c>waveOut</c>, <c>midiIn</c>, <c>midiOut</c>, or <c>mixer</c> device.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACE</code>
            , dwParam1 is a pointer to a caller-allocated buffer into which the function writes a null-terminated Unicode string containing
            the device-interface name. If the device has no device interface, the string length is zero.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACE</code>
            , dwParam2 specifies the buffer size in bytes. This is an input parameter to the function. The caller should specify a size that
            is greater than or equal to the buffer size retrieved by the DRV_QUERYDEVICEINTERFACESIZE message.
            </para>
            <para>
            The DRV_QUERYDEVICEINTERFACE message is supported in Windows Me, and Windows 2000 and later. This message is valid only for the
            waveInMessage, <c>waveOutMessage</c>, midiInMessage, midiOutMessage, and mixerMessage functions. The system intercepts this
            message and returns the appropriate value without sending the message to the device driver. For general information about
            system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>The following two message constants are used together for the purpose of obtaining device interface names:</para>
            <list type="bullet">
            <item>
            <term>DRV_QUERYDEVICEINTERFACESIZE</term>
            </item>
            <item>
            <term>DRV_QUERYDEVICEINTERFACE</term>
            </item>
            </list>
            <para>
            The first message obtains the size in bytes of the buffer needed to hold the string containing the device interface name. The
            second message retrieves the name string in a buffer of the required size.
            </para>
            <para>For more information, see Obtaining a Device Interface Name.</para>
            <para>The
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            message queries for the size of the buffer required to hold the device-interface name.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            , dwParam1 is a pointer to buffer size. This parameter points to a ULONG variable into which the function writes the required
            buffer size in bytes. The size includes storage space for the name string's terminating null. The size is zero if the device ID
            identifies a device that has no device interface.
            </para>
            <para>For
            <code>DRV_QUERYDEVICEINTERFACESIZE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            This message is valid only for the waveInMessage, <c>waveOutMessage</c>, midiInMessage, midiOutMessage, and mixerMessage
            functions. The system intercepts this message and returns the appropriate value without sending the message to the device
            driver. For general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            The buffer size retrieved by this message is expressed as a byte count. It specifies the size of the buffer needed to hold the
            null-terminated Unicode string that contains the device-interface name. The caller allocates a buffer of the specified size and
            uses the DRV_QUERYDEVICEINTERFACE message to retrieve the device-interface name string.
            </para>
            <para>For more information, see Obtaining a Device Interface Name.</para>
            <para>The
            <code>DRV_QUERYDEVNODE</code>
            message queries for the devnode number assigned to the device by the Plug and Play manager.
            </para>
            <para>For
            <code>DRV_QUERYDEVNODE</code>
            , dwParam1 is a pointer to a caller-allocated DWORD variable into which the function writes the devnode number. If no devnode is
            assigned to the device, the function sets this variable to zero.
            </para>
            <para>For
            <code>DRV_QUERYDEVNODE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            In Windows 2000 and later, the message always returns MMSYSERR_NOTSUPPORTED. This message is valid only for the waveInMessage,
            <c>waveOutMessage</c>, midiInMessage, midiOutMessage, and mixerMessage functions. The system intercepts this message and returns
            the appropriate value without sending the message to the device driver. For general information about system-intercepted
            <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>The
            <code>DRV_QUERYMAPPABLE</code>
            message queries for whether the specified device can be used by a mapper.
            </para>
            <para>For
            <code>DRV_QUERYMAPPABLE</code>
            , dwParam1 is unused. Set this parameter to zero.
            </para>
            <para>For
            <code>DRV_QUERYMAPPABLE</code>
            , dwParam2 is unused. Set this parameter to zero.
            </para>
            <para>
            This message is valid only for the waveInMessage, <c>waveOutMessage</c>, midiInMessage, midiOutMessage, mixerMessage and
            auxOutMessage functions. The system intercepts this message and returns the appropriate value without sending the message to the
            device driver. For general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            When an application program opens a mapper instead of a specific audio device, the system inserts a mapper between the
            application and the available devices. The mapper selects an appropriate device by mapping the application's requirements to one
            of the available devices. For more information about mappers, see the Microsoft Windows SDK documentation.
            </para>
            <para>The
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            message retrieves the device ID of the preferred voice-communications device.
            </para>
            <para>For
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            , dwParam1 is a pointer to device ID. This parameter points to a DWORD variable into which the function writes the device ID of
            the current preferred voice-communications device. The function writes the value (-1) if no device is available that qualifies
            as a preferred voice-communications device.
            </para>
            <para>For
            <code>DRVM_MAPPER_CONSOLEVOICECOM_GET</code>
            , dwParam2 is a pointer to status flags. This parameter points to a DWORD variable into which the function writes the
            device-status flags. Only one flag bit is currently defined: DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY.
            </para>
            <para>
            This message is valid only for the waveInMessage and <c>waveOutMessage</c> functions. When a caller calls these two functions
            with the DRVM_MAPPER_CONSOLEVOICECOM_GET message, the caller must specify the device ID as WAVE_MAPPER, and then cast this value
            to the appropriate handle type. For the <c>waveInMessage</c>, <c>waveOutMessage</c>, midiInMessage, midiOutMessage, or
            mixerMessage functions, the caller must cast the device ID to a handle of type HWAVEIN, HWAVEOUT, HMIDIIN, HMIDIOUT, or HMIXER,
            respectively. Note that if the caller supplies a valid handle instead of a device ID for this parameter, the function fails and
            returns error code MMSYSERR_NOSUPPORT.
            </para>
            <para>
            The system intercepts this message and returns the appropriate value without sending the message to the device driver. For
            general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            This message provides a way to determine which device is preferred specifically for voice communications, in contrast to the
            DRVM_MAPPER_PREFERRED_GET message, which determines which device is preferred for all other audio functions.
            </para>
            <para>
            For example, the preferred <c>waveOut</c> device for voice communications might be the earpiece in a headset, but the preferred
            <c>waveOut</c> device for all other audio functions might be a set of stereo speakers.
            </para>
            <para>
            When the DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY flag bit is set in the DWORD location pointed to by dwParam2, the
            <c>waveIn</c> and <c>waveOut</c> APIs use only the current preferred voice-communications device and do not search for other
            available devices if the preferred device is unavailable. The flag that is output by either the <c>waveInMessage</c> or
            <c>waveOutMessage</c> call applies to the preferred voice-communications device for both the <c>waveIn</c> and <c>waveOut</c>
            APIs, regardless of whether the call is made to <c>waveInMessage</c> or <c>waveOutMessage</c>. For more information, see
            Preferred Voice-Communications Device ID.
            </para>
            <para>The
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            message retrieves the device ID of the preferred audio device.
            </para>
            <para>For
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            , dwParam1 is a pointer to device ID. This parameter points to a DWORD variable into which the function writes the device ID of
            the current preferred device. The function writes the value (-1) if no device is available that qualifies as a preferred device.
            </para>
            <para>For
            <code>DRVM_MAPPER_PREFERRED_GET</code>
            , dwParam2 is a pointer to status flags. This parameter points to a DWORD variable into which the function writes the
            device-status flags. Only one flag bit is currently defined (for <c>waveInMessage</c> and <c>waveOutMessage</c> calls only): DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY.
            </para>
            <para>
            This message is valid only for the waveInMessage, <c>waveOutMessage</c> and midiOutMessage functions. When the caller calls
            these functions with the DRVM_MAPPER_PREFERRED_GET message, the caller must first specify the device ID as WAVE_MAPPER (for
            <c>waveInMessage</c> or <c>waveOutMessage</c>) or MIDI_MAPPER (for <c>midiOutMessage</c>), and then cast this value to the
            appropriate handle type. For the <c>waveInMessage</c>, <c>waveOutMessage</c>, or <c>midiOutMessage</c> functions, the caller
            must cast the device ID to a handle type HWAVEIN, HWAVEOUT or HMIDIOUT, respectively. Note that if the caller supplies a valid
            handle instead of a device ID for this parameter, the function fails and returns error code MMSYSERR_NOSUPPORT.
            </para>
            <para>
            The system intercepts this message and returns the appropriate value without sending the message to the device driver. For
            general information about system-intercepted <c>xxxMessage</c> functions, see System-Intercepted Device Messages.
            </para>
            <para>
            This message provides a way to determine which device is preferred for audio functions in general, in contrast to the
            DRVM_MAPPER_CONSOLEVOICECOM_GET message, which determines which device is preferred specifically for voice communications.
            </para>
            <para>
            When the DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY flag bit is set in the DWORD location pointed to by dwParam2, the
            <c>waveIn</c> and <c>waveOut</c> APIs use only the current preferred device and do not search for other available devices if the
            preferred device is unavailable. Note that the <c>midiOutMessage</c> function does not output this flag--the <c>midiOut</c> API
            always uses only the preferred device. The flag that is output by either the <c>waveInMessage</c> or <c>waveOutMessage</c> call
            applies to the preferred device for both the <c>waveIn</c> and <c>waveOut</c> APIs, regardless of whether the call is made to
            <c>waveInMessage</c> or <c>waveOutMessage</c>.
            </para>
            <para>
            The xxxMessage functions accept this value in place of a valid device handle in order to allow an application to determine the
            default device ID without first having to open a device. For more information, see Accessing the Preferred Device ID.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutOpen(Vanara.PInvoke.WinMm.SafeHWAVEOUT@,System.UInt32,Vanara.PInvoke.WinMm.WAVEFORMATEX@,System.IntPtr,System.IntPtr,Vanara.PInvoke.WinMm.WAVE_OPEN)">
            <summary>The <c>waveOutOpen</c> function opens the given waveform-audio output device for playback.</summary>
            <param name="phwo">
            Pointer to a buffer that receives a handle identifying the open waveform-audio output device. Use the handle to identify the
            device when calling other waveform-audio output functions. This parameter might be <c>NULL</c> if the <c>WAVE_FORMAT_QUERY</c>
            flag is specified for fdwOpen.
            </param>
            <param name="uDeviceID">
            <para>
            Identifier of the waveform-audio output device to open. It can be either a device identifier or a handle of an open
            waveform-audio input device. You can also use the following flag instead of a device identifier:
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WAVE_MAPPER</term>
            <term>The function selects a waveform-audio output device capable of playing the given format.</term>
            </item>
            </list>
            </param>
            <param name="pwfx">
            Pointer to a WAVEFORMATEX structure that identifies the format of the waveform-audio data to be sent to the device. You can free
            this structure immediately after passing it to <c>waveOutOpen</c>.
            </param>
            <param name="dwCallback">
            <para>Specifies the callback mechanism. The value must be one of the following:</para>
            <list type="bullet">
            <item>
            <term>A pointer to a callback function. For the function signature, see waveOutProc.</term>
            </item>
            <item>
            <term>A handle to a window.</term>
            </item>
            <item>
            <term>A thread identifier.</term>
            </item>
            <item>
            <term>A handle to an event.</term>
            </item>
            <item>
            <term>The value <c>NULL</c>.</term>
            </item>
            </list>
            <para>The</para>
            <para>fdwOpen</para>
            <para>parameter specifies how the</para>
            <para>dwCallback</para>
            <para>parameter is interpreted. For more information, see Remarks.</para>
            </param>
            <param name="dwInstance">
            User-instance data passed to the callback mechanism. This parameter is not used with the window callback mechanism.
            </param>
            <param name="fdwOpen">
            <para>Flags for opening the device. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>CALLBACK_EVENT</term>
            <term>The dwCallback parameter is an event handle.</term>
            </item>
            <item>
            <term>CALLBACK_FUNCTION</term>
            <term>The dwCallback parameter is a callback procedure address.</term>
            </item>
            <item>
            <term>CALLBACK_NULL</term>
            <term>No callback mechanism. This is the default setting.</term>
            </item>
            <item>
            <term>CALLBACK_THREAD</term>
            <term>The dwCallback parameter is a thread identifier.</term>
            </item>
            <item>
            <term>CALLBACK_WINDOW</term>
            <term>The dwCallback parameter is a window handle.</term>
            </item>
            <item>
            <term>WAVE_ALLOWSYNC</term>
            <term>
            If this flag is specified, a synchronous waveform-audio device can be opened. If this flag is not specified while opening a
            synchronous driver, the device will fail to open.
            </term>
            </item>
            <item>
            <term>WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE</term>
            <term>
            If this flag is specified and the uDeviceID parameter is WAVE_MAPPER, the function opens the default communication device. This
            flag applies only when uDeviceID equals WAVE_MAPPER.
            </term>
            </item>
            <item>
            <term>WAVE_FORMAT_DIRECT</term>
            <term>If this flag is specified, the ACM driver does not perform conversions on the audio data.</term>
            </item>
            <item>
            <term>WAVE_FORMAT_QUERY</term>
            <term>
            If this flag is specified, waveOutOpen queries the device to determine if it supports the given format, but the device is not
            actually opened.
            </term>
            </item>
            <item>
            <term>WAVE_MAPPED</term>
            <term>If this flag is specified, the uDeviceID parameter specifies a waveform-audio device to be mapped to by the wave mapper.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns <c>MMSYSERR_NOERROR</c> if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_ALLOCATED</term>
            <term>Specified resource is already allocated.</term>
            </item>
            <item>
            <term>MMSYSERR_BADDEVICEID</term>
            <term>Specified device identifier is out of range.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>WAVERR_BADFORMAT</term>
            <term>Attempted to open with an unsupported waveform-audio format.</term>
            </item>
            <item>
            <term>WAVERR_SYNC</term>
            <term>The device is synchronous but waveOutOpen was called without using the WAVE_ALLOWSYNC flag.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Use the waveOutGetNumDevs function to determine the number of waveform-audio output devices present in the system. If the value
            specified by the uDeviceID parameter is a device identifier, it can vary from zero to one less than the number of devices
            present. The <c>WAVE_MAPPER</c> constant can also be used as a device identifier.
            </para>
            <para>
            The structure pointed to by pwfx can be extended to include type-specific information for certain data formats. For example, for
            PCM data, an extra <c>UINT</c> is added to specify the number of bits per sample. Use the PCMWAVEFORMAT structure in this case.
            For all other waveform-audio formats, use the WAVEFORMATEX structure to specify the length of the additional data.
            </para>
            <para>
            If you choose to have a window or thread receive callback information, the following messages are sent to the window procedure
            function to indicate the progress of waveform-audio output: MM_WOM_OPEN, MM_WOM_CLOSE, and MM_WOM_DONE.
            </para>
            <para>Callback Mechanism</para>
            <para>The dwCallback and fdwOpen parameters specify how the application is notified about the progress of waveform-audio output.</para>
            <para>
            If fdwOpen contains the <c>CALLBACK_FUNCTION</c> flag, dwCallback is a pointer to a callback function. For the function
            signature, see waveOutProc. The uMsg parameter of the callback indicates the progress of the audio output:
            </para>
            <list type="bullet">
            <item>
            <term>WOM_OPEN</term>
            </item>
            <item>
            <term>WOM_CLOSE</term>
            </item>
            <item>
            <term>WOM_DONE</term>
            </item>
            </list>
            <para>
            If fdwOpen contains the <c>CALLBACK_WINDOW</c> flag, dwCallback is a handle to a window.The window receives the following
            messages, indicating the progress:
            </para>
            <list type="bullet">
            <item>
            <term>MM_WOM_OPEN</term>
            </item>
            <item>
            <term>MM_WOM_CLOSE</term>
            </item>
            <item>
            <term>MM_WOM_DONE</term>
            </item>
            </list>
            <para>
            If fdwOpen contains the <c>CALLBACK_THREAD</c> flag, dwCallback is a thread identifier. The thread receives the messages listed
            previously for <c>CALLBACK_WINDOW</c>.
            </para>
            <para>
            If fdwOpen contains the <c>CALLBACK_EVENT</c> flag, dwCallback is a handle to an event. The event is signaled whenever the state
            of the waveform buffer changes. The application can use WaitForSingleObject or WaitForMultipleObjects to wait for the event.
            When the event is signaled, you can get the current state of the waveform buffer by checking the <c>dwFlags</c> member of the
            WAVEHDR structure. (See waveOutPrepareHeader.)
            </para>
            <para>
            If fdwOpen contains the <c>CALLBACK_NULL</c> flag, dwCallback must be <c>NULL</c>. In that case, no callback mechanism is used.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutPause(Vanara.PInvoke.WinMm.HWAVEOUT)">
            <summary>
            The <c>waveOutPause</c> function pauses playback on the given waveform-audio output device. The current position is saved. Use
            the waveOutRestart function to resume playback from the current position.
            </summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>Specified device is synchronous and does not support pausing.</term>
            </item>
            </list>
            </returns>
            <remarks>Calling this function when the output is already paused has no effect, and the function returns zero.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutPrepareHeader(Vanara.PInvoke.WinMm.HWAVEOUT,Vanara.PInvoke.WinMm.WAVEHDR@,System.UInt32)">
            <summary>The <c>waveOutPrepareHeader</c> function prepares a waveform-audio data block for playback.</summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <param name="pwh">Pointer to a WAVEHDR structure that identifies the data block to be prepared.</param>
            <param name="cbwh">Size, in bytes, of the WAVEHDR structure.</param>
            <returns>
            <para>Returns <c>MMSYSERR_NOERROR</c> if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Set the <c>lpData</c>, <c>dwBufferLength</c>, and <c>dwFlags</c> members of the WAVEHDR structure before calling this function.
            Set the <c>dwFlags</c> member to zero.
            </para>
            <para>
            The <c>dwFlags</c>, <c>dwBufferLength</c>, and <c>dwLoops</c> members of the WAVEHDR structure can change between calls to this
            function and the waveOutWrite function. If you change the size specified by <c>dwBufferLength</c> before the call to
            <c>waveOutWrite</c>, the new value must be less than the prepared value.
            </para>
            <para>If the method succeeds, the <c>WHDR_PREPARED</c> flag is set in the <c>dwFlags</c> member of the WAVEHDR structure.</para>
            <para>Preparing a header that has already been prepared has no effect, and the function returns zero.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutReset(Vanara.PInvoke.WinMm.HWAVEOUT)">
            <summary>
            The <c>waveOutReset</c> function stops playback on the given waveform-audio output device and resets the current position to
            zero. All pending playback buffers are marked as done (WHDR_DONE) and returned to the application.
            </summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>Specified device is synchronous and does not support pausing.</term>
            </item>
            </list>
            </returns>
            <remarks>
            After this function returns, the application can send new playback buffers to the device by calling waveOutWrite, or close the
            device by calling waveOutClose.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutRestart(Vanara.PInvoke.WinMm.HWAVEOUT)">
            <summary>The <c>waveOutRestart</c> function resumes playback on a paused waveform-audio output device.</summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>Specified device is synchronous and does not support pausing.</term>
            </item>
            </list>
            </returns>
            <remarks>Calling this function when the output is not paused has no effect, and the function returns zero.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutSetPitch(Vanara.PInvoke.WinMm.HWAVEOUT,System.UInt32)">
            <summary>The <c>waveOutSetPitch</c> function sets the pitch for the specified waveform-audio output device.</summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <param name="dwPitch">
            <para>
            New pitch multiplier setting. This setting indicates the current change in pitch from the original authored setting. The pitch
            multiplier must be a positive value.
            </para>
            <para>
            The pitch multiplier is specified as a fixed-point value. The high-order word contains the signed integer part of the number,
            and the low-order word contains the fractional part. A value of 0x8000 in the low-order word represents one-half, and 0x4000
            represents one-quarter. For example, the value 0x00010000 specifies a multiplier of 1.0 (no pitch change), and a value of
            0x000F8000 specifies a multiplier of 15.5.
            </para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>Function isn't supported.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Changing the pitch does not change the playback rate or the sample rate, nor does it change the playback time. Not all devices
            support pitch changes. To determine whether the device supports pitch control, use the WAVECAPS_PITCH flag to test the
            <c>dwSupport</c> member of the <c>WAVEOUTCAPS</c> structure (filled by the <c>waveOutGetDevCaps</c> function).
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutSetPlaybackRate(Vanara.PInvoke.WinMm.HWAVEOUT,System.UInt32)">
            <summary>The <c>waveOutSetPlaybackRate</c> function sets the playback rate for the specified waveform-audio output device.</summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <param name="dwRate">
            <para>
            New playback rate setting. This setting is a multiplier indicating the current change in playback rate from the original
            authored setting. The playback rate multiplier must be a positive value.
            </para>
            <para>
            The rate is specified as a fixed-point value. The high-order word contains the signed integer part of the number, and the
            low-order word contains the fractional part. A value of 0x8000 in the low-order word represents one-half, and 0x4000 represents
            one-quarter. For example, the value 0x00010000 specifies a multiplier of 1.0 (no playback rate change), and a value of
            0x000F8000 specifies a multiplier of 15.5.
            </para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>Function isn't supported.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Changing the playback rate does not change the sample rate but does change the playback time. Not all devices support playback
            rate changes. To determine whether a device supports playback rate changes, use the WAVECAPS_PLAYBACKRATE flag to test the
            <c>dwSupport</c> member of the <c>WAVEOUTCAPS</c> structure (filled by the <c>waveOutGetDevCaps</c> function).
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutSetVolume(Vanara.PInvoke.WinMm.HWAVEOUT,System.UInt32)">
            <summary>The <c>waveOutSetVolume</c> function sets the volume level of the specified waveform-audio output device.</summary>
            <param name="hwo">Handle to an open waveform-audio output device. This parameter can also be a device identifier.</param>
            <param name="dwVolume">
            <para>
            New volume setting. The low-order word contains the left-channel volume setting, and the high-order word contains the
            right-channel setting. A value of 0xFFFF represents full volume, and a value of 0x0000 is silence.
            </para>
            <para>
            If a device does not support both left and right volume control, the low-order word of dwVolume specifies the volume level, and
            the high-order word is ignored.
            </para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>Function is not supported.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If a device identifier is used, then the result of the <c>waveOutSetVolume</c> call applies to all instances of the device. If a
            device handle is used, then the result applies only to the instance of the device referenced by the device handle.
            </para>
            <para>
            Not all devices support volume changes. To determine whether the device supports volume control, use the WAVECAPS_VOLUME flag to
            test the <c>dwSupport</c> member of the WAVEOUTCAPS structure (filled by the waveOutGetDevCaps function). To determine whether
            the device supports volume control on both the left and right channels, use the WAVECAPS_LRVOLUME flag.
            </para>
            <para>
            Most devices do not support the full 16 bits of volume-level control and will not use the least-significant bits of the
            requested volume setting. For example, if a device supports 4 bits of volume control, the values 0x4000, 0x4FFF, and 0x43BE will
            all be truncated to 0x4000. The <c>waveOutGetVolume</c> function returns the full 16-bit setting set with <c>waveOutSetVolume</c>.
            </para>
            <para>
            Volume settings are interpreted logarithmically. This means the perceived increase in volume is the same when increasing the
            volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutUnprepareHeader(Vanara.PInvoke.WinMm.HWAVEOUT,Vanara.PInvoke.WinMm.WAVEHDR@,System.UInt32)">
            <summary>
            The <c>waveOutUnprepareHeader</c> function cleans up the preparation performed by the waveOutPrepareHeader function. This
            function must be called after the device driver is finished with a data block. You must call this function before freeing the buffer.
            </summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <param name="pwh">Pointer to a WAVEHDR structure identifying the data block to be cleaned up.</param>
            <param name="cbwh">Size, in bytes, of the <c>WAVEHDR</c> structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>WAVERR_STILLPLAYING</term>
            <term>The data block pointed to by the pwh parameter is still in the queue.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function complements <c>waveOutPrepareHeader</c>. You must call this function before freeing the buffer. After passing a
            buffer to the device driver with the <c>waveOutWrite</c> function, you must wait until the driver is finished with the buffer
            before calling <c>waveOutUnprepareHeader</c>.
            </para>
            <para>Unpreparing a buffer that has not been prepared has no effect, and the function returns zero.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.waveOutWrite(Vanara.PInvoke.WinMm.HWAVEOUT,Vanara.PInvoke.WinMm.WAVEHDR@,System.UInt32)">
            <summary>The <c>waveOutWrite</c> function sends a data block to the given waveform-audio output device.</summary>
            <param name="hwo">Handle to the waveform-audio output device.</param>
            <param name="pwh">Pointer to a WAVEHDR structure containing information about the data block.</param>
            <param name="cbwh">Size, in bytes, of the <c>WAVEHDR</c> structure.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>Specified device handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>No device driver is present.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>Unable to allocate or lock memory.</term>
            </item>
            <item>
            <term>WAVERR_UNPREPARED</term>
            <term>The data block pointed to by the pwh parameter hasn't been prepared.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>When the buffer is finished, the WHDR_DONE bit is set in the <c>dwFlags</c> member of the <c>WAVEHDR</c> structure.</para>
            <para>
            The buffer must be prepared with the <c>waveOutPrepareHeader</c> function before it is passed to <c>waveOutWrite</c>. Unless the
            device is paused by calling the <c>waveOutPause</c> function, playback begins when the first data block is sent to the device.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.HWAVEIN">
            <summary>Provides a handle to a waveform-audio input device.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEIN.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.HWAVEIN"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HWAVEIN.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.WinMm.HWAVEIN"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HWAVEIN.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEIN.op_Explicit(Vanara.PInvoke.WinMm.HWAVEIN)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.WinMm.HWAVEIN"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEIN.op_Implicit(System.IntPtr)~Vanara.PInvoke.WinMm.HWAVEIN">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.WinMm.HWAVEIN"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEIN.op_Inequality(Vanara.PInvoke.WinMm.HWAVEIN,Vanara.PInvoke.WinMm.HWAVEIN)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEIN.op_Equality(Vanara.PInvoke.WinMm.HWAVEIN,Vanara.PInvoke.WinMm.HWAVEIN)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEIN.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEIN.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEIN.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.HWAVEOUT">
            <summary>Provides a handle to a waveform-audio output device.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEOUT.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.HWAVEOUT"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HWAVEOUT.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.WinMm.HWAVEOUT"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HWAVEOUT.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEOUT.op_Explicit(Vanara.PInvoke.WinMm.HWAVEOUT)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.WinMm.HWAVEOUT"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEOUT.op_Implicit(System.IntPtr)~Vanara.PInvoke.WinMm.HWAVEOUT">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.WinMm.HWAVEOUT"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEOUT.op_Inequality(Vanara.PInvoke.WinMm.HWAVEOUT,Vanara.PInvoke.WinMm.HWAVEOUT)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEOUT.op_Equality(Vanara.PInvoke.WinMm.HWAVEOUT,Vanara.PInvoke.WinMm.HWAVEOUT)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEOUT.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEOUT.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HWAVEOUT.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.WAVEFORMATEX">
            <summary>
            <para>
            The <c>WAVEFORMATEX</c> structure defines the format of waveform-audio data. Only format information common to all
            waveform-audio data formats is included in this structure. For formats that require additional information, this structure is
            included as the first member in another structure, along with the additional information.
            </para>
            <para>
            Formats that support more than two channels or sample sizes of more than 16 bits can be described in a WAVEFORMATEXTENSIBLE
            structure, which includes the WAVEFORMAT structure.
            </para>
            </summary>
            <remarks>
            An example of a format that uses extra information is the Microsoft Adaptive Delta Pulse Code Modulation (MS-ADPCM) format. The
            <c>wFormatTag</c> for MS-ADPCM is WAVE_FORMAT_ADPCM. The <c>cbSize</c> member will typically be set to 32. The extra information
            stored for WAVE_FORMAT_ADPCM is coefficient pairs required for encoding and decoding the waveform-audio data.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEX.wFormatTag">
            <summary>
            Waveform-audio format type. Format tags are registered with Microsoft Corporation for many compression algorithms. A
            complete list of format tags can be found in the Mmreg.h header file. For one- or two-channel PCM data, this value should be
            WAVE_FORMAT_PCM. When this structure is included in a WAVEFORMATEXTENSIBLE structure, this value must be WAVE_FORMAT_EXTENSIBLE.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEX.nChannels">
            <summary>Number of channels in the waveform-audio data. Monaural data uses one channel and stereo data uses two channels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEX.nSamplesPerSec">
            <summary>
            Sample rate, in samples per second (hertz). If <c>wFormatTag</c> is WAVE_FORMAT_PCM, then common values for
            <c>nSamplesPerSec</c> are 8.0 kHz, 11.025 kHz, 22.05 kHz, and 44.1 kHz. For non-PCM formats, this member must be computed
            according to the manufacturer's specification of the format tag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEX.nAvgBytesPerSec">
            <summary>
            Required average data-transfer rate, in bytes per second, for the format tag. If <c>wFormatTag</c> is WAVE_FORMAT_PCM,
            <c>nAvgBytesPerSec</c> should be equal to the product of <c>nSamplesPerSec</c> and <c>nBlockAlign</c>. For non-PCM formats,
            this member must be computed according to the manufacturer's specification of the format tag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEX.nBlockAlign">
            <summary>
            <para>
            Block alignment, in bytes. The block alignment is the minimum atomic unit of data for the <c>wFormatTag</c> format type. If
            <c>wFormatTag</c> is WAVE_FORMAT_PCM or WAVE_FORMAT_EXTENSIBLE, <c>nBlockAlign</c> must be equal to the product of
            <c>nChannels</c> and <c>wBitsPerSample</c> divided by 8 (bits per byte). For non-PCM formats, this member must be computed
            according to the manufacturer's specification of the format tag.
            </para>
            <para>
            Software must process a multiple of <c>nBlockAlign</c> bytes of data at a time. Data written to and read from a device must
            always start at the beginning of a block. For example, it is illegal to start playback of PCM data in the middle of a sample
            (that is, on a non-block-aligned boundary).
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEX.wBitsPerSample">
            <summary>
            Bits per sample for the <c>wFormatTag</c> format type. If <c>wFormatTag</c> is WAVE_FORMAT_PCM, then <c>wBitsPerSample</c>
            should be equal to 8 or 16. For non-PCM formats, this member must be set according to the manufacturer's specification of
            the format tag. If <c>wFormatTag</c> is WAVE_FORMAT_EXTENSIBLE, this value can be any integer multiple of 8 and represents
            the container size, not necessarily the sample size; for example, a 20-bit sample size is in a 24-bit container. Some
            compression schemes cannot define a value for <c>wBitsPerSample</c>, so this member can be 0.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEX.cbSize">
            <summary>
            Size, in bytes, of extra format information appended to the end of the <c>WAVEFORMATEX</c> structure. This information can
            be used by non-PCM formats to store extra attributes for the <c>wFormatTag</c>. If no extra information is required by the
            <c>wFormatTag</c>, this member must be set to 0. For WAVE_FORMAT_PCM formats (and only WAVE_FORMAT_PCM formats), this member
            is ignored. When this structure is included in a WAVEFORMATEXTENSIBLE structure, this value must be at least 22.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.WAVEFORMATEXTENSIBLE">
            <summary>
            The <c>WAVEFORMATEXTENSIBLE</c> structure defines the format of waveform-audio data for formats having more than two channels or
            higher sample resolutions than allowed by WAVEFORMATEX. It can also be used to define any format that can be defined by <c>WAVEFORMATEX</c>.
            </summary>
            <remarks>
            <para>
            <c>WAVEFORMATEXTENSIBLE</c> can describe any format that can be described by WAVEFORMATEX, but provides additional support for
            more than two channels, for greater precision in the number of bits per sample, and for new compression schemes.
            </para>
            <para>
            <c>WAVEFORMATEXTENSIBLE</c> can safely be cast to <c>WAVEFORMATEX</c>, because it simply configures the extra bytes specified by <c>WAVEFORMATEX.cbSize</c>.
            </para>
            <para>
            The <c>dwChannelMask</c> member specifies which channels are present in the multichannel stream. The least significant bit
            corresponds with the front left speaker, the next least significant bit corresponds to the front right speaker, and so on. The
            bits, in order of significance, are defined as follows.
            </para>
            <list type="table">
            <listheader>
            <term>Speaker position</term>
            <term>Flag bit</term>
            </listheader>
            <item>
            <term>SPEAKER_FRONT_LEFT</term>
            <term>0x1</term>
            </item>
            <item>
            <term>SPEAKER_FRONT_RIGHT</term>
            <term>0x2</term>
            </item>
            <item>
            <term>SPEAKER_FRONT_CENTER</term>
            <term>0x4</term>
            </item>
            <item>
            <term>SPEAKER_LOW_FREQUENCY</term>
            <term>0x8</term>
            </item>
            <item>
            <term>SPEAKER_BACK_LEFT</term>
            <term>0x10</term>
            </item>
            <item>
            <term>SPEAKER_BACK_RIGHT</term>
            <term>0x20</term>
            </item>
            <item>
            <term>SPEAKER_FRONT_LEFT_OF_CENTER</term>
            <term>0x40</term>
            </item>
            <item>
            <term>SPEAKER_FRONT_RIGHT_OF_CENTER</term>
            <term>0x80</term>
            </item>
            <item>
            <term>SPEAKER_BACK_CENTER</term>
            <term>0x100</term>
            </item>
            <item>
            <term>SPEAKER_SIDE_LEFT</term>
            <term>0x200</term>
            </item>
            <item>
            <term>SPEAKER_SIDE_RIGHT</term>
            <term>0x400</term>
            </item>
            <item>
            <term>SPEAKER_TOP_CENTER</term>
            <term>0x800</term>
            </item>
            <item>
            <term>SPEAKER_TOP_FRONT_LEFT</term>
            <term>0x1000</term>
            </item>
            <item>
            <term>SPEAKER_TOP_FRONT_CENTER</term>
            <term>0x2000</term>
            </item>
            <item>
            <term>SPEAKER_TOP_FRONT_RIGHT</term>
            <term>0x4000</term>
            </item>
            <item>
            <term>SPEAKER_TOP_BACK_LEFT</term>
            <term>0x8000</term>
            </item>
            <item>
            <term>SPEAKER_TOP_BACK_CENTER</term>
            <term>0x10000</term>
            </item>
            <item>
            <term>SPEAKER_TOP_BACK_RIGHT</term>
            <term>0x20000</term>
            </item>
            </list>
            <para>
            The channels specified in <c>dwChannelMask</c> must be present in the prescribed order (from least significant bit up). For
            example, if only SPEAKER_FRONT_LEFT and SPEAKER_FRONT_RIGHT are specified, then the samples for the front left speaker must come
            first in the interleaved stream. The number of bits set in <c>dwChannelMask</c> should be the same as the number of channels
            specified in <c>WAVEFORMATEX.nChannels</c>.
            </para>
            <para>
            For backward compatibility, any wave format that can be specified by a stand-alone WAVEFORMATEX structure can also be defined by
            a <c>WAVEFORMATEXTENSIBLE</c> structure. Thus, every wave-format tag in mmreg.h has a corresponding <c>SubFormat</c> GUID. The
            following table shows some typical wave-format tags and their corresponding <c>SubFormat</c> GUIDs. These GUIDs are defined in Ksmedia.h.
            </para>
            <list type="table">
            <listheader>
            <term>Wave-Format Tag</term>
            <term>SubFormat GUID</term>
            </listheader>
            <item>
            <term>WAVE_FORMAT_PCM</term>
            <term>KSDATAFORMAT_SUBTYPE_PCM</term>
            </item>
            <item>
            <term>WAVE_FORMAT_IEEE_FLOAT</term>
            <term>KSDATAFORMAT_SUBTYPE_IEEE_FLOAT</term>
            </item>
            <item>
            <term>WAVE_FORMAT_DRM</term>
            <term>KSDATAFORMAT_SUBTYPE_DRM</term>
            </item>
            <item>
            <term>WAVE_FORMAT_ALAW</term>
            <term>KSDATAFORMAT_SUBTYPE_ALAW</term>
            </item>
            <item>
            <term>WAVE_FORMAT_MULAW</term>
            <term>KSDATAFORMAT_SUBTYPE_MULAW</term>
            </item>
            <item>
            <term>WAVE_FORMAT_ADPCM</term>
            <term>KSDATAFORMAT_SUBTYPE_ADPCM</term>
            </item>
            </list>
            <para>
            Because <c>WAVEFORMATEXTENSIBLE</c> is an extended version of WAVEFORMATEX, it can describe additional formats that cannot be
            described by <c>WAVEFORMATEX</c> alone. Vendors are free to define their own <c>SubFormat</c> GUIDs to identify proprietary
            formats for which no wave-format tags exist.
            </para>
            <para>The following structures, for particular extended formats, are defined as <c>WAVEFORMATEXTENSIBLE</c>.</para>
            <list type="table">
            <listheader>
            <term>Definition</term>
            <term>Value of SubFormat</term>
            </listheader>
            <item>
            <term>WAVEFORMATIEEEFLOATEX</term>
            <term>KSDATAFORMAT_SUBTYPE_IEEE_FLOAT</term>
            </item>
            <item>
            <term>WAVEFORMATPCMEX</term>
            <term>KSDATAFORMAT_SUBTYPE_PCM</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEXTENSIBLE.Format">
            <summary>
            WAVEFORMATEX structure that specifies the basic format. The <c>wFormatTag</c> member must be WAVE_FORMAT_EXTENSIBLE. The
            <c>cbSize</c> member must be at least 22.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEXTENSIBLE.Samples">
            <summary>A union describing the sample format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEXTENSIBLE.dwChannelMask">
            <summary>Bitmask specifying the assignment of channels in the stream to speaker positions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEXTENSIBLE.SubFormat">
            <summary>
            Subformat of the data, such as KSDATAFORMAT_SUBTYPE_PCM. The subformat information is similar to that provided by the tag in
            the WAVEFORMATEX structure's <c>wFormatTag</c> member.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.WAVEFORMATEXTENSIBLE.SAMPLES">
            <summary>A union describing the sample format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEXTENSIBLE.SAMPLES.wValidBitsPerSample">
            <summary>
            Number of bits of precision in the signal. Usually equal to <c>WAVEFORMATEX.wBitsPerSample</c>. However,
            <c>wBitsPerSample</c> is the container size and must be a multiple of 8, whereas <c>wValidBitsPerSample</c> can be any
            value not exceeding the container size. For example, if the format uses 20-bit samples, <c>wBitsPerSample</c> must be at
            least 24, but <c>wValidBitsPerSample</c> is 20.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEXTENSIBLE.SAMPLES.wSamplesPerBlock">
            <summary>
            Number of samples contained in one compressed block of audio data. This value is used in buffer estimation. This value
            is used with compressed formats that have a fixed number of samples within each block. This value can be set to 0 if a
            variable number of samples is contained in each block of compressed audio data. In this case, buffer estimation and
            position information needs to be obtained in other ways.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMATEXTENSIBLE.SAMPLES.wReserved">
            <summary>Reserved for internal use by operating system. Set to 0.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.WAVEHDR">
            <summary>The <c>WAVEHDR</c> structure defines the header used to identify a waveform-audio buffer.</summary>
            <remarks>
            <para>
            Use the WHDR_BEGINLOOP and WHDR_ENDLOOP flags in the <c>dwFlags</c> member to specify the beginning and ending data blocks for
            looping. To loop on a single block, specify both flags for the same block. Use the <c>dwLoops</c> member in the <c>WAVEHDR</c>
            structure for the first block in the loop to specify the number of times to play the loop.
            </para>
            <para>
            The <c>lpData</c>, <c>dwBufferLength</c>, and <c>dwFlags</c> members must be set before calling the waveInPrepareHeader or
            waveOutPrepareHeader function. (For either function, the <c>dwFlags</c> member must be set to zero.)
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEHDR.lpData">
            <summary>Pointer to the waveform buffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEHDR.dwBufferLength">
            <summary>Length, in bytes, of the buffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEHDR.dwBytesRecorded">
            <summary>When the header is used in input, specifies how much data is in the buffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEHDR.dwUser">
            <summary>User data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEHDR.dwFlags">
            <summary>
            <para>A bitwise <c>OR</c> of zero of more flags. The following flags are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>WHDR_BEGINLOOP</term>
            <term>This buffer is the first buffer in a loop. This flag is used only with output buffers.</term>
            </item>
            <item>
            <term>WHDR_DONE</term>
            <term>Set by the device driver to indicate that it is finished with the buffer and is returning it to the application.</term>
            </item>
            <item>
            <term>WHDR_ENDLOOP</term>
            <term>This buffer is the last buffer in a loop. This flag is used only with output buffers.</term>
            </item>
            <item>
            <term>WHDR_INQUEUE</term>
            <term>Set by Windows to indicate that the buffer is queued for playback.</term>
            </item>
            <item>
            <term>WHDR_PREPARED</term>
            <term>
            Set by Windows to indicate that the buffer has been prepared with the waveInPrepareHeader or waveOutPrepareHeader function.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEHDR.dwLoops">
            <summary>Number of times to play the loop. This member is used only with output buffers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEHDR.lpNext">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEHDR.reserved">
            <summary>Reserved.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.WAVEINCAPS">
            <summary>The <c>WAVEINCAPS</c> structure describes the capabilities of a waveform-audio input device.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEINCAPS.wMid">
            <summary>
            Manufacturer identifier for the device driver for the waveform-audio input device. Manufacturer identifiers are defined in
            Manufacturer and Product Identifiers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEINCAPS.wPid">
            <summary>
            Product identifier for the waveform-audio input device. Product identifiers are defined in Manufacturer and Product Identifiers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEINCAPS.vDriverVersion">
            <summary>
            Version number of the device driver for the waveform-audio input device. The high-order byte is the major version number,
            and the low-order byte is the minor version number.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEINCAPS.szPname">
            <summary>Product name in a null-terminated string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEINCAPS.dwFormats">
            <summary>
            <para>Standard formats that are supported. Can be a combination of the following:</para>
            <list type="table">
            <listheader>
            <term>Format</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>WAVE_FORMAT_1M08</term>
            <term>11.025 kHz, mono, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_1M16</term>
            <term>11.025 kHz, mono, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_1S08</term>
            <term>11.025 kHz, stereo, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_1S16</term>
            <term>11.025 kHz, stereo, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_2M08</term>
            <term>22.05 kHz, mono, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_2M16</term>
            <term>22.05 kHz, mono, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_2S08</term>
            <term>22.05 kHz, stereo, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_2S16</term>
            <term>22.05 kHz, stereo, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_4M08</term>
            <term>44.1 kHz, mono, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_4M16</term>
            <term>44.1 kHz, mono, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_4S08</term>
            <term>44.1 kHz, stereo, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_4S16</term>
            <term>44.1 kHz, stereo, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_96M08</term>
            <term>96 kHz, mono, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_96M16</term>
            <term>96 kHz, mono, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_96S08</term>
            <term>96 kHz, stereo, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_96S16</term>
            <term>96 kHz, stereo, 16-bit</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEINCAPS.wChannels">
            <summary>Number specifying whether the device supports mono (1) or stereo (2) input.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.WAVEOUTCAPS">
            <summary>The <c>WAVEOUTCAPS</c> structure describes the capabilities of a waveform-audio output device.</summary>
            <remarks>
            If a device supports volume changes, the WAVECAPS_VOLUME flag will be set for the <c>dwSupport</c> member. If a device supports
            separate volume changes on the left and right channels, both the WAVECAPS_VOLUME and the WAVECAPS_LRVOLUME flags will be set for
            this member.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEOUTCAPS.wMid">
            <summary>
            Manufacturer identifier for the device driver for the device. Manufacturer identifiers are defined in Manufacturer and
            Product Identifiers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEOUTCAPS.wPid">
            <summary>Product identifier for the device. Product identifiers are defined in Manufacturer and Product Identifiers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEOUTCAPS.vDriverVersion">
            <summary>
            Version number of the device driver for the device. The high-order byte is the major version number, and the low-order byte
            is the minor version number.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEOUTCAPS.szPname">
            <summary>Product name in a null-terminated string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEOUTCAPS.dwFormats">
            <summary>
            <para>Standard formats that are supported. Can be a combination of the following:</para>
            <list type="table">
            <listheader>
            <term>Format</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>WAVE_FORMAT_1M08</term>
            <term>11.025 kHz, mono, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_1M16</term>
            <term>11.025 kHz, mono, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_1S08</term>
            <term>11.025 kHz, stereo, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_1S16</term>
            <term>11.025 kHz, stereo, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_2M08</term>
            <term>22.05 kHz, mono, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_2M16</term>
            <term>22.05 kHz, mono, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_2S08</term>
            <term>22.05 kHz, stereo, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_2S16</term>
            <term>22.05 kHz, stereo, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_4M08</term>
            <term>44.1 kHz, mono, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_4M16</term>
            <term>44.1 kHz, mono, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_4S08</term>
            <term>44.1 kHz, stereo, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_4S16</term>
            <term>44.1 kHz, stereo, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_96M08</term>
            <term>96 kHz, mono, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_96M16</term>
            <term>96 kHz, mono, 16-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_96S08</term>
            <term>96 kHz, stereo, 8-bit</term>
            </item>
            <item>
            <term>WAVE_FORMAT_96S16</term>
            <term>96 kHz, stereo, 16-bit</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEOUTCAPS.wChannels">
            <summary>Number specifying whether the device supports mono (1) or stereo (2) output.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEOUTCAPS.dwSupport">
            <summary>
            <para>Optional functionality supported by the device. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>WAVECAPS_LRVOLUME</term>
            <term>Supports separate left and right volume control.</term>
            </item>
            <item>
            <term>WAVECAPS_PITCH</term>
            <term>Supports pitch control.</term>
            </item>
            <item>
            <term>WAVECAPS_PLAYBACKRATE</term>
            <term>Supports playback rate control.</term>
            </item>
            <item>
            <term>WAVECAPS_SYNC</term>
            <term>The driver is synchronous and will block while playing a buffer.</term>
            </item>
            <item>
            <term>WAVECAPS_VOLUME</term>
            <term>Supports volume control.</term>
            </item>
            <item>
            <term>WAVECAPS_SAMPLEACCURATE</term>
            <term>Returns sample-accurate position information.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.SafeHWAVEIN">
            <summary>The <c>MMTIME</c> structure contains timing information for different types of multimedia data.</summary>
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.WinMm.HWAVEIN"/> that is disposed using <see cref="M:Vanara.PInvoke.WinMm.waveInClose(Vanara.PInvoke.WinMm.HWAVEIN)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SafeHWAVEIN.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.SafeHWAVEIN"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SafeHWAVEIN.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.SafeHWAVEIN"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SafeHWAVEIN.op_Implicit(Vanara.PInvoke.WinMm.SafeHWAVEIN)~Vanara.PInvoke.WinMm.HWAVEIN">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.WinMm.SafeHWAVEIN"/> to <see cref="T:Vanara.PInvoke.WinMm.HWAVEIN"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SafeHWAVEIN.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.SafeHWAVEOUT">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.WinMm.HWAVEOUT"/> that is disposed using <see cref="M:Vanara.PInvoke.WinMm.waveOutClose(Vanara.PInvoke.WinMm.HWAVEOUT)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SafeHWAVEOUT.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.SafeHWAVEOUT"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SafeHWAVEOUT.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.SafeHWAVEOUT"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SafeHWAVEOUT.op_Implicit(Vanara.PInvoke.WinMm.SafeHWAVEOUT)~Vanara.PInvoke.WinMm.HWAVEOUT">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.WinMm.SafeHWAVEOUT"/> to <see cref="T:Vanara.PInvoke.WinMm.HWAVEOUT"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SafeHWAVEOUT.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.DRIVERPROC">
            <summary>Processes driver messages for the installable driver. <c>DriverProc</c> is a driver-supplied function.</summary>
            <param name="dwDriverIdentifier">Identifier of the installable driver.</param>
            <param name="hdrvr">Handle of the installable driver instance. Each instance of the installable driver has a unique handle.</param>
            <param name="uMsg">
            <para>Driver message value. It can be a custom value or one of these standard values:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DRV_CLOSE</term>
            <term>Notifies the driver that it should decrement its usage count and unload the driver if the count is zero.</term>
            </item>
            <item>
            <term>DRV_CONFIGURE</term>
            <term>
            Notifies the driver that it should display a configuration dialog box. This message is sent only if the driver returns a nonzero
            value when processing the DRV_QUERYCONFIGURE message.
            </term>
            </item>
            <item>
            <term>DRV_DISABLE</term>
            <term>Notifies the driver that its allocated memory is about to be freed.</term>
            </item>
            <item>
            <term>DRV_ENABLE</term>
            <term>Notifies the driver that it has been loaded or reloaded or that Windows has been enabled.</term>
            </item>
            <item>
            <term>DRV_FREE</term>
            <term>Notifies the driver that it will be discarded.</term>
            </item>
            <item>
            <term>DRV_INSTALL</term>
            <term>Notifies the driver that it has been successfully installed.</term>
            </item>
            <item>
            <term>DRV_LOAD</term>
            <term>Notifies the driver that it has been successfully loaded.</term>
            </item>
            <item>
            <term>DRV_OPEN</term>
            <term>Notifies the driver that it is about to be opened.</term>
            </item>
            <item>
            <term>DRV_POWER</term>
            <term>Notifies the driver that the device's power source is about to be turned on or off.</term>
            </item>
            <item>
            <term>DRV_QUERYCONFIGURE</term>
            <term>Directs the driver to specify whether it supports the DRV_CONFIGURE message.</term>
            </item>
            <item>
            <term>DRV_REMOVE</term>
            <term>Notifies the driver that it is about to be removed from the system.</term>
            </item>
            </list>
            </param>
            <param name="lParam1">32-bit message-specific value.</param>
            <param name="lParam2">32-bit message-specific value.</param>
            <returns>Returns nonzero if successful or zero otherwise.</returns>
            <remarks>
            <para>
            When msg is DRV_OPEN, lParam1 is the string following the driver filename from the SYSTEM.INI file and lParam2 is the value
            given as the lParam parameter in a call to the OpenDriver function.
            </para>
            <para>
            When msg is DRV_CLOSE, lParam1 and lParam2 are the same values as the lParam1 and lParam2 parameters in a call to the
            CloseDriver function.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMIOPROC">
            <summary>
            The <c>MMIOProc</c> function is a custom input/output (I/O) procedure installed by the mmioInstallIOProc function.
            <c>MMIOProc</c> is a placeholder for the application-defined function name. The address of this function can be specified in the
            callback-address parameter of <c>mmioInstallIOProc</c>.
            </summary>
            <param name="lpmmioinfo">
            <para>Points to an MMIOINFO structure containing information about the open file.</para>
            <para>
            The I/O procedure must maintain the <c>lDiskOffset</c> member in this structure to indicate the file offset to the next read or
            write location. The I/O procedure can use the <c>adwInfo</c>[] member to store state information. The I/O procedure should not
            modify any other members of the MMIOINFO structure.
            </para>
            </param>
            <param name="uMsg">
            Specifies a message indicating the requested I/O operation. Messages that can be received include MMIOM_OPEN, MMIOM_CLOSE,
            MMIOM_READ, MMIOM_SEEK, MMIOM_WRITE, and MMIOM_WRITEFLUSH.
            </param>
            <param name="lParam1">Specifies an application-defined parameter for the message.</param>
            <param name="lParam2">Specifies an application-defined parameter for the message.</param>
            <returns>
            The return value depends on the message specified by uMsg. If the I/O procedure does not recognize a message, it should return zero.
            </returns>
            <remarks>
            <para>
            The four-character code specified by the <c>fccMMIOProc</c> member in the MMIOINFO structure associated with a file identifies a
            file name extension for a custom storage system. When an application calls mmioOpen with a file name such as "one.xyz+two", the
            I/O procedure associated with the four-character code "XYZ" is called to open the "two" element of the file "one.xyz".
            </para>
            <para>
            The mmioInstallIOProc function maintains a separate list of installed I/O procedures for each Windows-based application.
            Therefore, different applications can use the same I/O procedure identifier for different I/O procedures without conflict.
            However, installing an I/O procedure globally enables any process to use the procedure.
            </para>
            <para>
            If an application calls mmioInstallIOProc more than once to register the same I/O procedure, then it must call
            <c>mmioInstallIOProc</c> to remove the procedure once for each time it installed the procedure.
            </para>
            <para>
            mmioInstallIOProc will not prevent an application from installing two different I/O procedures with the same identifier, or
            installing an I/O procedure with one of the predefined identifiers ("DOS ", "MEM "). The most recently installed procedure takes
            precedence, and the most recently installed procedure is the first one to be removed.
            </para>
            <para>When searching for a specified I/O procedure, local procedures are searched first, then global procedures.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.DCB">
            <summary>Notification flags.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DCB.DCB_NULL">
            <summary>Unknown callback type</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DCB.DCB_WINDOW">
            <summary>
            The dwCallback parameter is the handle of an application-defined window. The system sends subsequent notifications to the window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DCB.DCB_TASK">
            <summary>
            The dwCallback parameter is the handle of an application or task. The system sends subsequent notifications to the
            application or task.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DCB.DCB_FUNCTION">
            <summary>
            The dwCallback parameter is the address of an application-defined callback function. The system sends the callback message
            to the callback function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DCB.DCB_EVENT">
            <summary>dwCallback is an EVENT</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DCB.DCB_NOSWITCH">
            <summary>
            The system is prevented from switching stacks. This value is only used if enough stack space for the callback function is
            known to exist.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.DRV">
            <summary>Driver message value. It can be a custom value or one of these standard values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_LOAD">
            <summary>Notifies the driver that it has been successfully loaded.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_ENABLE">
            <summary>Notifies the driver that it has been loaded or reloaded or that Windows has been enabled.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_OPEN">
            <summary>Notifies the driver that it is about to be opened.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_CLOSE">
            <summary>Notifies the driver that it should decrement its usage count and unload the driver if the count is zero.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_DISABLE">
            <summary>Notifies the driver that its allocated memory is about to be freed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_FREE">
            <summary>Notifies the driver that it will be discarded.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_CONFIGURE">
            <summary>
            Notifies the driver that it should display a configuration dialog box. This message is sent only if the driver returns a
            nonzero value when processing the DRV_QUERYCONFIGURE message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_QUERYCONFIGURE">
            <summary>Directs the driver to specify whether it supports the DRV_CONFIGURE message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_INSTALL">
            <summary>Notifies the driver that it has been successfully installed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_REMOVE">
            <summary>Notifies the driver that it is about to be removed from the system.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_EXITSESSION">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_POWER">
            <summary>Notifies the driver that the device's power source is about to be turned on or off.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_RESERVED">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRV.DRV_USER">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMIO">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_CREATE">
            <summary>The mmioOpen function was directed to create the file (or truncate it to zero length if it already existed).</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_PARSE">
            <summary>The new file's path is returned.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_DELETE">
            <summary>create new file (or truncate file)</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_EXIST">
            <summary>Checks for the existence of the file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_ALLOCBUF">
            <summary>File's I/O buffer was allocated by the mmioOpen or mmioSetBuffer function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_GETTEMP">
            <summary>A temporary name was retrieved by the mmioOpen function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_DIRTY">
            <summary>The I/O buffer has been modified.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_READ">
            <summary>File was opened only for reading.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_WRITE">
            <summary>File was opened only for writing.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_READWRITE">
            <summary>File was opened for reading and writing.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_COMPAT">
            <summary>
            File was opened with compatibility mode, allowing any process on a given machine to open the file any number of times.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_EXCLUSIVE">
            <summary>Other processes are denied read and write access to the file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_DENYWRITE">
            <summary>Other processes are denied write access to the file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_DENYREAD">
            <summary>Other processes are denied read access to the file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIO.MMIO_DENYNONE">
            <summary>Other processes are not denied read or write access to the file.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMIOCLOSE">
            <summary>Flags for the close operation.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOCLOSE.MMIO_FHOPEN">
            <summary>
            If the file was opened by passing a file handle whose type is not HMMIO, using this flag tells the mmioClose function to
            close the multimedia file handle, but not the standard file handle.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMIOCONV">
            <summary>Flags for the conversion.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOCONV.MMIO_TOUPPER">
            <summary>Converts all characters to uppercase.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMIOCREATE">
            <summary>Flags identifying what type of chunk to create.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOCREATE.MMIO_CREATERIFF">
            <summary>RIFF chunk</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOCREATE.MMIO_CREATELIST">
            <summary>LIST chunk</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMIODESC">
            <summary>
            Search flags. If no flags are specified, <c>mmioDescend</c> descends into the chunk beginning at the current file position.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIODESC.MMIO_FINDCHUNK">
            <summary>Searches for a chunk with the specified chunk identifier.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIODESC.MMIO_FINDRIFF">
            <summary>Searches for a chunk with the chunk identifier "RIFF" and with the specified form type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIODESC.MMIO_FINDLIST">
            <summary>Searches for a chunk with the chunk identifier "LIST" and with the specified form type.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMIOFLUSH">
            <summary>Flag determining how the flush is carried out.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOFLUSH.MMIO_EMPTYBUF">
            <summary>Empties the buffer after writing it to the disk.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMIOINST">
            <summary>Flag indicating whether the I/O procedure is being installed, removed, or located.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINST.MMIO_INSTALLPROC">
            <summary>Installs the specified I/O procedure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINST.MMIO_GLOBALPROC">
            <summary>
            This flag is a modifier to the MMIO_INSTALLPROC flag and indicates the I/O procedure should be installed for global use.
            This flag is ignored if MMIO_FINDPROC or MMIO_REMOVEPROC is specified.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINST.MMIO_REMOVEPROC">
            <summary>Removes the specified I/O procedure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINST.MMIO_UNICODEPROC">
            <summary>Unicode MMIOProc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINST.MMIO_FINDPROC">
            <summary>Searches for the specified I/O procedure.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMIOM">
            <summary>MMIO messages.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOM.MMIOM_READ">
            <summary>read</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOM.MMIOM_WRITE">
            <summary>write</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOM.MMIOM_SEEK">
            <summary>seek to a new position in file</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOM.MMIOM_OPEN">
            <summary>open file</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOM.MMIOM_CLOSE">
            <summary>close file</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOM.MMIOM_WRITEFLUSH">
            <summary>write and flush</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOM.MMIOM_RENAME">
            <summary>rename specified file</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOM.MMIOM_USER">
            <summary>beginning of user-defined messages</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.CloseDriver(Vanara.PInvoke.WinMm.HDRVR,System.IntPtr,System.IntPtr)">
            <summary>Closes an installable driver.</summary>
            <param name="hDriver">
            Handle of an installable driver instance. The handle must have been previously created by using the OpenDriver function.
            </param>
            <param name="lParam1">32-bit driver-specific data.</param>
            <param name="lParam2">32-bit driver-specific data.</param>
            <returns>Returns nonzero if successful or zero otherwise.</returns>
            <remarks>The function passes the lParam1 and lParam2 parameters to the DriverProc function of the installable driver.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.DefDriverProc(System.IntPtr,Vanara.PInvoke.WinMm.HDRVR,Vanara.PInvoke.WinMm.DRV,System.IntPtr,System.IntPtr)">
            <summary>
            Provides default processing for any messages not processed by an installable driver. This function is intended to be used only
            within the DriverProc function of an installable driver.
            </summary>
            <param name="dwDriverIdentifier">Identifier of the installable driver.</param>
            <param name="hdrvr">Handle of the installable driver instance.</param>
            <param name="uMsg">Driver message value.</param>
            <param name="lParam1">32-bit message-dependent information.</param>
            <param name="lParam2">32-bit message-dependent information.</param>
            <returns>Returns nonzero if successful or zero otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.DriverCallback(System.IntPtr,Vanara.PInvoke.WinMm.DCB,Vanara.PInvoke.WinMm.HDRVR,System.UInt32,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calls a callback function, sends a message to a window, or unblocks a thread. The action depends on the value of the
            notification flag. This function is intended to be used only within the DriverProc function of an installable driver.
            </summary>
            <param name="dwCallback">
            Address of the callback function, a window handle, or a task handle, depending on the flag specified in the dwFlags parameter.
            </param>
            <param name="dwFlags">
            <para>Notification flags. It can be one of these values:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DCB_NOSWITCH</term>
            <term>
            The system is prevented from switching stacks. This value is only used if enough stack space for the callback function is known
            to exist.
            </term>
            </item>
            <item>
            <term>DCB_FUNCTION</term>
            <term>
            The dwCallback parameter is the address of an application-defined callback function. The system sends the callback message to
            the callback function.
            </term>
            </item>
            <item>
            <term>DCB_WINDOW</term>
            <term>
            The dwCallback parameter is the handle of an application-defined window. The system sends subsequent notifications to the window.
            </term>
            </item>
            <item>
            <term>DCB_TASK</term>
            <term>
            The dwCallback parameter is the handle of an application or task. The system sends subsequent notifications to the application
            or task.
            </term>
            </item>
            </list>
            </param>
            <param name="hDevice">Handle of the installable driver instance.</param>
            <param name="dwMsg">Message value.</param>
            <param name="dwUser">32-bit user-instance data supplied by the application when the device was opened.</param>
            <param name="dwParam1">32-bit message-dependent parameter.</param>
            <param name="dwParam2">32-bit message-dependent parameter.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> if a parameter is invalid or the task's message queue is full.</returns>
            <remarks>
            <para>
            The client specifies how to notify it when the device is opened. The DCB_FUNCTION and DCB_WINDOW flags are equivalent to the
            high-order word of the corresponding flags CALLBACK_FUNCTION and CALLBACK_WINDOW specified in the lParam2 parameter of the
            DRV_OPEN message when the device was opened.
            </para>
            <para>
            If notification is accomplished with a callback function, hdrvr, msg, dwUser, dwParam1, and dwParam2 are passed to the callback
            function. If notification is accomplished by means of a window, only msg, hdrvr, and dwParam1 are passed to the window.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.DrvDefDriverProc(System.UInt32,Vanara.PInvoke.WinMm.HDRVR,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Provides default processing for any messages not processed by an installable driver. This function is intended to be used only
            within the DriverProc function of an installable driver.
            </summary>
            <param name="dwDriverIdentifier">Identifier of the installable driver.</param>
            <param name="hdrvr">Handle of the installable driver instance.</param>
            <param name="uMsg">Driver message value.</param>
            <param name="lParam1">32-bit message-dependent information.</param>
            <param name="lParam2">32-bit message-dependent information.</param>
            <returns>Returns nonzero if successful or zero otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.DrvGetModuleHandle(Vanara.PInvoke.WinMm.HDRVR)">
            <summary>
            Retrieves the instance handle of the module that contains the installable driver. This function is provided for compatibility
            with previous versions of Windows.
            </summary>
            <param name="hDriver">
            Handle of the installable driver instance. The handle must have been previously created by using the OpenDriver function.
            </param>
            <returns>Returns an instance handle of the driver module if successful or <c>NULL</c> otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.GetDriverModuleHandle(Vanara.PInvoke.WinMm.HDRVR)">
            <summary>Retrieves the instance handle of the module that contains the installable driver.</summary>
            <param name="hDriver">Handle of the installable driver instance. The handle must have been previously created by using the OpenDriver function.</param>
            <returns>Returns an instance handle of the driver module if successful or <c>NULL</c> otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioAdvance(Vanara.PInvoke.WinMm.HMMIO,Vanara.PInvoke.WinMm.MMIOINFO@,Vanara.PInvoke.WinMm.MMIO)">
            <summary>
            The <c>mmioAdvance</c> function advances the I/O buffer of a file set up for direct I/O buffer access with the mmioGetInfo function.
            </summary>
            <param name="hmmio">File handle of a file opened by using the mmioOpen function.</param>
            <param name="pmmioinfo">
            Pointer to the MMIOINFO structure obtained by using the mmioGetInfo function. This structure is used to set the current file
            information, and then it is updated after the buffer is advanced. This parameter is optional.
            </param>
            <param name="fuAdvance">
            <para>Flags for the operation. It can be one of the following.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MMIO_READ</term>
            <term>Buffer is filled from the file.</term>
            </item>
            <item>
            <term>MMIO_WRITE</term>
            <term>Buffer is written to the file.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMIOERR_CANNOTEXPAND</term>
            <term>
            The specified memory file cannot be expanded, probably because the adwInfo member of the MMIOINFO structure was set to zero in
            the initial call to the mmioOpen function.
            </term>
            </item>
            <item>
            <term>MMIOERR_CANNOTREAD</term>
            <term>An error occurred while refilling the buffer.</term>
            </item>
            <item>
            <term>MMIOERR_CANNOTWRITE</term>
            <term>The contents of the buffer could not be written to disk.</term>
            </item>
            <item>
            <term>MMIOERR_OUTOFMEMORY</term>
            <term>There was not enough memory to expand a memory file for further writing.</term>
            </item>
            <item>
            <term>MMIOERR_UNBUFFERED</term>
            <term>The specified file is not opened for buffered I/O.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If the file is opened for reading, the I/O buffer is filled from the disk. If the file is opened for writing and the MMIO_DIRTY
            flag is set in the <c>dwFlags</c> member of the MMIOINFO structure, the buffer is written to disk. The
            <c>pchNext,</c><c>pchEndRead</c>, and <c>pchEndWrite</c> members of the <c>MMIOINFO</c> structure are updated to reflect the new
            state of the I/O buffer.
            </para>
            <para>
            If the specified file is opened for writing or for both reading and writing, the I/O buffer is flushed to disk before the next
            buffer is read. If the I/O buffer cannot be written to disk because the disk is full, <c>mmioAdvance</c> returns MMIOERR_CANNOTWRITE.
            </para>
            <para>If the specified file is open only for writing, the MMIO_WRITE flag must be specified.</para>
            <para>
            If you have written to the I/O buffer, you must set the MMIO_DIRTY flag in the <c>dwFlags</c> member of the <c>MMIOINFO</c>
            structure before calling <c>mmioAdvance</c>. Otherwise, the buffer will not be written to disk.
            </para>
            <para>
            If the end of file is reached, <c>mmioAdvance</c> still returns successfully even though no more data can be read. To check for
            the end of the file, check if the <c>pchNext</c> and <c>pchEndRead</c> members of the <c>MMIOINFO</c> structure are equal after
            calling <c>mmioAdvance</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioAdvance(Vanara.PInvoke.WinMm.HMMIO,System.IntPtr,Vanara.PInvoke.WinMm.MMIO)">
            <summary>
            The <c>mmioAdvance</c> function advances the I/O buffer of a file set up for direct I/O buffer access with the mmioGetInfo function.
            </summary>
            <param name="hmmio">File handle of a file opened by using the mmioOpen function.</param>
            <param name="pmmioinfo">
            Pointer to the MMIOINFO structure obtained by using the mmioGetInfo function. This structure is used to set the current file
            information, and then it is updated after the buffer is advanced. This parameter is optional.
            </param>
            <param name="fuAdvance">
            <para>Flags for the operation. It can be one of the following.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MMIO_READ</term>
            <term>Buffer is filled from the file.</term>
            </item>
            <item>
            <term>MMIO_WRITE</term>
            <term>Buffer is written to the file.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMIOERR_CANNOTEXPAND</term>
            <term>
            The specified memory file cannot be expanded, probably because the adwInfo member of the MMIOINFO structure was set to zero in
            the initial call to the mmioOpen function.
            </term>
            </item>
            <item>
            <term>MMIOERR_CANNOTREAD</term>
            <term>An error occurred while refilling the buffer.</term>
            </item>
            <item>
            <term>MMIOERR_CANNOTWRITE</term>
            <term>The contents of the buffer could not be written to disk.</term>
            </item>
            <item>
            <term>MMIOERR_OUTOFMEMORY</term>
            <term>There was not enough memory to expand a memory file for further writing.</term>
            </item>
            <item>
            <term>MMIOERR_UNBUFFERED</term>
            <term>The specified file is not opened for buffered I/O.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If the file is opened for reading, the I/O buffer is filled from the disk. If the file is opened for writing and the MMIO_DIRTY
            flag is set in the <c>dwFlags</c> member of the MMIOINFO structure, the buffer is written to disk. The
            <c>pchNext,</c><c>pchEndRead</c>, and <c>pchEndWrite</c> members of the <c>MMIOINFO</c> structure are updated to reflect the new
            state of the I/O buffer.
            </para>
            <para>
            If the specified file is opened for writing or for both reading and writing, the I/O buffer is flushed to disk before the next
            buffer is read. If the I/O buffer cannot be written to disk because the disk is full, <c>mmioAdvance</c> returns MMIOERR_CANNOTWRITE.
            </para>
            <para>If the specified file is open only for writing, the MMIO_WRITE flag must be specified.</para>
            <para>
            If you have written to the I/O buffer, you must set the MMIO_DIRTY flag in the <c>dwFlags</c> member of the <c>MMIOINFO</c>
            structure before calling <c>mmioAdvance</c>. Otherwise, the buffer will not be written to disk.
            </para>
            <para>
            If the end of file is reached, <c>mmioAdvance</c> still returns successfully even though no more data can be read. To check for
            the end of the file, check if the <c>pchNext</c> and <c>pchEndRead</c> members of the <c>MMIOINFO</c> structure are equal after
            calling <c>mmioAdvance</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioAscend(Vanara.PInvoke.WinMm.HMMIO,Vanara.PInvoke.WinMm.MMCKINFO@,System.UInt32)">
            <summary>
            The <c>mmioAscend</c> function ascends out of a chunk in a RIFF file descended into with the mmioDescend function or created
            with the mmioCreateChunk function.
            </summary>
            <param name="hmmio">File handle of an open RIFF file.</param>
            <param name="pmmcki">
            Pointer to an application-defined MMCKINFO structure previously filled by the mmioDescend or mmioCreateChunk function.
            </param>
            <param name="fuAscend">Reserved; must be zero.</param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMIOERR_CANNOTSEEK</term>
            <term>There was an error while seeking to the end of the chunk.</term>
            </item>
            <item>
            <term>MMIOERR_CANNOTWRITE</term>
            <term>The contents of the buffer could not be written to disk.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If the chunk was descended into by using mmioDescend, <c>mmioAscend</c> seeks to the location following the end of the chunk
            (past the extra pad byte, if any).
            </para>
            <para>
            If the chunk was created and descended into by using <c>mmioCreateChunk</c>, or if the MMIO_DIRTY flag is set in the
            <c>dwFlags</c> member of the <c>MMCKINFO</c> structure referenced by lpck, the current file position is assumed to be the end of
            the data portion of the chunk. If the chunk size is not the same as the value stored in the <c>cksize</c> member of the
            <c>MMCKINFO</c> structure when <c>mmioCreateChunk</c> was called, <c>mmioAscend</c> corrects the chunk size in the file before
            ascending from the chunk. If the chunk size is odd, <c>mmioAscend</c> writes a null pad byte at the end of the chunk. After
            ascending from the chunk, the current file position is the location following the end of the chunk (past the extra pad byte, if any).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioClose(Vanara.PInvoke.WinMm.HMMIO,Vanara.PInvoke.WinMm.MMIOCLOSE)">
            <summary>The <c>mmioClose</c> function closes a file that was opened by using the mmioOpen function.</summary>
            <param name="hmmio">File handle of the file to close.</param>
            <param name="fuClose">
            <para>Flags for the close operation. The following value is defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MMIO_FHOPEN</term>
            <term>
            If the file was opened by passing a file handle whose type is not HMMIO, using this flag tells the mmioClose function to close
            the multimedia file handle, but not the standard file handle.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            Returns zero if successful or an error otherwise. The error value can originate from the mmioFlush function or from the I/O
            procedure. Possible error values include the following.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMIOERR_CANNOTWRITE</term>
            <term>The contents of the buffer could not be written to disk.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioCreateChunk(Vanara.PInvoke.WinMm.HMMIO,Vanara.PInvoke.WinMm.MMCKINFO@,Vanara.PInvoke.WinMm.MMIOCREATE)">
            <summary>
            The <c>mmioCreateChunk</c> function creates a chunk in a RIFF file that was opened by using the mmioOpen function. The new chunk
            is created at the current file position. After the new chunk is created, the current file position is the beginning of the data
            portion of the new chunk.
            </summary>
            <param name="hmmio">File handle of an open RIFF file.</param>
            <param name="pmmcki">Pointer to a buffer that receives a MMCKINFO structure containing information about the chunk to be created.</param>
            <param name="fuCreate">
            <para>Flags identifying what type of chunk to create. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MMIO_CREATELIST</term>
            <term>"LIST" chunk.</term>
            </item>
            <item>
            <term>MMIO_CREATERIFF</term>
            <term>"RIFF" chunk.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMIOERR_CANNOTSEEK</term>
            <term>Unable to determine offset of the data portion of the chunk.</term>
            </item>
            <item>
            <term>MMIOERR_CANNOTWRITE</term>
            <term>Unable to write the chunk header.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function cannot insert a chunk into the middle of a file. If an application attempts to create a chunk somewhere other than
            at the end of a file, <c>mmioCreateChunk</c> overwrites existing information in the file.
            </para>
            <para>The MMCKINFO structure pointed to by the lpck parameter should be set up as follows:</para>
            <list type="bullet">
            <item>
            <term>
            The <c>ckid</c> member specifies the chunk identifier. If wFlags includes MMIO_CREATERIFF or MMIO_CREATELIST, this member will
            be filled by <c>mmioCreateChunk</c>.
            </term>
            </item>
            <item>
            <term>
            The <c>cksize</c> member specifies the size of the data portion of the chunk, including the form type or list type (if any). If
            this value is not correct when the mmioAscend function is called to mark the end of the chunk, <c>mmioAscend</c> corrects the
            chunk size.
            </term>
            </item>
            <item>
            <term>
            The <c>fccType</c> member specifies the form type or list type if the chunk is a "RIFF" or "LIST" chunk. If the chunk is not a
            "RIFF" or "LIST" chunk, this member does not need to be filled in.
            </term>
            </item>
            <item>
            <term>
            The <c>dwDataOffset</c> member does not need to be filled in. The <c>mmioCreateChunk</c> function fills this member with the
            file offset of the data portion of the chunk.
            </term>
            </item>
            <item>
            <term>
            The <c>dwFlags</c> member does not need to be filled in. The <c>mmioCreateChunk</c> function sets the MMIO_DIRTY flag in <c>dwFlags</c>.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioDescend(Vanara.PInvoke.WinMm.HMMIO,Vanara.PInvoke.WinMm.MMCKINFO@,Vanara.PInvoke.WinMm.MMCKINFO@,Vanara.PInvoke.WinMm.MMIODESC)">
            <summary>
            The <c>mmioDescend</c> function descends into a chunk of a RIFF file that was opened by using the mmioOpen function. It can also
            search for a given chunk.
            </summary>
            <param name="hmmio">File handle of an open RIFF file.</param>
            <param name="pmmcki">Pointer to a buffer that receives an MMCKINFO structure.</param>
            <param name="pmmckiParent">
            Pointer to an optional application-defined MMCKINFO structure identifying the parent of the chunk being searched for. If this
            parameter is not <c>NULL</c>, <c>mmioDescend</c> assumes the <c>MMCKINFO</c> structure it refers to was filled when
            <c>mmioDescend</c> was called to descend into the parent chunk, and <c>mmioDescend</c> searches for a chunk within the parent
            chunk. Set this parameter to <c>NULL</c> if no parent chunk is being specified.
            </param>
            <param name="fuDescend">
            <para>
            Search flags. If no flags are specified, <c>mmioDescend</c> descends into the chunk beginning at the current file position. The
            following values are defined.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MMIO_FINDCHUNK</term>
            <term>Searches for a chunk with the specified chunk identifier.</term>
            </item>
            <item>
            <term>MMIO_FINDLIST</term>
            <term>Searches for a chunk with the chunk identifier "LIST" and with the specified form type.</term>
            </item>
            <item>
            <term>MMIO_FINDRIFF</term>
            <term>Searches for a chunk with the chunk identifier "RIFF" and with the specified form type.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMIOERR_CHUNKNOTFOUND</term>
            <term>The end of the file (or the end of the parent chunk, if given) was reached before the desired chunk was found.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            A "RIFF" chunk consists of a four-byte chunk identifier (type <c>FOURCC</c>), followed by a four-byte chunk size (type
            <c>DWORD</c>), followed by the data portion of the chunk, followed by a null pad byte if the size of the data portion is odd. If
            the chunk identifier is "RIFF" or "LIST", the first four bytes of the data portion of the chunk are a form type or list type
            (type <c>FOURCC</c>).
            </para>
            <para>
            If you use <c>mmioDescend</c> to search for a chunk, make sure the file position is at the beginning of a chunk before calling
            the function. The search begins at the current file position and continues to the end of the file. If a parent chunk is
            specified, the file position should be somewhere within the parent chunk before calling <c>mmioDescend</c>. In this case, the
            search begins at the current file position and continues to the end of the parent chunk.
            </para>
            <para>
            If <c>mmioDescend</c> is unsuccessful in searching for a chunk, the current file position is undefined. If <c>mmioDescend</c> is
            successful, the current file position is changed. If the chunk is a "RIFF" or "LIST" chunk, the new file position will be just
            after the form type or list type (12 bytes from the beginning of the chunk). For other chunks, the new file position will be the
            start of the data portion of the chunk (8 bytes from the beginning of the chunk).
            </para>
            <para>The <c>mmioDescend</c> function fills the MMCKINFO structure pointed to by the lpck parameter with the following information:</para>
            <list type="bullet">
            <item>
            <term>
            The <c>ckid</c> member is the chunk. If the MMIO_FINDCHUNK, MMIO_FINDRIFF, or MMIO_FINDLIST flag is specified for <c>wFlags</c>,
            the MMCKINFO structure is also used to pass parameters to <c>mmioDescend</c>. In this case, the <c>ckid</c> member specifies the
            four-character code of the chunk identifier, form type, or list type to search for.
            </term>
            </item>
            <item>
            <term>
            The <c>cksize</c> member is the size, in bytes, of the data portion of the chunk. The size includes the form type or list type
            (if any), but does not include the 8-byte chunk header or the pad byte at the end of the data (if any).
            </term>
            </item>
            <item>
            <term>
            The <c>fccType</c> member is the form type if <c>ckid</c> is "RIFF", or the list type if <c>ckid</c> is "LIST". Otherwise, it is <c>NULL</c>.
            </term>
            </item>
            <item>
            <term>
            The <c>dwDataOffset</c> member is the file offset of the beginning of the data portion of the chunk. If the chunk is a "RIFF"
            chunk or a "LIST" chunk, this member is the offset of the form type or list type.
            </term>
            </item>
            <item>
            <term>
            The <c>dwFlags</c> member contains other information about the chunk. Currently, this information is not used and is set to zero.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioFlush(Vanara.PInvoke.WinMm.HMMIO,Vanara.PInvoke.WinMm.MMIOFLUSH)">
            <summary>The <c>mmioFlush</c> function writes the I/O buffer of a file to disk if the buffer has been written to.</summary>
            <param name="hmmio">File handle of a file opened by using the mmioOpen function.</param>
            <param name="fuFlush">
            <para>Flag determining how the flush is carried out. It can be zero or the following.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMIO_EMPTYBUF</term>
            <term>Empties the buffer after writing it to the disk.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMIOERR_CANNOTWRITE</term>
            <term>The contents of the buffer could not be written to disk.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Closing a file with the mmioClose function automatically flushes its buffer.</para>
            <para>
            If there is insufficient disk space to write the buffer, <c>mmioFlush</c> fails, even if the preceding calls of the mmioWrite
            function were successful.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioGetInfo(Vanara.PInvoke.WinMm.HMMIO,Vanara.PInvoke.WinMm.MMIOINFO@,System.UInt32)">
            <summary>
            The <c>mmioGetInfo</c> function retrieves information about a file opened by using the mmioOpen function. This information
            allows the application to directly access the I/O buffer, if the file is opened for buffered I/O.
            </summary>
            <param name="hmmio">File handle of the file.</param>
            <param name="pmmioinfo">
            Pointer to a buffer that receives an MMIOINFO structure that <c>mmioGetInfo</c> fills with information about the file.
            </param>
            <param name="fuInfo">Reserved; must be zero.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>
            To directly access the I/O buffer of a file opened for buffered I/O, use the following members of the MMIOINFO structure filled
            by <c>mmioGetInfo</c>:
            </para>
            <list type="bullet">
            <item>
            <term>
            The <c>pchNext</c> member points to the next byte in the buffer that can be read or written. When you read or write, increment
            <c>pchNext</c> by the number of bytes read or written.
            </term>
            </item>
            <item>
            <term>The <c>pchEndRead</c> member points to 1 byte past the last valid byte in the buffer that can be read.</term>
            </item>
            <item>
            <term>The <c>pchEndWrite</c> member points to 1 byte past the last location in the buffer that can be written.</term>
            </item>
            </list>
            <para>
            After you read or write to the buffer and modify <c>pchNext</c>, do not call any multimedia file I/O functions except
            mmioAdvance until you call the mmioSetInfo function. Call <c>mmioSetInfo</c> when you are finished directly accessing the buffer.
            </para>
            <para>
            When you reach the end of the buffer specified by the <c>pchEndRead</c> or <c>pchEndWrite</c> member, call mmioAdvance to fill
            the buffer from the disk or write the buffer to the disk. The <c>mmioAdvance</c> function updates the <c>pchNext</c>,
            <c>pchEndRead</c>, and <c>pchEndWrite</c> members in the MMIOINFO structure for the file.
            </para>
            <para>
            Before calling mmioAdvance or mmioSetInfo to flush a buffer to disk, set the MMIO_DIRTY flag in the <c>dwFlags</c> member of the
            MMIOINFO structure for the file. Otherwise, the buffer will not be written to disk.
            </para>
            <para>
            Do not decrement <c>pchNext</c> or modify any members in the MMIOINFO structure other than <c>pchNext</c> and <c>dwFlags</c>. Do
            not set any flags in <c>dwFlags</c> except MMIO_DIRTY.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioInstallIOProc(System.UInt32,Vanara.PInvoke.WinMm.MMIOPROC,Vanara.PInvoke.WinMm.MMIOINST)">
            <summary>
            The <c>mmioInstallIOProc</c> function installs or removes a custom I/O procedure. This function also locates an installed I/O
            procedure, using its corresponding four-character code.
            </summary>
            <param name="fccIOProc">
            Four-character code identifying the I/O procedure to install, remove, or locate. All characters in this code should be uppercase.
            </param>
            <param name="pIOProc">
            Pointer to the I/O procedure to install. To remove or locate an I/O procedure, set this parameter to <c>NULL</c>. For more
            information about the I/O procedure, see MMIOProc.
            </param>
            <param name="dwFlags">
            <para>Flag indicating whether the I/O procedure is being installed, removed, or located. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MMIO_FINDPROC</term>
            <term>Searches for the specified I/O procedure.</term>
            </item>
            <item>
            <term>MMIO_GLOBALPROC</term>
            <term>
            This flag is a modifier to the MMIO_INSTALLPROC flag and indicates the I/O procedure should be installed for global use. This
            flag is ignored if MMIO_FINDPROC or MMIO_REMOVEPROC is specified.
            </term>
            </item>
            <item>
            <term>MMIO_INSTALLPROC</term>
            <term>Installs the specified I/O procedure.</term>
            </item>
            <item>
            <term>MMIO_REMOVEPROC</term>
            <term>Removes the specified I/O procedure.</term>
            </item>
            </list>
            </param>
            <returns>Returns the address of the I/O procedure installed, removed, or located. Returns <c>NULL</c> if there is an error.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioOpen(System.Text.StringBuilder,Vanara.PInvoke.WinMm.MMIOINFO@,Vanara.PInvoke.WinMm.MMIO)">
            <summary>
            <para>
            The <c>mmioOpen</c> function opens a file for unbuffered or buffered I/O; creates a file; deletes a file; or checks whether a
            file exists. The file can be a standard file, a memory file, or an element of a custom storage system. The handle returned by
            mmioOpen is not a standard file handle; do not use it with any file I/O functions other than multimedia file I/O functions.
            </para>
            <para><c>Note</c> This function is deprecated. Applications should call CreateFile to create or open files.</para>
            </summary>
            <param name="pszFileName">
            <para>
            Pointer to a buffer that contains the name of the file. If no I/O procedure is specified to open the file, the file name
            determines how the file is opened, as follows:
            </para>
            <list type="bullet">
            <item>
            <term>
            If the file name does not contain a plus sign (+), it is assumed to be the name of a standard file (that is, a file whose type
            is not <c>HMMIO</c>).
            </term>
            </item>
            <item>
            <term>
            If the file name is of the form EXAMPLE.EXT+ABC, the extension EXT is assumed to identify an installed I/O procedure which is
            called to perform I/O on the file. For more information, see mmioInstallIOProc.
            </term>
            </item>
            <item>
            <term>
            If the file name is <c>NULL</c> and no I/O procedure is given, the <c>adwInfo</c> member of the MMIOINFO structure is assumed to
            be the standard (non- <c>HMMIO</c>) file handle of a currently open file.
            </term>
            </item>
            </list>
            <para>The file name should not be longer than 128 characters, including the terminating NULL character.</para>
            <para>When opening a memory file, set szFilename to <c>NULL</c>.</para>
            </param>
            <param name="pmmioinfo">
            Pointer to an MMIOINFO structure containing extra parameters used by <c>mmioOpen</c>. Unless you are opening a memory file,
            specifying the size of a buffer for buffered I/O, or specifying an uninstalled I/O procedure to open a file, this parameter
            should be <c>NULL</c>. If this parameter is not <c>NULL</c>, all unused members of the <c>MMIOINFO</c> structure it references
            must be set to zero, including the reserved members.
            </param>
            <param name="fdwOpen">
            <para>
            Flags for the open operation. The MMIO_READ, MMIO_WRITE, and MMIO_READWRITE flags are mutually exclusive – only one should be
            specified. The MMIO_COMPAT, MMIO_EXCLUSIVE, MMIO_DENYWRITE, MMIO_DENYREAD, and MMIO_DENYNONE flags are file-sharing flags. The
            following values are defined.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MMIO_ALLOCBUF</term>
            <term>
            Opens a file for buffered I/O. To allocate a buffer larger or smaller than the default buffer size (8K, defined as
            MMIO_DEFAULTBUFFER), set the cchBuffer member of the MMIOINFO structure to the desired buffer size. If cchBuffer is zero, the
            default buffer size is used. If you are providing your own I/O buffer, this flag should not be used.
            </term>
            </item>
            <item>
            <term>MMIO_COMPAT</term>
            <term>
            Opens the file with compatibility mode, allowing any process on a given machine to open the file any number of times. If the
            file has been opened with any of the other sharing modes, mmioOpen fails.
            </term>
            </item>
            <item>
            <term>MMIO_CREATE</term>
            <term>
            Creates a new file. If the file already exists, it is truncated to zero length. For memory files, this flag indicates the end of
            the file is initially at the start of the buffer.
            </term>
            </item>
            <item>
            <term>MMIO_DELETE</term>
            <term>
            Deletes a file. If this flag is specified, szFilename should not be NULL. The return value is TRUE (cast to HMMIO) if the file
            was deleted successfully or FALSE otherwise. Do not call the mmioClose function for a file that has been deleted. If this flag
            is specified, all other flags that open files are ignored.
            </term>
            </item>
            <item>
            <term>MMIO_DENYNONE</term>
            <term>
            Opens the file without denying other processes read or write access to the file. If the file has been opened in compatibility
            mode by any other process, mmioOpen fails.
            </term>
            </item>
            <item>
            <term>MMIO_DENYREAD</term>
            <term>
            Opens the file and denies other processes read access to the file. If the file has been opened in compatibility mode or for read
            access by any other process, mmioOpen fails.
            </term>
            </item>
            <item>
            <term>MMIO_DENYWRITE</term>
            <term>
            Opens the file and denies other processes write access to the file. If the file has been opened in compatibility mode or for
            write access by any other process, mmioOpen fails.
            </term>
            </item>
            <item>
            <term>MMIO_EXCLUSIVE</term>
            <term>
            Opens the file and denies other processes read and write access to the file. If the file has been opened in any other mode for
            read or write access, even by the current process, mmioOpen fails.
            </term>
            </item>
            <item>
            <term>MMIO_EXIST</term>
            <term>
            Determines whether the specified file exists and creates a fully qualified file name from the path specified in szFilename. The
            return value is TRUE (cast to HMMIO) if the qualification was successful and the file exists or FALSE otherwise. The file is not
            opened, and the function does not return a valid multimedia file I/O file handle, so do not attempt to close the file.
            </term>
            </item>
            <item>
            <term>MMIO_GETTEMP</term>
            <term>
            Creates a temporary file name, optionally using the parameters passed in szFilename. For example, you can specify "C:F" to
            create a temporary file residing on drive C, starting with letter "F". The resulting file name is copied to the buffer pointed
            to by szFilename. The buffer must be large enough to hold at least 128 characters. If the temporary file name was created
            successfully, the return value is MMSYSERR_NOERROR (cast to HMMIO). Otherwise, the return value is MMIOERR_FILENOTFOUND
            otherwise. The file is not opened, and the function does not return a valid multimedia file I/O file handle, so do not attempt
            to close the file. This flag overrides all other flags.
            </term>
            </item>
            <item>
            <term>MMIO_PARSE</term>
            <term>
            Creates a fully qualified file name from the path specified in szFilename. The fully qualified name is copied to the buffer
            pointed to by szFilename. The buffer must be large enough to hold at least 128 characters. If the function succeeds, the return
            value is TRUE (cast to HMMIO). Otherwise, the return value is FALSE. The file is not opened, and the function does not return a
            valid multimedia file I/O file handle, so do not attempt to close the file. If this flag is specified, all flags that open files
            are ignored.
            </term>
            </item>
            <item>
            <term>MMIO_READ</term>
            <term>Opens the file for reading only. This is the default if MMIO_WRITE and MMIO_READWRITE are not specified.</term>
            </item>
            <item>
            <term>MMIO_READWRITE</term>
            <term>Opens the file for reading and writing.</term>
            </item>
            <item>
            <term>MMIO_WRITE</term>
            <term>Opens the file for writing only.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            Returns a handle of the opened file. If the file cannot be opened, the return value is <c>NULL</c>. If lpmmioinfo is not
            <c>NULL</c>, the <c>wErrorRet</c> member of the MMIOINFO structure will contain one of the following error values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMIOERR_ACCESSDENIED</term>
            <term>The file is protected and cannot be opened.</term>
            </item>
            <item>
            <term>MMIOERR_INVALIDFILE</term>
            <term>Another failure condition occurred. This is the default error for an open-file failure.</term>
            </item>
            <item>
            <term>MMIOERR_NETWORKERROR</term>
            <term>The network is not responding to the request to open a remote file.</term>
            </item>
            <item>
            <term>MMIOERR_PATHNOTFOUND</term>
            <term>The directory specification is incorrect.</term>
            </item>
            <item>
            <term>MMIOERR_SHARINGVIOLATION</term>
            <term>The file is being used by another application and is unavailable.</term>
            </item>
            <item>
            <term>MMIOERR_TOOMANYOPENFILES</term>
            <term>The number of files simultaneously open is at a maximum level. The system has run out of available file handles.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If lpmmioinfo points to an MMIOINFO structure, initialize the members of the structure as follows. All unused members must be
            set to zero, including reserved members.
            </para>
            <list type="bullet">
            <item>
            <term>
            To request that a file be opened with an installed I/O procedure, set <c>fccIOProc</c> to the four-character code of the I/O
            procedure, and set <c>pIOProc</c> to <c>NULL</c>.
            </term>
            </item>
            <item>
            <term>
            To request that a file be opened with an uninstalled I/O procedure, set IOProc to point to the I/O procedure, and set
            <c>fccIOProc</c> to <c>NULL</c>.
            </term>
            </item>
            <item>
            <term>
            To request that <c>mmioOpen</c> determine which I/O procedure to use to open the file based on the file name contained in
            szFilename, set <c>fccIOProc</c> and <c>pIOProc</c> to <c>NULL</c>. This is the default behavior if no MMIOINFO structure is specified.
            </term>
            </item>
            <item>
            <term>
            To open a memory file using an internally allocated and managed buffer, set <c>pchBuffer</c> to <c>NULL</c>, <c>fccIOProc</c> to
            FOURCC_MEM, <c>cchBuffer</c> to the initial size of the buffer, and <c>adwInfo</c> to the incremental expansion size of the
            buffer. This memory file will automatically be expanded in increments of the number of bytes specified in <c>adwInfo</c> when
            necessary. Specify the MMIO_CREATE flag for the dwOpenFlags parameter to initially set the end of the file to be the beginning
            of the buffer.
            </term>
            </item>
            <item>
            <term>
            To open a memory file using an application-supplied buffer, set <c>pchBuffer</c> to point to the memory buffer, <c>fccIOProc</c>
            to FOURCC_MEM, <c>cchBuffer</c> to the size of the buffer, and <c>adwInfo</c> to the incremental expansion size of the buffer.
            The expansion size in <c>adwInfo</c> should be nonzero only if <c>pchBuffer</c> is a pointer obtained by calling the GlobalAlloc
            and GlobalLock functions; in this case, the GlobalReAlloc function will be called to expand the buffer. In other words, if
            <c>pchBuffer</c> points to a local or global array or a block of memory in the local heap, <c>adwInfo</c> must be zero. Specify
            the MMIO_CREATE flag for the dwOpenFlags parameter to initially set the end of the file to be the beginning of the buffer.
            Otherwise, the entire block of memory is considered readable.
            </term>
            </item>
            <item>
            <term>
            To use a currently open standard file handle (that is, a file handle that does not have the <c>HMMIO</c> type) with multimedia
            file I/O services, set <c>fccIOProc</c> to FOURCC_DOS, <c>pchBuffer</c> to <c>NULL</c>, and <c>adwInfo</c> to the standard file
            handle. Offsets within the file will be relative to the beginning of the file and are not related to the position in the
            standard file at the time <c>mmioOpen</c> is called; the initial multimedia file I/O offset will be the same as the offset in
            the standard file when <c>mmioOpen</c> is called. To close the multimedia file I/O file handle without closing the standard file
            handle, pass the MMIO_FHOPEN flag to mmioClose.
            </term>
            </item>
            </list>
            <para>
            You must call mmioClose to close a file opened by using <c>mmioOpen</c>. Open files are not automatically closed when an
            application exits.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioOpen(System.Text.StringBuilder,System.IntPtr,Vanara.PInvoke.WinMm.MMIO)">
            <summary>
            <para>
            The <c>mmioOpen</c> function opens a file for unbuffered or buffered I/O; creates a file; deletes a file; or checks whether a
            file exists. The file can be a standard file, a memory file, or an element of a custom storage system. The handle returned by
            mmioOpen is not a standard file handle; do not use it with any file I/O functions other than multimedia file I/O functions.
            </para>
            <para><c>Note</c> This function is deprecated. Applications should call CreateFile to create or open files.</para>
            </summary>
            <param name="pszFileName">
            <para>
            Pointer to a buffer that contains the name of the file. If no I/O procedure is specified to open the file, the file name
            determines how the file is opened, as follows:
            </para>
            <list type="bullet">
            <item>
            <term>
            If the file name does not contain a plus sign (+), it is assumed to be the name of a standard file (that is, a file whose type
            is not <c>HMMIO</c>).
            </term>
            </item>
            <item>
            <term>
            If the file name is of the form EXAMPLE.EXT+ABC, the extension EXT is assumed to identify an installed I/O procedure which is
            called to perform I/O on the file. For more information, see mmioInstallIOProc.
            </term>
            </item>
            <item>
            <term>
            If the file name is <c>NULL</c> and no I/O procedure is given, the <c>adwInfo</c> member of the MMIOINFO structure is assumed to
            be the standard (non- <c>HMMIO</c>) file handle of a currently open file.
            </term>
            </item>
            </list>
            <para>The file name should not be longer than 128 characters, including the terminating NULL character.</para>
            <para>When opening a memory file, set szFilename to <c>NULL</c>.</para>
            </param>
            <param name="pmmioinfo">
            Pointer to an MMIOINFO structure containing extra parameters used by <c>mmioOpen</c>. Unless you are opening a memory file,
            specifying the size of a buffer for buffered I/O, or specifying an uninstalled I/O procedure to open a file, this parameter
            should be <c>NULL</c>. If this parameter is not <c>NULL</c>, all unused members of the <c>MMIOINFO</c> structure it references
            must be set to zero, including the reserved members.
            </param>
            <param name="fdwOpen">
            <para>
            Flags for the open operation. The MMIO_READ, MMIO_WRITE, and MMIO_READWRITE flags are mutually exclusive – only one should be
            specified. The MMIO_COMPAT, MMIO_EXCLUSIVE, MMIO_DENYWRITE, MMIO_DENYREAD, and MMIO_DENYNONE flags are file-sharing flags. The
            following values are defined.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MMIO_ALLOCBUF</term>
            <term>
            Opens a file for buffered I/O. To allocate a buffer larger or smaller than the default buffer size (8K, defined as
            MMIO_DEFAULTBUFFER), set the cchBuffer member of the MMIOINFO structure to the desired buffer size. If cchBuffer is zero, the
            default buffer size is used. If you are providing your own I/O buffer, this flag should not be used.
            </term>
            </item>
            <item>
            <term>MMIO_COMPAT</term>
            <term>
            Opens the file with compatibility mode, allowing any process on a given machine to open the file any number of times. If the
            file has been opened with any of the other sharing modes, mmioOpen fails.
            </term>
            </item>
            <item>
            <term>MMIO_CREATE</term>
            <term>
            Creates a new file. If the file already exists, it is truncated to zero length. For memory files, this flag indicates the end of
            the file is initially at the start of the buffer.
            </term>
            </item>
            <item>
            <term>MMIO_DELETE</term>
            <term>
            Deletes a file. If this flag is specified, szFilename should not be NULL. The return value is TRUE (cast to HMMIO) if the file
            was deleted successfully or FALSE otherwise. Do not call the mmioClose function for a file that has been deleted. If this flag
            is specified, all other flags that open files are ignored.
            </term>
            </item>
            <item>
            <term>MMIO_DENYNONE</term>
            <term>
            Opens the file without denying other processes read or write access to the file. If the file has been opened in compatibility
            mode by any other process, mmioOpen fails.
            </term>
            </item>
            <item>
            <term>MMIO_DENYREAD</term>
            <term>
            Opens the file and denies other processes read access to the file. If the file has been opened in compatibility mode or for read
            access by any other process, mmioOpen fails.
            </term>
            </item>
            <item>
            <term>MMIO_DENYWRITE</term>
            <term>
            Opens the file and denies other processes write access to the file. If the file has been opened in compatibility mode or for
            write access by any other process, mmioOpen fails.
            </term>
            </item>
            <item>
            <term>MMIO_EXCLUSIVE</term>
            <term>
            Opens the file and denies other processes read and write access to the file. If the file has been opened in any other mode for
            read or write access, even by the current process, mmioOpen fails.
            </term>
            </item>
            <item>
            <term>MMIO_EXIST</term>
            <term>
            Determines whether the specified file exists and creates a fully qualified file name from the path specified in szFilename. The
            return value is TRUE (cast to HMMIO) if the qualification was successful and the file exists or FALSE otherwise. The file is not
            opened, and the function does not return a valid multimedia file I/O file handle, so do not attempt to close the file.
            </term>
            </item>
            <item>
            <term>MMIO_GETTEMP</term>
            <term>
            Creates a temporary file name, optionally using the parameters passed in szFilename. For example, you can specify "C:F" to
            create a temporary file residing on drive C, starting with letter "F". The resulting file name is copied to the buffer pointed
            to by szFilename. The buffer must be large enough to hold at least 128 characters. If the temporary file name was created
            successfully, the return value is MMSYSERR_NOERROR (cast to HMMIO). Otherwise, the return value is MMIOERR_FILENOTFOUND
            otherwise. The file is not opened, and the function does not return a valid multimedia file I/O file handle, so do not attempt
            to close the file. This flag overrides all other flags.
            </term>
            </item>
            <item>
            <term>MMIO_PARSE</term>
            <term>
            Creates a fully qualified file name from the path specified in szFilename. The fully qualified name is copied to the buffer
            pointed to by szFilename. The buffer must be large enough to hold at least 128 characters. If the function succeeds, the return
            value is TRUE (cast to HMMIO). Otherwise, the return value is FALSE. The file is not opened, and the function does not return a
            valid multimedia file I/O file handle, so do not attempt to close the file. If this flag is specified, all flags that open files
            are ignored.
            </term>
            </item>
            <item>
            <term>MMIO_READ</term>
            <term>Opens the file for reading only. This is the default if MMIO_WRITE and MMIO_READWRITE are not specified.</term>
            </item>
            <item>
            <term>MMIO_READWRITE</term>
            <term>Opens the file for reading and writing.</term>
            </item>
            <item>
            <term>MMIO_WRITE</term>
            <term>Opens the file for writing only.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            Returns a handle of the opened file. If the file cannot be opened, the return value is <c>NULL</c>. If lpmmioinfo is not
            <c>NULL</c>, the <c>wErrorRet</c> member of the MMIOINFO structure will contain one of the following error values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMIOERR_ACCESSDENIED</term>
            <term>The file is protected and cannot be opened.</term>
            </item>
            <item>
            <term>MMIOERR_INVALIDFILE</term>
            <term>Another failure condition occurred. This is the default error for an open-file failure.</term>
            </item>
            <item>
            <term>MMIOERR_NETWORKERROR</term>
            <term>The network is not responding to the request to open a remote file.</term>
            </item>
            <item>
            <term>MMIOERR_PATHNOTFOUND</term>
            <term>The directory specification is incorrect.</term>
            </item>
            <item>
            <term>MMIOERR_SHARINGVIOLATION</term>
            <term>The file is being used by another application and is unavailable.</term>
            </item>
            <item>
            <term>MMIOERR_TOOMANYOPENFILES</term>
            <term>The number of files simultaneously open is at a maximum level. The system has run out of available file handles.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If lpmmioinfo points to an MMIOINFO structure, initialize the members of the structure as follows. All unused members must be
            set to zero, including reserved members.
            </para>
            <list type="bullet">
            <item>
            <term>
            To request that a file be opened with an installed I/O procedure, set <c>fccIOProc</c> to the four-character code of the I/O
            procedure, and set <c>pIOProc</c> to <c>NULL</c>.
            </term>
            </item>
            <item>
            <term>
            To request that a file be opened with an uninstalled I/O procedure, set IOProc to point to the I/O procedure, and set
            <c>fccIOProc</c> to <c>NULL</c>.
            </term>
            </item>
            <item>
            <term>
            To request that <c>mmioOpen</c> determine which I/O procedure to use to open the file based on the file name contained in
            szFilename, set <c>fccIOProc</c> and <c>pIOProc</c> to <c>NULL</c>. This is the default behavior if no MMIOINFO structure is specified.
            </term>
            </item>
            <item>
            <term>
            To open a memory file using an internally allocated and managed buffer, set <c>pchBuffer</c> to <c>NULL</c>, <c>fccIOProc</c> to
            FOURCC_MEM, <c>cchBuffer</c> to the initial size of the buffer, and <c>adwInfo</c> to the incremental expansion size of the
            buffer. This memory file will automatically be expanded in increments of the number of bytes specified in <c>adwInfo</c> when
            necessary. Specify the MMIO_CREATE flag for the dwOpenFlags parameter to initially set the end of the file to be the beginning
            of the buffer.
            </term>
            </item>
            <item>
            <term>
            To open a memory file using an application-supplied buffer, set <c>pchBuffer</c> to point to the memory buffer, <c>fccIOProc</c>
            to FOURCC_MEM, <c>cchBuffer</c> to the size of the buffer, and <c>adwInfo</c> to the incremental expansion size of the buffer.
            The expansion size in <c>adwInfo</c> should be nonzero only if <c>pchBuffer</c> is a pointer obtained by calling the GlobalAlloc
            and GlobalLock functions; in this case, the GlobalReAlloc function will be called to expand the buffer. In other words, if
            <c>pchBuffer</c> points to a local or global array or a block of memory in the local heap, <c>adwInfo</c> must be zero. Specify
            the MMIO_CREATE flag for the dwOpenFlags parameter to initially set the end of the file to be the beginning of the buffer.
            Otherwise, the entire block of memory is considered readable.
            </term>
            </item>
            <item>
            <term>
            To use a currently open standard file handle (that is, a file handle that does not have the <c>HMMIO</c> type) with multimedia
            file I/O services, set <c>fccIOProc</c> to FOURCC_DOS, <c>pchBuffer</c> to <c>NULL</c>, and <c>adwInfo</c> to the standard file
            handle. Offsets within the file will be relative to the beginning of the file and are not related to the position in the
            standard file at the time <c>mmioOpen</c> is called; the initial multimedia file I/O offset will be the same as the offset in
            the standard file when <c>mmioOpen</c> is called. To close the multimedia file I/O file handle without closing the standard file
            handle, pass the MMIO_FHOPEN flag to mmioClose.
            </term>
            </item>
            </list>
            <para>
            You must call mmioClose to close a file opened by using <c>mmioOpen</c>. Open files are not automatically closed when an
            application exits.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioRead(Vanara.PInvoke.WinMm.HMMIO,System.Byte[],System.Int32)">
            <summary>The <c>mmioRead</c> function reads a specified number of bytes from a file opened by using the mmioOpen function.</summary>
            <param name="hmmio">File handle of the file to be read.</param>
            <param name="pch">Pointer to a buffer to contain the data read from the file.</param>
            <param name="cch">Number of bytes to read from the file.</param>
            <returns>
            Returns the number of bytes actually read. If the end of the file has been reached and no more bytes can be read, the return
            value is 0. If there is an error reading from the file, the return value is –1.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioRename(System.String,System.String,Vanara.PInvoke.WinMm.MMIOINFO@,System.UInt32)">
            <summary>The <c>mmioRename</c> function renames the specified file.</summary>
            <param name="pszFileName">Pointer to a string containing the file name of the file to rename.</param>
            <param name="pszNewFileName">Pointer to a string containing the new file name.</param>
            <param name="pmmioinfo">
            Pointer to an MMIOINFO structure containing extra parameters used by <c>mmioRename</c>. If this parameter is not <c>NULL</c>,
            all unused members of the <c>MMIOINFO</c> structure it references must be set to zero, including the reserved members.
            </param>
            <param name="fdwRename">Flags for the rename operation. This parameter should be set to zero.</param>
            <returns>
            Returns zero if the file was renamed. Otherwise, returns an error code returned from <c>mmioRename</c> or from the I/O procedure.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioRename(System.String,System.String,System.IntPtr,System.UInt32)">
            <summary>The <c>mmioRename</c> function renames the specified file.</summary>
            <param name="pszFileName">Pointer to a string containing the file name of the file to rename.</param>
            <param name="pszNewFileName">Pointer to a string containing the new file name.</param>
            <param name="pmmioinfo">
            Pointer to an MMIOINFO structure containing extra parameters used by <c>mmioRename</c>. If this parameter is not <c>NULL</c>,
            all unused members of the <c>MMIOINFO</c> structure it references must be set to zero, including the reserved members.
            </param>
            <param name="fdwRename">Flags for the rename operation. This parameter should be set to zero.</param>
            <returns>
            Returns zero if the file was renamed. Otherwise, returns an error code returned from <c>mmioRename</c> or from the I/O procedure.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioSeek(Vanara.PInvoke.WinMm.HMMIO,System.Int32,System.Int32)">
            <summary>The <c>mmioSeek</c> function changes the current file position in a file opened by using the mmioOpen function.</summary>
            <param name="hmmio">File handle of the file to seek in.</param>
            <param name="lOffset">Offset to change the file position.</param>
            <param name="iOrigin">
            <para>Flags indicating how the offset specified by lOffset is interpreted. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>SEEK_CUR</term>
            <term>Seeks to lOffset bytes from the current file position.</term>
            </item>
            <item>
            <term>SEEK_END</term>
            <term>Seeks to lOffset bytes from the end of the file.</term>
            </item>
            <item>
            <term>SEEK_SET</term>
            <term>Seeks to lOffset bytes from the beginning of the file.</term>
            </item>
            </list>
            </param>
            <returns>
            Returns the new file position, in bytes, relative to the beginning of the file. If there is an error, the return value is –1.
            </returns>
            <remarks>
            <para>
            Seeking to an invalid location in the file, such as past the end of the file, might not cause <c>mmioSeek</c> to return an
            error, but it might cause subsequent I/O operations on the file to fail.
            </para>
            <para>To locate the end of a file, call <c>mmioSeek</c> with lOffset set to zero and iOrigin set to SEEK_END.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioSendMessage(Vanara.PInvoke.WinMm.HMMIO,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>The <c>mmioSendMessage</c> function sends a message to the I/O procedure associated with the specified file.</summary>
            <param name="hmmio">File handle for a file opened by using the mmioOpen function.</param>
            <param name="uMsg">Message to send to the I/O procedure.</param>
            <param name="lParam1">Parameter for the message.</param>
            <param name="lParam2">Parameter for the message.</param>
            <returns>
            Returns a value that corresponds to the message. If the I/O procedure does not recognize the message, the return value should be zero.
            </returns>
            <remarks>
            Use this function to send custom user-defined messages. Do not use it to send the MMIOM_OPEN, MMIOM_CLOSE, MMIOM_READ,
            MMIOM_WRITE, MMIOM_WRITEFLUSH, or MMIOM_SEEK messages. Define custom messages to be greater than or equal to the MMIOM_USER constant.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioSetBuffer(Vanara.PInvoke.WinMm.HMMIO,System.Text.StringBuilder,System.Int32,System.UInt32)">
            <summary>
            The <c>mmioSetBuffer</c> function enables or disables buffered I/O, or changes the buffer or buffer size for a file opened by
            using the mmioOpen function.
            </summary>
            <param name="hmmio">File handle of the file.</param>
            <param name="pchBuffer">
            Pointer to an application-defined buffer to use for buffered I/O. If this parameter is <c>NULL</c>, <c>mmioSetBuffer</c>
            allocates an internal buffer for buffered I/O.
            </param>
            <param name="cchBuffer">
            Size, in characters, of the application-defined buffer, or the size of the buffer for <c>mmioSetBuffer</c> to allocate.
            </param>
            <param name="fuBuffer">Reserved; must be zero.</param>
            <returns>
            <para>
            Returns zero if successful or an error otherwise. If an error occurs, the file handle remains valid. The following values are defined.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMIOERR_CANNOTWRITE</term>
            <term>The contents of the old buffer could not be written to disk, so the operation was aborted.</term>
            </item>
            <item>
            <term>MMIOERR_OUTOFMEMORY</term>
            <term>The new buffer could not be allocated, probably due to a lack of available memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>To enable buffering using an internal buffer, set pchBuffer to <c>NULL</c> and cchBuffer to the desired buffer size.</para>
            <para>To supply your own buffer, set pchBuffer to point to the buffer, and set cchBuffer to the size of the buffer.</para>
            <para>To disable buffered I/O, set pchBuffer to <c>NULL</c> and cchBuffer to zero.</para>
            <para>
            If buffered I/O is already enabled using an internal buffer, you can reallocate the buffer to a different size by setting
            pchBuffer to <c>NULL</c> and cchBuffer to the new buffer size. The contents of the buffer can be changed after resizing.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioSetInfo(Vanara.PInvoke.WinMm.HMMIO,Vanara.PInvoke.WinMm.MMIOINFO@,System.UInt32)">
            <summary>
            The <c>mmioSetInfo</c> function updates the information retrieved by the mmioGetInfo function about a file opened by using the
            mmioOpen function. Use this function to terminate direct buffer access of a file opened for buffered I/O.
            </summary>
            <param name="hmmio">File handle of the file.</param>
            <param name="pmmioinfo">Pointer to an MMIOINFO structure filled with information by the mmioGetInfo function.</param>
            <param name="fuInfo">Reserved; must be zero.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            If you have written to the file I/O buffer, set the MMIO_DIRTY flag in the <c>dwFlags</c> member of the MMIOINFO structure
            before calling <c>mmioSetInfo</c> to terminate direct buffer access. Otherwise, the buffer will not get flushed to disk.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioStringToFOURCC(System.String,Vanara.PInvoke.WinMm.MMIOCONV)">
            <summary>The <c>mmioStringToFOURCC</c> function converts a null-terminated string to a four-character code.</summary>
            <param name="sz">Pointer to a null-terminated string to convert to a four-character code.</param>
            <param name="uFlags">
            <para>Flags for the conversion. The following value is defined:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MMIO_TOUPPER</term>
            <term>Converts all characters to uppercase.</term>
            </item>
            </list>
            </param>
            <returns>Returns the four-character code created from the given string.</returns>
            <remarks>
            This function copies the string to a four-character code and pads it with space characters or truncates it if necessary. It does
            not check whether the code it returns is valid.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.mmioWrite(Vanara.PInvoke.WinMm.HMMIO,System.Byte[],System.Int32)">
            <summary>The <c>mmioWrite</c> function writes a specified number of bytes to a file opened by using the mmioOpen function.</summary>
            <param name="hmmio">File handle of the file.</param>
            <param name="pch">Pointer to the buffer to be written to the file.</param>
            <param name="cch">Number of bytes to write to the file.</param>
            <returns>Returns the number of bytes actually written. If there is an error writing to the file, the return value is -1.</returns>
            <remarks>The current file position is incremented by the number of bytes written.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.OpenDriver(System.String,System.String,System.IntPtr)">
            <summary>
            Opens an instance of an installable driver and initializes the instance using either the driver's default settings or a
            driver-specific value.
            </summary>
            <param name="szDriverName">
            Address of a null-terminated, wide-character string that specifies the filename of an installable driver or the name of a
            registry value associated with the installable driver. (This value must have been previously set when the driver was installed.)
            </param>
            <param name="szSectionName">
            Address of a null-terminated, wide-character string that specifies the name of the registry key containing the registry value
            given by the lpDriverName parameter. If lpSectionName is <c>NULL</c>, the registry key is assumed to be <c>Drivers32</c>.
            </param>
            <param name="lParam2">
            32-bit driver-specific value. This value is passed as the lParam2 parameter to the DriverProc function of the installable driver.
            </param>
            <returns>Returns the handle of the installable driver instance if successful or <c>NULL</c> otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SendDriverMessage(Vanara.PInvoke.WinMm.HDRVR,Vanara.PInvoke.WinMm.DRV,System.IntPtr,System.IntPtr)">
            <summary>Sends the specified message to the installable driver.</summary>
            <param name="hDriver">
            Handle of the installable driver instance. The handle must been previously created by using the OpenDriver function.
            </param>
            <param name="message">
            <para>Driver message value. It can be a custom message value or one of these standard message values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DRV_QUERYCONFIGURE</term>
            <term>
            Queries an installable driver about whether it supports the DRV_CONFIGURE message and can display a configuration dialog box.
            </term>
            </item>
            <item>
            <term>DRV_CONFIGURE</term>
            <term>
            Notifies an installable driver that it should display a configuration dialog box. (This message should only be sent if the
            driver returns a nonzero value when the DRV_QUERYCONFIGURE message is processed.)
            </term>
            </item>
            <item>
            <term>DRV_INSTALL</term>
            <term>Notifies an installable driver that it has been successfully installed.</term>
            </item>
            <item>
            <term>DRV_REMOVE</term>
            <term>Notifies an installable driver that it is about to be removed from the system.</term>
            </item>
            </list>
            </param>
            <param name="lParam1">32-bit message-dependent information.</param>
            <param name="lParam2">32-bit message-dependent information.</param>
            <returns>Returns nonzero if successful or zero otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.sndOpenSound(System.String,System.String,System.Int32,System.IntPtr@)">
            <summary>Opens the specified sound event.</summary>
            <param name="EventName">The name of the sound event.</param>
            <param name="AppName">The application associated with the sound event.</param>
            <param name="Flags">Flags for playing the sound. The following values are defined.</param>
            <param name="FileHandle">Receives the handle to the sound.</param>
            <returns>If this function succeeds, it returns <c>S_OK</c>. Otherwise, it returns an <c>HRESULT</c> error code.</returns>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.DRVCONFIGINFO">
            <summary>Contains the registry key and value names associated with the installable driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRVCONFIGINFO.dwDCISize">
            <summary>Size of the structure, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRVCONFIGINFO.lpszDCISectionName">
            <summary>
            Address of a null-terminated, wide-character string specifying the name of the registry key associated with the driver.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.DRVCONFIGINFO.lpszDCIAliasName">
            <summary>
            Address of a null-terminated, wide-character string specifying the name of the registry value associated with the driver.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.HDRVR">
            <summary>Provides a handle to an installable driver.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HDRVR.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.HDRVR"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HDRVR.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.WinMm.HDRVR"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HDRVR.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HDRVR.op_Explicit(Vanara.PInvoke.WinMm.HDRVR)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.WinMm.HDRVR"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HDRVR.op_Implicit(System.IntPtr)~Vanara.PInvoke.WinMm.HDRVR">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.WinMm.HDRVR"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HDRVR.op_Inequality(Vanara.PInvoke.WinMm.HDRVR,Vanara.PInvoke.WinMm.HDRVR)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HDRVR.op_Equality(Vanara.PInvoke.WinMm.HDRVR,Vanara.PInvoke.WinMm.HDRVR)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HDRVR.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HDRVR.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HDRVR.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.HMMIO">
            <summary>Provides a handle to a MMIO device.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMMIO.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.HMMIO"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMMIO.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.WinMm.HMMIO"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.WinMm.HMMIO.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMMIO.op_Explicit(Vanara.PInvoke.WinMm.HMMIO)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.WinMm.HMMIO"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMMIO.op_Implicit(System.IntPtr)~Vanara.PInvoke.WinMm.HMMIO">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.WinMm.HMMIO"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMMIO.op_Inequality(Vanara.PInvoke.WinMm.HMMIO,Vanara.PInvoke.WinMm.HMMIO)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMMIO.op_Equality(Vanara.PInvoke.WinMm.HMMIO,Vanara.PInvoke.WinMm.HMMIO)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMMIO.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMMIO.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.HMMIO.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMCKINFO">
            <summary>The <c>MMCKINFO</c> structure contains information about a chunk in a RIFF file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMCKINFO.ckid">
            <summary>Chunk identifier.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMCKINFO.cksize">
            <summary>
            Size, in bytes, of the data member of the chunk. The size of the data member does not include the 4-byte chunk identifier,
            the 4-byte chunk size, or the optional pad byte at the end of the data member.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMCKINFO.fccType">
            <summary>Form type for "RIFF" chunks or the list type for "LIST" chunks.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMCKINFO.dwDataOffset">
            <summary>File offset of the beginning of the chunk's data member, relative to the beginning of the file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMCKINFO.dwFlags">
            <summary>
            <para>Flags specifying additional information about the chunk. It can be zero or the following flag:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMIO_DIRTY</term>
            <term>
            The length of the chunk might have changed and should be updated by the mmioAscend function. This flag is set when a chunk
            is created by using the mmioCreateChunk function.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMIOINFO">
            <summary>The <c>MMIOINFO</c> structure contains the current state of a file opened by using the <c>mmioOpen</c> function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.dwFlags">
            <summary>Flags specifying how a file was opened.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.fccIOProc">
            <summary>
            Four-character code identifying the file's I/O procedure. If the I/O procedure is not an installed I/O procedure, this
            member is NULL.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.pIOProc">
            <summary>Pointer to file's IO procedure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.wErrorRet">
            <summary>
            Extended error value from the mmioOpen function if it returns NULL. This member is not used to return extended error
            information from any other functions.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.hTask">
            <summary>
            Handle to a local I/O procedure. Media Control Interface (MCI) devices that perform file I/O in the background and need an
            I/O procedure can locate a local I/O procedure with this handle.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.cchBuffer">
            <summary>Size, in bytes, of the file's I/O buffer. If the file does not have an I/O buffer, this member is zero.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.pchBuffer">
            <summary>Pointer to the file's I/O buffer. If the file is unbuffered, this member is NULL.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.pchNext">
            <summary>
            Pointer to the next location in the I/O buffer to be read or written. If no more bytes can be read without calling the
            mmioAdvance or mmioRead function, this member points to the pchEndRead member. If no more bytes can be written without
            calling the mmioAdvance or mmioWrite function, this member points to the pchEndWrite member.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.pchEndRead">
            <summary>Pointer to the location that is 1 byte past the last location in the buffer that can be read.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.pchEndWrite">
            <summary>Pointer to the location that is 1 byte past the last location in the buffer that can be written.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.lBufOffset">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.lDiskOffset">
            <summary>
            Current file position, which is an offset, in bytes, from the beginning of the file. I/O procedures are responsible for
            maintaining this member.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.adwInfo">
            <summary>
            State information maintained by the I/O procedure. I/O procedures can also use these members to transfer information from
            the application to the I/O procedure when the application opens a file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.dwReserved1">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.dwReserved2">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMIOINFO.hmmio">
            <summary>
            Handle to the open file, as returned by the mmioOpen function. I/O procedures can use this handle when calling other
            multimedia file I/O functions.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.SafeHDRVR">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.WinMm.HDRVR"/> that is disposed using <see cref="M:Vanara.PInvoke.WinMm.CloseDriver(Vanara.PInvoke.WinMm.HDRVR,System.IntPtr,System.IntPtr)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SafeHDRVR.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.SafeHDRVR"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SafeHDRVR.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.WinMm.SafeHDRVR"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SafeHDRVR.op_Implicit(Vanara.PInvoke.WinMm.SafeHDRVR)~Vanara.PInvoke.WinMm.HDRVR">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.WinMm.SafeHDRVR"/> to <see cref="T:Vanara.PInvoke.WinMm.HDRVR"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.SafeHDRVR.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.WAVE_FORMAT">
            <summary>Format type.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_UNKNOWN">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_PCM">
            <summary>Waveform-audio data is PCM.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ADPCM">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_IEEE_FLOAT">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VSELP">
            <summary>Compaq Computer Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_IBM_CVSD">
            <summary>IBM Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ALAW">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MULAW">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DTS">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DRM">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_WMAVOICE9">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_WMAVOICE10">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OKI_ADPCM">
            <summary>OKI</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DVI_ADPCM">
            <summary>Intel Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_IMA_ADPCM">
            <summary>Intel Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MEDIASPACE_ADPCM">
            <summary>Videologic</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SIERRA_ADPCM">
            <summary>Sierra Semiconductor Corp</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_G723_ADPCM">
            <summary>Antex Electronics Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DIGISTD">
            <summary>DSP Solutions, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DIGIFIX">
            <summary>DSP Solutions, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DIALOGIC_OKI_ADPCM">
            <summary>Dialogic Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MEDIAVISION_ADPCM">
            <summary>Media Vision, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CU_CODEC">
            <summary>Hewlett-Packard Company</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_HP_DYN_VOICE">
            <summary>Hewlett-Packard Company</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_YAMAHA_ADPCM">
            <summary>Yamaha Corporation of America</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SONARC">
            <summary>Speech Compression</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DSPGROUP_TRUESPEECH">
            <summary>DSP Group, Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ECHOSC1">
            <summary>Echo Speech Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_AUDIOFILE_AF36">
            <summary>Virtual Music, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_APTX">
            <summary>Audio Processing Technology</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_AUDIOFILE_AF10">
            <summary>Virtual Music, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_PROSODY_1612">
            <summary>Aculab plc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_LRC">
            <summary>Merging Technologies S.A.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DOLBY_AC2">
            <summary>Dolby Laboratories</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_GSM610">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MSNAUDIO">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ANTEX_ADPCME">
            <summary>Antex Electronics Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CONTROL_RES_VQLPC">
            <summary>Control Resources Limited</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DIGIREAL">
            <summary>DSP Solutions, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DIGIADPCM">
            <summary>DSP Solutions, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CONTROL_RES_CR10">
            <summary>Control Resources Limited</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_NMS_VBXADPCM">
            <summary>Natural MicroSystems</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CS_IMAADPCM">
            <summary>Crystal Semiconductor IMA ADPCM</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ECHOSC3">
            <summary>Echo Speech Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ROCKWELL_ADPCM">
            <summary>Rockwell International</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ROCKWELL_DIGITALK">
            <summary>Rockwell International</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_XEBEC">
            <summary>Xebec Multimedia Solutions Limited</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_G721_ADPCM">
            <summary>Antex Electronics Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_G728_CELP">
            <summary>Antex Electronics Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MSG723">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_INTEL_G723_1">
            <summary>Intel Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_INTEL_G729">
            <summary>Intel Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SHARP_G726">
            <summary>Sharp</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MPEG">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_RT24">
            <summary>InSoft, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_PAC">
            <summary>InSoft, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MPEGLAYER3">
            <summary>ISO/MPEG Layer3 Format Tag</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_LUCENT_G723">
            <summary>Lucent Technologies</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CIRRUS">
            <summary>Cirrus Logic</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ESPCM">
            <summary>ESS Technology</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CANOPUS_ATRAC">
            <summary>Canopus, co., Ltd.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_G726_ADPCM">
            <summary>APICOM</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_G722_ADPCM">
            <summary>APICOM</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DSAT">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DSAT_DISPLAY">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_BYTE_ALIGNED">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_AC8">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_AC10">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_AC16">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_AC20">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_RT24">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_RT29">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_RT29HW">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_VR12">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_VR18">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_TQ40">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_SC3">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_SC3_1">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SOFTSOUND">
            <summary>Softsound, Ltd.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_TQ60">
            <summary>Voxware Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MSRT24">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_G729A">
            <summary>AT&amp;T Labs, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MVI_MVI2">
            <summary>Motion Pixels</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DF_G726">
            <summary>DataFusion Systems (Pty) (Ltd)</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DF_GSM610">
            <summary>DataFusion Systems (Pty) (Ltd)</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ISIAUDIO">
            <summary>Iterated Systems, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ONLIVE">
            <summary>OnLive! Technologies, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MULTITUDE_FT_SX20">
            <summary>Multitude Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_INFOCOM_ITS_G721_ADPCM">
            <summary>Infocom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CONVEDIA_G729">
            <summary>Convedia Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CONGRUENCY">
            <summary>Congruency Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SBC24">
            <summary>Siemens Business Communications Sys</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DOLBY_AC3_SPDIF">
            <summary>Sonic Foundry</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MEDIASONIC_G723">
            <summary>MediaSonic</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_PROSODY_8KBPS">
            <summary>Aculab plc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ZYXEL_ADPCM">
            <summary>ZyXEL Communications, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_PHILIPS_LPCBB">
            <summary>Philips Speech Processing</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_PACKED">
            <summary>Studer Professional Audio AG</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MALDEN_PHONYTALK">
            <summary>Malden Electronics Ltd.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_RACAL_RECORDER_GSM">
            <summary>Racal recorders</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_RACAL_RECORDER_G720_A">
            <summary>Racal recorders</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_RACAL_RECORDER_G723_1">
            <summary>Racal recorders</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_RACAL_RECORDER_TETRA_ACELP">
            <summary>Racal recorders</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_NEC_AAC">
            <summary>NEC Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_RAW_AAC1">
            <summary>For Raw AAC, with format block AudioSpecificConfig() (as defined by MPEG-4), that follows WAVEFORMATEX</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_RHETOREX_ADPCM">
            <summary>Rhetorex Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_IRAT">
            <summary>BeCubed Software Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VIVO_G723">
            <summary>Vivo Software</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VIVO_SIREN">
            <summary>Vivo Software</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_PHILIPS_CELP">
            <summary>Philips Speech Processing</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_PHILIPS_GRUNDIG">
            <summary>Philips Speech Processing</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DIGITAL_G723">
            <summary>Digital Equipment Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SANYO_LD_ADPCM">
            <summary>Sanyo Electric Co., Ltd.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SIPROLAB_ACEPLNET">
            <summary>Sipro Lab Telecom Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SIPROLAB_ACELP4800">
            <summary>Sipro Lab Telecom Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SIPROLAB_ACELP8V3">
            <summary>Sipro Lab Telecom Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SIPROLAB_G729">
            <summary>Sipro Lab Telecom Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SIPROLAB_G729A">
            <summary>Sipro Lab Telecom Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SIPROLAB_KELVIN">
            <summary>Sipro Lab Telecom Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOICEAGE_AMR">
            <summary>VoiceAge Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_G726ADPCM">
            <summary>Dictaphone Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DICTAPHONE_CELP68">
            <summary>Dictaphone Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DICTAPHONE_CELP54">
            <summary>Dictaphone Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_QUALCOMM_PUREVOICE">
            <summary>Qualcomm, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_QUALCOMM_HALFRATE">
            <summary>Qualcomm, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_TUBGSM">
            <summary>Ring Zero Systems, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MSAUDIO1">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_WMAUDIO2">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_WMAUDIO3">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_WMAUDIO_LOSSLESS">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_WMASPDIF">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_UNISYS_NAP_ADPCM">
            <summary>Unisys Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_UNISYS_NAP_ULAW">
            <summary>Unisys Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_UNISYS_NAP_ALAW">
            <summary>Unisys Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_UNISYS_NAP_16K">
            <summary>Unisys Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SYCOM_ACM_SYC008">
            <summary>SyCom Technologies</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SYCOM_ACM_SYC701_G726L">
            <summary>SyCom Technologies</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SYCOM_ACM_SYC701_CELP54">
            <summary>SyCom Technologies</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SYCOM_ACM_SYC701_CELP68">
            <summary>SyCom Technologies</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_KNOWLEDGE_ADVENTURE_ADPCM">
            <summary>Knowledge Adventure, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_FRAUNHOFER_IIS_MPEG2_AAC">
            <summary>Fraunhofer IIS</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DTS_DS">
            <summary>Digital Theatre Systems, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CREATIVE_ADPCM">
            <summary>Creative Labs, Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CREATIVE_FASTSPEECH8">
            <summary>Creative Labs, Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CREATIVE_FASTSPEECH10">
            <summary>Creative Labs, Inc</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_UHER_ADPCM">
            <summary>UHER informatic GmbH</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ULEAD_DV_AUDIO">
            <summary>Ulead Systems, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ULEAD_DV_AUDIO_1">
            <summary>Ulead Systems, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_QUARTERDECK">
            <summary>Quarterdeck Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ILINK_VC">
            <summary>I-link Worldwide</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_RAW_SPORT">
            <summary>Aureal Semiconductor</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ESST_AC3">
            <summary>ESS Technology, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_GENERIC_PASSTHRU">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_IPI_HSX">
            <summary>Interactive Products, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_IPI_RPELP">
            <summary>Interactive Products, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CS2">
            <summary>Consistent Software</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SONY_SCX">
            <summary>Sony Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SONY_SCY">
            <summary>Sony Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SONY_ATRAC3">
            <summary>Sony Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SONY_SPC">
            <summary>Sony Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_TELUM_AUDIO">
            <summary>Telum Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_TELUM_IA_AUDIO">
            <summary>Telum Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_NORCOM_VOICE_SYSTEMS_ADPCM">
            <summary>Norcom Electronics Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_FM_TOWNS_SND">
            <summary>Fujitsu Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MICRONAS">
            <summary>Micronas Semiconductors, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MICRONAS_CELP833">
            <summary>Micronas Semiconductors, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_BTV_DIGITAL">
            <summary>Brooktree Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_INTEL_MUSIC_CODER">
            <summary>Intel Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_INDEO_AUDIO">
            <summary>Ligos</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_QDESIGN_MUSIC">
            <summary>QDesign Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ON2_VP7_AUDIO">
            <summary>On2 Technologies</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ON2_VP6_AUDIO">
            <summary>On2 Technologies</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VME_VMPCM">
            <summary>AT&amp;T Labs, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_TPC">
            <summary>AT&amp;T Labs, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_LIGHTWAVE_LOSSLESS">
            <summary>Clearjump</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OLIGSM">
            <summary>Ing C. Olivetti &amp; C., S.p.A.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OLIADPCM">
            <summary>Ing C. Olivetti &amp; C., S.p.A.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OLICELP">
            <summary>Ing C. Olivetti &amp; C., S.p.A.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OLISBC">
            <summary>Ing C. Olivetti &amp; C., S.p.A.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OLIOPR">
            <summary>Ing C. Olivetti &amp; C., S.p.A.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_LH_CODEC">
            <summary>Lernout &amp; Hauspie</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_LH_CODEC_CELP">
            <summary>Lernout &amp; Hauspie</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_LH_CODEC_SBC8">
            <summary>Lernout &amp; Hauspie</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_LH_CODEC_SBC12">
            <summary>Lernout &amp; Hauspie</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_LH_CODEC_SBC16">
            <summary>Lernout &amp; Hauspie</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_NORRIS">
            <summary>Norris Communications, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ISIAUDIO_2">
            <summary>ISIAudio</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SOUNDSPACE_MUSICOMPRESS">
            <summary>AT&amp;T Labs, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MPEG_ADTS_AAC">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MPEG_RAW_AAC">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MPEG_LOAS">
            <summary>Microsoft Corporation (MPEG-4 Audio Transport Streams (LOAS/LATM)</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_NOKIA_MPEG_ADTS_AAC">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_NOKIA_MPEG_RAW_AAC">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VODAFONE_MPEG_ADTS_AAC">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VODAFONE_MPEG_RAW_AAC">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MPEG_HEAAC">
            <summary>
            Microsoft Corporation (MPEG-2 AAC or MPEG-4 HE-AAC v1/v2 streams with any payload (ADTS, ADIF, LOAS/LATM, RAW). Format block
            includes MP4 AudioSpecificConfig() -- see HEAACWAVEFORMAT below
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOXWARE_RT24_SPEECH">
            <summary>Voxware Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SONICFOUNDRY_LOSSLESS">
            <summary>Sonic Foundry</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_INNINGS_TELECOM_ADPCM">
            <summary>Innings Telecom Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_LUCENT_SX8300P">
            <summary>Lucent Technologies</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_LUCENT_SX5363S">
            <summary>Lucent Technologies</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CUSEEME">
            <summary>CUSeeMe</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_NTCSOFT_ALF2CM_ACM">
            <summary>NTCSoft</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DVM">
            <summary>FAST Multimedia AG</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DTS2">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MAKEAVIS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DIVIO_MPEG4_AAC">
            <summary>Divio, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_NOKIA_ADAPTIVE_MULTIRATE">
            <summary>Nokia</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DIVIO_G726">
            <summary>Divio, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_LEAD_SPEECH">
            <summary>LEAD Technologies</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_LEAD_VORBIS">
            <summary>LEAD Technologies</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_WAVPACK_AUDIO">
            <summary>xiph.org</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ALAC">
            <summary>Apple Lossless</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OGG_VORBIS_MODE_1">
            <summary>Ogg Vorbis</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OGG_VORBIS_MODE_2">
            <summary>Ogg Vorbis</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OGG_VORBIS_MODE_3">
            <summary>Ogg Vorbis</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OGG_VORBIS_MODE_1_PLUS">
            <summary>Ogg Vorbis</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OGG_VORBIS_MODE_2_PLUS">
            <summary>Ogg Vorbis</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OGG_VORBIS_MODE_3_PLUS">
            <summary>Ogg Vorbis</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_3COM_NBX">
            <summary>3COM Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_OPUS">
            <summary>Opus</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_FAAD_AAC">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_AMR_NB">
            <summary>AMR Narrowband</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_AMR_WB">
            <summary>AMR Wideband</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_AMR_WP">
            <summary>AMR Wideband Plus</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_GSM_AMR_CBR">
            <summary>GSMA/3GPP</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_GSM_AMR_VBR_SID">
            <summary>GSMA/3GPP</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_COMVERSE_INFOSYS_G723_1">
            <summary>Comverse Infosys</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_COMVERSE_INFOSYS_AVQSBC">
            <summary>Comverse Infosys</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_COMVERSE_INFOSYS_SBC">
            <summary>Comverse Infosys</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SYMBOL_G729_A">
            <summary>Symbol Technologies</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOICEAGE_AMR_WB">
            <summary>VoiceAge Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_INGENIENT_G726">
            <summary>Ingenient Technologies, Inc.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_MPEG4_AAC">
            <summary>ISO/MPEG-4</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ENCORE_G726">
            <summary>Encore Software</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_ZOLL_ASAO">
            <summary>ZOLL Medical Corp.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_SPEEX_VOICE">
            <summary>xiph.org</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VIANIX_MASC">
            <summary>Vianix LLC</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_WM9_SPECTRUM_ANALYZER">
            <summary>Microsoft</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_WMF_SPECTRUM_ANAYZER">
            <summary>Microsoft</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_GSM_610">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_GSM_620">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_GSM_660">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_GSM_690">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_GSM_ADAPTIVE_MULTIRATE_WB">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_POLYCOM_G722">
            <summary>Polycom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_POLYCOM_G728">
            <summary>Polycom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_POLYCOM_G729_A">
            <summary>Polycom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_POLYCOM_SIREN">
            <summary>Polycom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_GLOBAL_IP_ILBC">
            <summary>Global IP</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_RADIOTIME_TIME_SHIFT_RADIO">
            <summary>RadioTime</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_NICE_ACA">
            <summary>Nice Systems</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_NICE_ADPCM">
            <summary>Nice Systems</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOCORD_G721">
            <summary>Vocord Telecom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOCORD_G726">
            <summary>Vocord Telecom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOCORD_G722_1">
            <summary>Vocord Telecom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOCORD_G728">
            <summary>Vocord Telecom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOCORD_G729">
            <summary>Vocord Telecom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOCORD_G729_A">
            <summary>Vocord Telecom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOCORD_G723_1">
            <summary>Vocord Telecom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_VOCORD_LBC">
            <summary>Vocord Telecom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_NICE_G728">
            <summary>Nice Systems</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_FRACE_TELECOM_G729">
            <summary>France Telecom</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_CODIAN">
            <summary>CODIAN</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_FLAC">
            <summary>flac.sourceforge.net</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_EXTENSIBLE">
            <summary>Microsoft</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVE_FORMAT.WAVE_FORMAT_DEVELOPMENT">
            <summary>
            New wave format development should be based on the WAVEFORMATEXTENSIBLE structure. WAVEFORMATEXTENSIBLE allows you to avoid
            having to register a new format tag with Microsoft. However, if you must still define a new format tag, the
            WAVE_FORMAT_DEVELOPMENT format tag can be used during the development phase of a new wave format. Before shipping, you MUST
            acquire an official format tag from Microsoft.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.PCMWAVEFORMAT">
            <summary>
            The <c>PCMWAVEFORMAT</c> structure describes the data format for PCM waveform-audio data. This structure has been superseded by
            the WAVEFORMATEX structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.PCMWAVEFORMAT.wf">
            <summary>A WAVEFORMAT structure containing general information about the format of the data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.PCMWAVEFORMAT.wBitsPerSample">
            <summary>Number of bits per sample.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.WAVEFILTER">
            <summary>
            The <c>WAVEFILTER</c> structure defines a filter for waveform-audio data. Only filter information common to all waveform-audio
            data filters is included in this structure. For filters that require additional information, this structure is included as the
            first member in another structure along with the additional information.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFILTER.cbStruct">
            <summary>
            Size, in bytes, of the <c>WAVEFILTER</c> structure. The size specified in this member must be large enough to contain the
            base <c>WAVEFILTER</c> structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFILTER.dwFilterTag">
            <summary>Waveform-audio filter type. Filter tags are registered with Microsoft Corporation for various filter algorithms.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFILTER.fdwFilter">
            <summary>
            Flags for the <c>dwFilterTag</c> member. The flags defined for this member are universal to all filters. Currently, no flags
            are defined.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFILTER.dwReserved1">
            <summary>Reserved for system use; should not be examined or modified by an application.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.WAVEFORMAT">
            <summary>
            The <c>WAVEFORMAT</c> structure describes the format of waveform-audio data. Only format information common to all
            waveform-audio data formats is included in this structure. This structure has been superseded by the WAVEFORMATEX structure.
            </summary>
            <remarks>
            For formats that require additional information, this structure is included as a member in another structure along with the
            additional information.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMAT.wFormatTag">
            <summary>
            <para>Format type. The following type is defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>WAVE_FORMAT_PCM</term>
            <term>Waveform-audio data is PCM.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMAT.nChannels">
            <summary>Number of channels in the waveform-audio data. Mono data uses one channel and stereo data uses two channels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMAT.nSamplesPerSec">
            <summary>Sample rate, in samples per second.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMAT.nAvgBytesPerSec">
            <summary>
            Required average data transfer rate, in bytes per second. For example, 16-bit stereo at 44.1 kHz has an average data rate of
            176,400 bytes per second (2 channels — 2 bytes per sample per channel — 44,100 samples per second).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.WAVEFORMAT.nBlockAlign">
            <summary>
            Block alignment, in bytes. The block alignment is the minimum atomic unit of data. For PCM data, the block alignment is the
            number of bytes used by a single sample, including data for both channels if the data is stereo. For example, the block
            alignment for 16-bit stereo PCM is 4 bytes (2 channels — 2 bytes per sample).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MAX_JOYSTICKOEMVXDNAME">
            <summary>max oem vxd name length (including NULL)</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MAXERRORLENGTH">
            <summary>max error text length (including NULL)</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MAXPNAMELEN">
            <summary>max product name length (including NULL)</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MM_MICROSOFT">
            <summary>Microsoft Corporation</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.DRVCALLBACK">
            <summary>
            The <c>DRVCALLBACK</c> function is the callback function used with the waveform-audio input device. This function is a
            placeholder for the application-defined function name. The address of this function can be specified in the callback-address
            parameter of the <c>waveInOpen</c> function.
            </summary>
            <param name="hdrvr">Handle to the waveform-audio device associated with the callback function.</param>
            <param name="uMsg">
            <para>Waveform-audio input message. It can be one of the following messages.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WIM_CLOSE</term>
            <term>Sent when the device is closed using the waveInClose function.</term>
            </item>
            <item>
            <term>WIM_DATA</term>
            <term>Sent when the device driver is finished with a data block sent using the waveInAddBuffer function.</term>
            </item>
            <item>
            <term>WIM_OPEN</term>
            <term>Sent when the device is opened using the waveInOpen function.</term>
            </item>
            </list>
            </param>
            <param name="dwUser">User instance data specified with <c>waveInOpen</c>.</param>
            <param name="dwParam1">Message parameter.</param>
            <param name="dwParam2">Message parameter.</param>
            <returns>This function does not return a value.</returns>
            <remarks>
            Applications should not call any system-defined functions from inside a callback function, except for
            <c>EnterCriticalSection</c>, <c>LeaveCriticalSection</c>, <c>midiOutLongMsg</c>, <c>midiOutShortMsg</c>,
            <c>OutputDebugString</c>, <c>PostMessage</c>, <c>PostThreadMessage</c>, <c>SetEvent</c>, <c>timeGetSystemTime</c>,
            <c>timeGetTime</c>, <c>timeKillEvent</c>, and <c>timeSetEvent.</c> Calling other wave functions will cause deadlock.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.CALLBACK_FLAGS">
            <summary>
            Flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and midiOutOpen() to specify the type of the dwCallback parameter.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.CALLBACK_FLAGS.CALLBACK_NULL">
            <summary>No callback mechanism. This is the default setting.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.CALLBACK_FLAGS.CALLBACK_WINDOW">
            <summary>The dwCallback parameter is a window handle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.CALLBACK_FLAGS.CALLBACK_TASK">
            <summary>The dwCallback parameter is a task handle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.CALLBACK_FLAGS.CALLBACK_FUNCTION">
            <summary>The dwCallback parameter is a callback procedure address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.CALLBACK_FLAGS.CALLBACK_THREAD">
            <summary>The dwCallback parameter is a thread identifier.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.CALLBACK_FLAGS.CALLBACK_EVENT">
            <summary>The dwCallback parameter is an event handle.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMPRODID">
            <summary>Microsoft Corporation Product Identifiers</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMPRODID.MM_MIDI_MAPPER">
            <summary>MIDI Mapper</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMPRODID.MM_WAVE_MAPPER">
            <summary>Wave Mapper</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMPRODID.MM_SNDBLST_MIDIOUT">
            <summary>Sound Blaster MIDI output port</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMPRODID.MM_SNDBLST_MIDIIN">
            <summary>Sound Blaster MIDI input port</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMPRODID.MM_SNDBLST_SYNTH">
            <summary>Sound Blaster internal synthesizer</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMPRODID.MM_SNDBLST_WAVEOUT">
            <summary>Sound Blaster waveform output</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMPRODID.MM_SNDBLST_WAVEIN">
            <summary>Sound Blaster waveform input</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMPRODID.MM_ADLIB">
            <summary>Ad Lib-compatible synthesizer</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMPRODID.MM_MPU401_MIDIOUT">
            <summary>MPU401-compatible MIDI output port</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMPRODID.MM_MPU401_MIDIIN">
            <summary>MPU401-compatible MIDI input port</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMPRODID.MM_PC_JOYSTICK">
            <summary>Joystick adapter</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMRESULT">
            <summary>Multimedia function result codes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_NOERROR">
            <summary>no error</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_ERROR">
            <summary>unspecified error</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_BADDEVICEID">
            <summary>Specified device identifier is out of range.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_NOTENABLED">
            <summary>driver failed enable</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_ALLOCATED">
            <summary>Specified resource is already allocated.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_INVALHANDLE">
            <summary>Specified device handle is invalid.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_NODRIVER">
            <summary>No device driver is present.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_NOMEM">
            <summary>Unable to allocate or lock memory.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_NOTSUPPORTED">
            <summary>function isn't supported</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_BADERRNUM">
            <summary>Specified error number is out of range.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_INVALFLAG">
            <summary>invalid flag passed</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_INVALPARAM">
            <summary>invalid parameter passed</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_HANDLEBUSY">
            <summary>handle being used simultaneously on another thread (eg callback)</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_INVALIDALIAS">
            <summary>specified alias not found</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_BADDB">
            <summary>bad registry database</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_KEYNOTFOUND">
            <summary>registry key not found</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_READERROR">
            <summary>registry read error</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_WRITEERROR">
            <summary>registry write error</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_DELETEERROR">
            <summary>registry delete error</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_VALNOTFOUND">
            <summary>registry value not found</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_NODRIVERCB">
            <summary>driver does not call DriverCallback</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MMSYSERR_MOREDATA">
            <summary>more data to be returned</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.WAVERR_BADFORMAT">
            <summary>Attempted to open with an unsupported waveform-audio format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.WAVERR_STILLPLAYING">
            <summary>There are still buffers in the queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.WAVERR_UNPREPARED">
            <summary>The buffer pointed to by the pwh parameter hasn't been prepared.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.WAVERR_SYNC">
            <summary>device is synchronous</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.WAVERR_LASTERROR">
            <summary>last error in range</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIDIERR_UNPREPARED">
            <summary>header not prepared</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIDIERR_STILLPLAYING">
            <summary>still something playing</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIDIERR_NOMAP">
            <summary>no configured instruments</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIDIERR_NOTREADY">
            <summary>hardware is still busy</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIDIERR_NODEVICE">
            <summary>port no longer connected</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIDIERR_INVALIDSETUP">
            <summary>invalid MIF</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIDIERR_BADOPENMODE">
            <summary>operation unsupported w/ open mode</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIDIERR_DONT_CONTINUE">
            <summary>thru device 'eating' a message</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIDIERR_LASTERROR">
            <summary>last error in range</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIXERR_INVALLINE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIXERR_INVALCONTROL">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIXERR_INVALVALUE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMRESULT.MIXERR_LASTERROR">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMTIME_TYPE">
            <summary>Time format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMTIME_TYPE.TIME_MS">
            <summary>time in milliseconds</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMTIME_TYPE.TIME_SAMPLES">
            <summary>number of wave samples</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMTIME_TYPE.TIME_BYTES">
            <summary>current byte offset</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMTIME_TYPE.TIME_SMPTE">
            <summary>SMPTE time</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMTIME_TYPE.TIME_MIDI">
            <summary>MIDI time</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMTIME_TYPE.TIME_TICKS">
            <summary>Ticks within MIDI stream</summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.MAKEFOURCC(System.Char,System.Char,System.Char,System.Char)">
            <summary>Makes a four character code.</summary>
            <param name="ch0">The first character.</param>
            <param name="ch1">The second character.</param>
            <param name="ch2">The third character.</param>
            <param name="ch3">The fourth character.</param>
            <returns>The character code.</returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.MAKEFOURCC(System.String)">
            <summary>Makes a four character code.</summary>
            <param name="chars">The four character code.</param>
            <returns>The character code.</returns>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.MMTIME">
            <summary>Multimedia time.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMTIME.wType">
            <summary>Time format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMTIME.u">
            <summary>The value.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.MMTIME.NativeSize">
            <summary>Gets the native size of this structure.</summary>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.SND">
            <summary>Flags for playing the sound.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_SYNC">
            <summary>
            The sound is played synchronously, and PlaySound returns after the sound event completes. This is the default behavior.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_ASYNC">
            <summary>
            The sound is played asynchronously and PlaySound returns immediately after beginning the sound. To terminate an
            asynchronously played waveform sound, call PlaySound with pszSound set to NULL.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_NODEFAULT">
            <summary>
            No default sound event is used. If the sound cannot be found, PlaySound returns silently without playing the default sound.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_MEMORY">
            <summary>The pszSound parameter points to a sound loaded in memory. For more information, see Playing WAVE Resources.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_LOOP">
            <summary>
            The sound plays repeatedly until PlaySound is called again with the pszSound parameter set to NULL. If this flag is set, you
            must also set the SND_ASYNC flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_NOSTOP">
            <summary>
            The specified sound event will yield to another sound event that is already playing in the same process. If a sound cannot
            be played because the resource needed to generate that sound is busy playing another sound, the function immediately returns
            FALSE without playing the requested sound. If this flag is not specified, PlaySound attempts to stop any sound that is
            currently playing in the same process. Sounds played in other processes are not affected.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_NOWAIT">
            <summary>
            Not supported. Note Previous versions of the documentation implied incorrectly that this flag is supported. The function
            ignores this flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_ALIAS">
            <summary>
            The pszSound parameter is a system-event alias in the registry or the WIN.INI file. Do not use with either SND_FILENAME or SND_RESOURCE.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_ALIAS_ID">
            <summary>The pszSound parameter is a predefined identifier for a system-event alias. See Remarks.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_FILENAME">
            <summary>
            The pszSound parameter is a file name. If the file cannot be found, the function plays the default sound unless the
            SND_NODEFAULT flag is set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_RESOURCE">
            <summary>
            The pszSound parameter is a resource identifier; hmod must identify the instance that contains the resource. For more
            information, see Playing WAVE Resources.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_PURGE">
            <summary>Not supported.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_APPLICATION">
            <summary>
            The pszSound parameter is an application-specific alias in the registry. You can combine this flag with the SND_ALIAS or
            SND_ALIAS_ID flag to specify an application-defined sound alias.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_SENTRY">
            <summary>
            Note Requires Windows Vista or later. If this flag is set, the function triggers a SoundSentry event when the sound is
            played. SoundSentry is an accessibility feature that causes the computer to display a visual cue when a sound is played. If
            the user did not enable SoundSentry, the visual cue is not displayed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_RING">
            <summary>Treat this as a "ring" from a communications app - don't duck me</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.SND.SND_SYSTEM">
            <summary>
            Note Requires Windows Vista or later. If this flag is set, the sound is assigned to the audio session for system
            notification sounds. The system volume-control program (SndVol) displays a volume slider that controls system notification
            sounds. Setting this flag puts the sound under the control of that volume slider If this flag is not set, the sound is
            assigned to the default audio session for the application's process. For more information, see the documentation for the
            Core Audio APIs.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.PlaySound(System.String,Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.WinMm.SND)">
            <summary>
            The <c>PlaySound</c> function plays a sound specified by the given file name, resource, or system event. (A system event may be
            associated with a sound in the registry or in the WIN.INI file.)
            </summary>
            <param name="pszSound">
            <para>
            A string that specifies the sound to play. The maximum length, including the null terminator, is 256 characters. If this
            parameter is <c>NULL</c>, any currently playing waveform sound is stopped.
            </para>
            <para>
            Three flags in fdwSound ( <c>SND_ALIAS</c>, <c>SND_FILENAME</c>, and <c>SND_RESOURCE</c>) determine whether the name is
            interpreted as an alias for a system event, a file name, or a resource identifier. If none of these flags are specified,
            <c>PlaySound</c> searches the registry or the WIN.INI file for an association with the specified sound name. If an association
            is found, the sound event is played. If no association is found in the registry, the name is interpreted as a file name.
            </para>
            </param>
            <param name="hmod">
            Handle to the executable file that contains the resource to be loaded. This parameter must be <c>NULL</c> unless
            <c>SND_RESOURCE</c> is specified in fdwSound.
            </param>
            <param name="fdwSound">
            <para>Flags for playing the sound. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SND_APPLICATION</term>
            <term>
            The pszSound parameter is an application-specific alias in the registry. You can combine this flag with the SND_ALIAS or
            SND_ALIAS_ID flag to specify an application-defined sound alias.
            </term>
            </item>
            <item>
            <term>SND_ALIAS</term>
            <term>
            The pszSound parameter is a system-event alias in the registry or the WIN.INI file. Do not use with either SND_FILENAME or SND_RESOURCE.
            </term>
            </item>
            <item>
            <term>SND_ALIAS_ID</term>
            <term>The pszSound parameter is a predefined identifier for a system-event alias. See Remarks.</term>
            </item>
            <item>
            <term>SND_ASYNC</term>
            <term>
            The sound is played asynchronously and PlaySound returns immediately after beginning the sound. To terminate an asynchronously
            played waveform sound, call PlaySound with pszSound set to NULL.
            </term>
            </item>
            <item>
            <term>SND_FILENAME</term>
            <term>
            The pszSound parameter is a file name. If the file cannot be found, the function plays the default sound unless the
            SND_NODEFAULT flag is set.
            </term>
            </item>
            <item>
            <term>SND_LOOP</term>
            <term>
            The sound plays repeatedly until PlaySound is called again with the pszSound parameter set to NULL. If this flag is set, you
            must also set the SND_ASYNC flag.
            </term>
            </item>
            <item>
            <term>SND_MEMORY</term>
            <term>The pszSound parameter points to a sound loaded in memory. For more information, see Playing WAVE Resources.</term>
            </item>
            <item>
            <term>SND_NODEFAULT</term>
            <term>No default sound event is used. If the sound cannot be found, PlaySound returns silently without playing the default sound.</term>
            </item>
            <item>
            <term>SND_NOSTOP</term>
            <term>
            The specified sound event will yield to another sound event that is already playing in the same process. If a sound cannot be
            played because the resource needed to generate that sound is busy playing another sound, the function immediately returns FALSE
            without playing the requested sound. If this flag is not specified, PlaySound attempts to stop any sound that is currently
            playing in the same process. Sounds played in other processes are not affected.
            </term>
            </item>
            <item>
            <term>SND_NOWAIT</term>
            <term>
            Not supported. Note Previous versions of the documentation implied incorrectly that this flag is supported. The function ignores
            this flag.
            </term>
            </item>
            <item>
            <term>SND_PURGE</term>
            <term>Not supported.</term>
            </item>
            <item>
            <term>SND_RESOURCE</term>
            <term>
            The pszSound parameter is a resource identifier; hmod must identify the instance that contains the resource. For more
            information, see Playing WAVE Resources.
            </term>
            </item>
            <item>
            <term>SND_SENTRY</term>
            <term>
            Note Requires Windows Vista or later. If this flag is set, the function triggers a SoundSentry event when the sound is played.
            SoundSentry is an accessibility feature that causes the computer to display a visual cue when a sound is played. If the user did
            not enable SoundSentry, the visual cue is not displayed.
            </term>
            </item>
            <item>
            <term>SND_SYNC</term>
            <term>The sound is played synchronously, and PlaySound returns after the sound event completes. This is the default behavior.</term>
            </item>
            <item>
            <term>SND_SYSTEM</term>
            <term>
            Note Requires Windows Vista or later. If this flag is set, the sound is assigned to the audio session for system notification
            sounds. The system volume-control program (SndVol) displays a volume slider that controls system notification sounds. Setting
            this flag puts the sound under the control of that volume slider If this flag is not set, the sound is assigned to the default
            audio session for the application's process. For more information, see the documentation for the Core Audio APIs.
            </term>
            </item>
            </list>
            </param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
            <remarks>
            <para>
            The sound specified by pszSound must fit into available physical memory and be playable by an installed waveform-audio device driver.
            </para>
            <para>
            <c>PlaySound</c> searches the following directories for sound files: the current directory; the Windows directory; the Windows
            system directory; directories listed in the PATH environment variable; and the list of directories mapped in a network. If the
            function cannot find the specified sound and the <c>SND_NODEFAULT</c> flag is not specified, <c>PlaySound</c> uses the default
            system event sound instead. If the function can find neither the system default entry nor the default sound, it makes no sound
            and returns <c>FALSE</c>.
            </para>
            <para>If the <c>SND_ALIAS_ID</c> flag is specified in fdwSound, the pszSound parameter must be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>SND_ALIAS_SYSTEMASTERISK</term>
            <term>"SystemAsterisk" event.</term>
            </item>
            <item>
            <term>SND_ALIAS_SYSTEMDEFAULT</term>
            <term>"SystemDefault" event.</term>
            </item>
            <item>
            <term>SND_ALIAS_SYSTEMEXCLAMATION</term>
            <term>"SystemExclamation" event.</term>
            </item>
            <item>
            <term>SND_ALIAS_SYSTEMEXIT</term>
            <term>"SystemExit" event.</term>
            </item>
            <item>
            <term>SND_ALIAS_SYSTEMHAND</term>
            <term>"SystemHand" event.</term>
            </item>
            <item>
            <term>SND_ALIAS_SYSTEMQUESTION</term>
            <term>"SystemQuestion" event.</term>
            </item>
            <item>
            <term>SND_ALIAS_SYSTEMSTART</term>
            <term>"SystemStart" event.</term>
            </item>
            <item>
            <term>SND_ALIAS_SYSTEMWELCOME</term>
            <term>"SystemWelcome" event.</term>
            </item>
            </list>
            <para>
            The <c>SND_ASYNC</c> flag causes <c>PlaySound</c> to return immediately without waiting for the sound to finish playing. If you
            combine the <c>SND_MEMORY</c> and <c>SND_ASYNC</c> flags, the memory buffer that contains the sound must remain valid until the
            sound has completed playing.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.sndPlaySound(System.String,System.UInt32)">
            <summary>
            The <c>sndPlaySound</c> function plays a waveform sound specified either by a file name or by an entry in the registry or the
            WIN.INI file. This function offers a subset of the functionality of the <c>PlaySound</c> function; <c>sndPlaySound</c> is being
            maintained for backward compatibility.
            </summary>
            <param name="lpszSound">
            A string that specifies the sound to play. This parameter can be either an entry in the registry or in WIN.INI that identifies a
            system sound, or it can be the name of a waveform-audio file. (If the function does not find the entry, the parameter is treated
            as a file name.) If this parameter is <c>NULL</c>, any currently playing sound is stopped.
            </param>
            <param name="fuSound">
            <para>Flags for playing the sound. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SND_ASYNC</term>
            <term>
            The sound is played asynchronously and the function returns immediately after beginning the sound. To terminate an
            asynchronously played sound, call sndPlaySound with lpszSound set to NULL.
            </term>
            </item>
            <item>
            <term>SND_LOOP</term>
            <term>
            The sound plays repeatedly until sndPlaySound is called again with the lpszSound parameter set to NULL. You must also specify
            the SND_ASYNC flag to loop sounds.
            </term>
            </item>
            <item>
            <term>SND_MEMORY</term>
            <term>
            The parameter specified by lpszSound points to an image of a waveform sound in memory. The data passed must be trusted by the application.
            </term>
            </item>
            <item>
            <term>SND_NODEFAULT</term>
            <term>If the sound cannot be found, the function returns silently without playing the default sound.</term>
            </item>
            <item>
            <term>SND_NOSTOP</term>
            <term>
            If a sound is currently playing in the same process, the function immediately returns FALSE, without playing the requested sound.
            </term>
            </item>
            <item>
            <term>SND_SENTRY</term>
            <term>
            Note Requires Windows Vista or later. If this flag is set, the function triggers a SoundSentry event when the sound is played.
            For more information, see PlaySound.
            </term>
            </item>
            <item>
            <term>SND_SYNC</term>
            <term>The sound is played synchronously and the function does not return until the sound ends.</term>
            </item>
            <item>
            <term>SND_SYSTEM</term>
            <term>
            Note Requires Windows Vista or later. If this flag is set, the sound is assigned to the audio session for system notification
            sounds. For more information, see PlaySound.
            </term>
            </item>
            </list>
            </param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
            <remarks>
            <para>
            If the specified sound cannot be found, <c>sndPlaySound</c> plays the system default sound. If there is no system default entry
            in the registry or WIN.INI file, or if the default sound cannot be found, the function makes no sound and returns <c>FALSE</c>.
            </para>
            <para>
            The specified sound must fit in available physical memory and be playable by an installed waveform-audio device driver. If
            <c>sndPlaySound</c> does not find the sound in the current directory, the function searches for it using the standard
            directory-search order.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.timeBeginPeriod(System.UInt32)">
            <summary>The <c>timeBeginPeriod</c> function requests a minimum resolution for periodic timers.</summary>
            <param name="uPeriod">
            Minimum timer resolution, in milliseconds, for the application or device driver. A lower value specifies a higher (more
            accurate) resolution.
            </param>
            <returns>
            Returns <c>TIMERR_NOERROR</c> if successful or <c>TIMERR_NOCANDO</c> if the resolution specified in uPeriod is out of range.
            </returns>
            <remarks>
            <para>
            Call this function immediately before using timer services, and call the timeEndPeriod function immediately after you are
            finished using the timer services.
            </para>
            <para>
            You must match each call to <c>timeBeginPeriod</c> with a call to timeEndPeriod, specifying the same minimum resolution in both
            calls. An application can make multiple <c>timeBeginPeriod</c> calls as long as each call is matched with a call to <c>timeEndPeriod</c>.
            </para>
            <para>
            Prior to Windows 10, version 2004, this function affects a global Windows setting. For all processes Windows uses the lowest
            value (that is, highest resolution) requested by any process. Starting with Windows 10, version 2004, this function no longer
            affects global timer resolution. For processes which call this function, Windows uses the lowest value (that is, highest
            resolution) requested by any process. For processes which have not called this function, Windows does not guarantee a higher
            resolution than the default system resolution.
            </para>
            <para>
            Setting a higher resolution can improve the accuracy of time-out intervals in wait functions. However, it can also reduce
            overall system performance, because the thread scheduler switches tasks more often. High resolutions can also prevent the CPU
            power management system from entering power-saving modes. Setting a higher resolution does not improve the accuracy of the
            high-resolution performance counter.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.timeEndPeriod(System.UInt32)">
            <summary>The <c>timeEndPeriod</c> function clears a previously set minimum timer resolution.</summary>
            <param name="uPeriod">Minimum timer resolution specified in the previous call to the timeBeginPeriod function.</param>
            <returns>
            Returns <c>TIMERR_NOERROR</c> if successful or <c>TIMERR_NOCANDO</c> if the resolution specified in uPeriod is out of range.
            </returns>
            <remarks>
            <para>Call this function immediately after you are finished using timer services.</para>
            <para>
            You must match each call to timeBeginPeriod with a call to <c>timeEndPeriod</c>, specifying the same minimum resolution in both
            calls. An application can make multiple <c>timeBeginPeriod</c> calls as long as each call is matched with a call to <c>timeEndPeriod</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.timeGetDevCaps(Vanara.PInvoke.WinMm.TIMECAPS@,System.UInt32)">
            <summary>The <c>timeGetDevCaps</c> function queries the timer device to determine its resolution.</summary>
            <param name="ptc">
            A pointer to a TIMECAPS structure. This structure is filled with information about the resolution of the timer device.
            </param>
            <param name="cbtc">The size, in bytes, of the TIMECAPS structure.</param>
            <returns>
            <para>Returns <c>MMSYSERR_NOERROR</c> if successful or an error code otherwise. Possible error codes include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_ERROR</term>
            <term>General error code.</term>
            </item>
            <item>
            <term>TIMERR_NOCANDO</term>
            <term>The ptc parameter is NULL, or the cbtc parameter is invalid, or some other error occurred.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.timeGetSystemTime(Vanara.PInvoke.WinMm.MMTIME@,System.UInt32)">
            <summary>
            The <c>timeGetSystemTime</c> function retrieves the system time, in milliseconds. The system time is the time elapsed since
            Windows was started. This function works very much like the timeGetTime function. See <c>timeGetTime</c> for details of these
            functions' operation.
            </summary>
            <param name="pmmt">Pointer to an MMTIME structure.</param>
            <param name="cbmmt">Size, in bytes, of the MMTIME structure.</param>
            <returns>If successful, returns <c>TIMERR_NOERROR</c>. Otherwise, returns an error code.</returns>
            <remarks>The system time is returned in the <c>ms</c> member of the MMTIME structure.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.WinMm.timeGetTime">
            <summary>
            The <c>timeGetTime</c> function retrieves the system time, in milliseconds. The system time is the time elapsed since Windows
            was started.
            </summary>
            <returns>Returns the system time, in milliseconds.</returns>
            <remarks>
            <para>
            The only difference between this function and the timeGetSystemTime function is that <c>timeGetSystemTime</c> uses the MMTIME
            structure to return the system time. The <c>timeGetTime</c> function has less overhead than <c>timeGetSystemTime</c>.
            </para>
            <para>
            Note that the value returned by the <c>timeGetTime</c> function is a <c>DWORD</c> value. The return value wraps around to 0
            every 2^32 milliseconds, which is about 49.71 days. This can cause problems in code that directly uses the <c>timeGetTime</c>
            return value in computations, particularly where the value is used to control code execution. You should always use the
            difference between two <c>timeGetTime</c> return values in computations.
            </para>
            <para>
            The default precision of the <c>timeGetTime</c> function can be five milliseconds or more, depending on the machine. You can use
            the timeBeginPeriod and timeEndPeriod functions to increase the precision of <c>timeGetTime</c>. If you do so, the minimum
            difference between successive values returned by <c>timeGetTime</c> can be as large as the minimum period value set using
            <c>timeBeginPeriod</c> and <c>timeEndPeriod</c>. Use the QueryPerformanceCounter and QueryPerformanceFrequency functions to
            measure short time intervals at a high resolution.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.WinMm.TIMECAPS">
            <summary>The <c>TIMECAPS</c> structure contains information about the resolution of the timer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.TIMECAPS.wPeriodMin">
            <summary>The minimum supported resolution, in milliseconds.</summary>
        </member>
        <member name="F:Vanara.PInvoke.WinMm.TIMECAPS.wPeriodMax">
            <summary>The maximum supported resolution, in milliseconds.</summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32">
            <summary>Items from the MsAcm32.dll</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS_FCCCOMP">
            <summary>The FOURCC used in the fccComp field of the ACMDRIVERDETAILS structure. This is currently an unused field.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC">
            <summary>
            The FOURCC used in the fccType field of the ACMDRIVERDETAILS structure to specify that this is an ACM codec designed for audio.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMDRIVERENUMCB">
            <summary>
            The <c>acmDriverEnumCallback</c> function specifies a callback function used with the acmDriverEnum function. The
            <c>acmDriverEnumCallback</c> name is a placeholder for an application-defined function name.
            </summary>
            <param name="hadid">Handle to an ACM driver identifier.</param>
            <param name="dwInstance">Application-defined value specified in acmDriverEnum.</param>
            <param name="fdwSupport">
            <para>
            Driver-support flags specific to the driver specified by ACMDRIVERDETAILS structure. This parameter can be a combination of the
            following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_ASYNC</term>
            <term>Driver supports asynchronous conversions.</term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CODEC</term>
            <term>
            Driver supports conversion between two different format tags. For example, if a driver supports compression from WAVE_FORMAT_PCM
            to WAVE_FORMAT_ADPCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CONVERTER</term>
            <term>
            Driver supports conversion between two different formats of the same format tag. For example, if a driver supports resampling of
            WAVE_FORMAT_PCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_DISABLED</term>
            <term>
            Driver has been disabled. An application must specify the ACM_DRIVERENUMF_DISABLED flag with acmDriverEnum to include disabled
            drivers in the enumeration.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_FILTER</term>
            <term>
            Driver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver
            supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set.
            </term>
            </item>
            </list>
            </param>
            <returns>The callback function must return <c>TRUE</c> to continue enumeration or <c>FALSE</c> to stop enumeration.</returns>
            <remarks>
            <para>
            The acmDriverEnum function will return MMSYSERR_NOERROR (zero) if no ACM drivers are installed. Moreover, the callback function
            will not be called.
            </para>
            <para>The following functions should not be called from within the callback function: acmDriverAdd, acmDriverRemove, and acmDriverPriority.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMDRIVERPROC">
            <summary>
            The <c>acmDriverProc</c> function specifies a callback function used with the ACM driver. The <c>acmDriverProc</c> name is a
            placeholder for an application-defined function name. The actual name must be exported by including it in the module-definition
            file of the executable or DLL file.
            </summary>
            <param name="unnamedParam1">Identifier of the installable ACM driver.</param>
            <param name="unnamedParam2">
            Handle to the installable ACM driver. This parameter is a unique handle the ACM assigns to the driver.
            </param>
            <param name="unnamedParam3">ACM driver message.</param>
            <param name="unnamedParam4">Message parameter.</param>
            <param name="unnamedParam5">Message parameter.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            Applications should not call any system-defined functions from inside a callback function, except for <c>PostMessage</c>,
            timeGetSystemTime, timeGetTime, timeSetEvent, timeKillEvent, midiOutShortMsg, midiOutLongMsg, and <c>OutputDebugStr</c>.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSEHOOKPROC">
            <summary>
            The <c>acmFilterChooseHookProc</c> function specifies a user-defined function that hooks the acmFilterChoose dialog box.
            </summary>
            <param name="hwnd">Window handle for the dialog box.</param>
            <param name="uMsg">Window message.</param>
            <param name="wParam">Message parameter.</param>
            <param name="lParam">Message parameter.</param>
            <returns>None</returns>
            <remarks>
            <para>To customize the dialog box selections, a hook function can optionally process the MM_ACM_FILTERCHOOSE message.</para>
            <para>You should use this function the same way as you use the Common Dialog hook functions for customizing common dialog boxes.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFILTERENUMCB">
            <summary>
            The <c>acmFilterEnumCallback</c> function specifies a callback function used with the acmFilterEnum function. The
            <c>acmFilterEnumCallback</c> name is a placeholder for an application-defined function name.
            </summary>
            <param name="hadid">Handle to the ACM driver identifier.</param>
            <param name="pafd">Pointer to an ACMFILTERDETAILS structure that contains the enumerated filter details for a filter tag.</param>
            <param name="dwInstance">Application-defined value specified in acmFilterEnum.</param>
            <param name="fdwSupport">
            <para>
            Driver-support flags specific to the driver identified by ACMDRIVERDETAILS structure, but they are specific to the filter that
            is being enumerated. This parameter can be a combination of the following values and identifies which operations the driver
            supports for the filter tag.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_ASYNC</term>
            <term>Driver supports asynchronous conversions with the specified filter tag.</term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CODEC</term>
            <term>
            Driver supports conversion between two different format tags while using the specified filter. For example, if a driver supports
            compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specified filter, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CONVERTER</term>
            <term>
            Driver supports conversion between two different formats of the same format tag while using the specified filter. For example,
            if a driver supports resampling of WAVE_FORMAT_PCM with the specified filter, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_FILTER</term>
            <term>
            Driver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver
            supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_HARDWARE</term>
            <term>
            Driver supports hardware input, output, or both with the specified filter through a waveform-audio device. An application should
            use the acmMetrics function with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indices to get
            the waveform-audio device identifiers associated with the supporting ACM driver.
            </term>
            </item>
            </list>
            </param>
            <returns>The callback function must return <c>TRUE</c> to continue enumeration or <c>FALSE</c> to stop enumeration.</returns>
            <remarks>
            <para>
            The <c>acmFilterEnum</c> function will return MMSYSERR_NOERROR (zero) if no filters are to be enumerated. Moreover, the callback
            function will not be called.
            </para>
            <para>
            The following functions should not be called from within the callback function: <c>acmDriverAdd</c>, <c>acmDriverRemove</c>, and <c>acmDriverPriority</c>.
            </para>
            <para>
            <para>Note</para>
            <para>
            The msacm.h header defines ACMFILTERENUMCB as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFILTERTAGENUMCB">
            <summary>
            The <c>acmFilterTagEnumCallback</c> function specifies a callback function used with the acmFilterTagEnum function. The
            <c>acmFilterTagEnumCallback</c> function name is a placeholder for an application-defined function name.
            </summary>
            <param name="hadid">Handle to the ACM driver identifier.</param>
            <param name="paftd">Pointer to an ACMFILTERTAGDETAILS structure that contains the enumerated filter tag details.</param>
            <param name="dwInstance">Application-defined value specified in acmFilterTagEnum.</param>
            <param name="fdwSupport">
            <para>
            Driver-support flags specific to the driver identifier ACMDRIVERDETAILS structure. This parameter can be a combination of the
            following values and identifies which operations the driver supports with the filter tag.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_ASYNC</term>
            <term>Driver supports asynchronous conversions with the specified filter tag.</term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CODEC</term>
            <term>
            Driver supports conversion between two different format tags while using the specified filter tag. For example, if a driver
            supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specified filter tag, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CONVERTER</term>
            <term>
            Driver supports conversion between two different formats of the same format tag while using the specified filter tag. For
            example, if a driver supports resampling of WAVE_FORMAT_PCM with the specified filter tag, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_FILTER</term>
            <term>
            Driver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver
            supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_HARDWARE</term>
            <term>
            Driver supports hardware input, output, or both with the specified filter tag through a waveform-audio device. An application
            should use the acmMetrics function with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indices to
            get the waveform-audio device identifiers associated with the supporting ACM driver.
            </term>
            </item>
            </list>
            </param>
            <returns>The callback function must return <c>TRUE</c> to continue enumeration or <c>FALSE</c> to stop enumeration.</returns>
            <remarks>
            <para>
            The acmFilterTagEnum function returns <c>MMSYSERR_NOERROR</c> (zero) if no filter tags are to be enumerated. Moreover, the
            callback function will not be called.
            </para>
            <para>The following functions should not be called from within the callback function: acmDriverAdd, acmDriverRemove, and acmDriverPriority.</para>
            <para>
            <para>Note</para>
            <para>
            The msacm.h header defines ACMFILTERTAGENUMCB as an alias which automatically selects the ANSI or Unicode version of this
            function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that
            not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions
            for Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSEHOOKPROC">
            <summary>
            The <c>acmFormatChooseHookProc</c> function specifies a user-defined function that hooks the acmFormatChoose dialog box. The
            <c>acmFormatChooseHookProc</c> name is a placeholder for an application-defined name.
            </summary>
            <param name="hwnd">Window handle for the dialog box.</param>
            <param name="uMsg">Window message.</param>
            <param name="wParam">Message parameter.</param>
            <param name="lParam">Message parameter.</param>
            <returns>None</returns>
            <remarks>
            <para>
            If the hook function processes one of the WM_CTLCOLOR messages, this function must return a handle of the brush that should be
            used to paint the control background.
            </para>
            <para>A hook function can optionally process the MM_ACM_FORMATCHOOSE message.</para>
            <para>You should use this function the same way as you use the Common Dialog hook functions for customizing common dialog boxes.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFORMATENUMCB">
            <summary>
            The <c>acmFormatEnumCallback</c> function specifies a callback function used with the acmFormatEnum function. The
            <c>acmFormatEnumCallback</c> name is a placeholder for the application-defined function name.
            </summary>
            <param name="hadid">Handle to the ACM driver identifier.</param>
            <param name="pafd">Pointer to an ACMFORMATDETAILS structure that contains the enumerated format details for a format tag.</param>
            <param name="dwInstance">Application-defined value specified in the acmFormatEnum function.</param>
            <param name="fdwSupport">
            <para>
            Driver support flags specific to the driver identified by ACMDRIVERDETAILS structure, but they are specific to the format that
            is being enumerated. This parameter can be a combination of the following values and indicates which operations the driver
            supports for the format tag.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_ASYNC</term>
            <term>Driver supports asynchronous conversions with the specified filter tag.</term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CODEC</term>
            <term>
            Driver supports conversion between two different format tags for the specified format. For example, if a driver supports
            compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specified format, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CONVERTER</term>
            <term>
            Driver supports conversion between two different formats of the same format tag while using the specified format. For example,
            if a driver supports resampling of WAVE_FORMAT_PCM to the specified format, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_FILTER</term>
            <term>
            Driver supports a filter (modification of the data without changing any of the format attributes) with the specified format. For
            example, if a driver supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_HARDWARE</term>
            <term>
            Driver supports hardware input, output, or both of the specified format tags through a waveform-audio device. An application
            should use the acmMetrics function with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to
            get the waveform-audio device identifiers associated with the supporting ACM driver.
            </term>
            </item>
            </list>
            </param>
            <returns>The callback function must return <c>TRUE</c> to continue enumeration or <c>FALSE</c> to stop enumeration.</returns>
            <remarks>
            <para>
            The acmFormatEnum function will return MMSYSERR_NOERROR (zero) if no formats are to be enumerated. Moreover, the callback
            function will not be called.
            </para>
            <para>The following functions should not be called from within the callback function: acmDriverAdd, acmDriverRemove, and acmDriverPriority.</para>
            <para>
            <para>Note</para>
            <para>
            The msacm.h header defines ACMFORMATENUMCB as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFORMATTAGENUMCB">
            <summary>
            The <c>acmFormatTagEnumCallback</c> function specifies a callback function used with the acmFormatTagEnum function. The
            <c>acmFormatTagEnumCallback</c> name is a placeholder for an application-defined function name.
            </summary>
            <param name="hadid">Handle to the ACM driver identifier.</param>
            <param name="paftd">Pointer to an ACMFORMATTAGDETAILS structure that contains the enumerated format tag details.</param>
            <param name="dwInstance">Application-defined value specified in the acmFormatTagEnum function.</param>
            <param name="fdwSupport">
            <para>
            Driver-support flags specific to the format tag. These flags are identical to the ACMDRIVERDETAILS structure. This parameter can
            be a combination of the following values and indicates which operations the driver supports with the format tag.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_ASYNC</term>
            <term>Driver supports asynchronous conversions with the specified filter tag.</term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CODEC</term>
            <term>
            Driver supports conversion between two different format tags where one of the tags is the specified format tag. For example, if
            a driver supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CONVERTER</term>
            <term>
            Driver supports conversion between two different formats of the specified format tag. For example, if a driver supports
            resampling of WAVE_FORMAT_PCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_FILTER</term>
            <term>
            Driver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver
            supports volume or echo operations on the specified format tag, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_HARDWARE</term>
            <term>
            Driver supports hardware input, output, or both of the specified format tag through a waveform-audio device. An application
            should use acmMetrics with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the
            waveform-audio device identifiers associated with the supporting ACM driver.
            </term>
            </item>
            </list>
            </param>
            <returns>The callback function must return <c>TRUE</c> to continue enumeration or <c>FALSE</c> to stop enumeration.</returns>
            <remarks>
            <para>
            The acmFormatTagEnum function will return MMSYSERR_NOERROR (zero) if no format tags are to be enumerated. Moreover, the callback
            function will not be called.
            </para>
            <para>The following functions should not be called from within the callback function: acmDriverAdd, acmDriverRemove, and acmDriverPriority.</para>
            <para>
            <para>Note</para>
            <para>
            The msacm.h header defines ACMFORMATTAGENUMCB as an alias which automatically selects the ANSI or Unicode version of this
            function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that
            not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions
            for Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_DRIVERADDF">
            <summary>Flags for adding ACM drivers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_DRIVERADDF.ACM_DRIVERADDF_NAME">
            <summary>
            The lParam parameter is a registry value name in HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Drivers32.
            The value identifies a DLL that implements an ACM codec. Applications can use this flag if new registry entries are created
            after the application has already started using the ACM.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_DRIVERADDF.ACM_DRIVERADDF_FUNCTION">
            <summary>
            The lParam parameter is a driver function address conforming to the acmDriverProc prototype. The function may reside in
            either an executable or DLL file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_DRIVERADDF.ACM_DRIVERADDF_NOTIFYHWND">
            <summary>
            The lParam parameter is a handle of a notification window that receives messages when changes to global driver priorities
            and states are made. The window message to receive is defined by the application and must be passed in dwPriority. The
            wParam and lParam parameters passed with the window message are reserved for future use and should be ignored.
            ACM_DRIVERADDF_GLOBAL cannot be specified in conjunction with this flag. For more information about driver priorities, see
            the description for the acmDriverPriority function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_DRIVERADDF.ACM_DRIVERADDF_LOCAL">
            <summary>
            The ACM automatically gives a local driver higher priority than a global driver when searching for a driver to satisfy a
            function call. For more information, see Adding Drivers Within an Application.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_DRIVERADDF.ACM_DRIVERADDF_GLOBAL">
            <summary>
            Provided for compatibility with 16-bit applications. For the Win32 API, ACM drivers added by the acmDriverAdd function can
            be used only by the application that added the driver. This is true whether or not ACM_DRIVERADDF_GLOBAL is specified. For
            more information, see Adding Drivers Within an Application.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_DRIVERENUMF">
            <summary>Flags for enumerating ACM drivers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_DRIVERENUMF.ACM_DRIVERENUMF_NOLOCAL">
            <summary>Only global drivers should be included in the enumeration.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_DRIVERENUMF.ACM_DRIVERENUMF_DISABLED">
            <summary>
            Disabled ACM drivers should be included in the enumeration. Drivers can be disabled by the user through the Control Panel or
            by an application using the acmDriverPriority function. If a driver is disabled, the fdwSupport parameter to the callback
            function will have the ACMDRIVERDETAILS_SUPPORTF_DISABLED flag set.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_DRIVERPRIORITYF">
            <summary>Flags for setting priorities of ACM drivers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_DRIVERPRIORITYF.ACM_DRIVERPRIORITYF_ENABLE">
            <summary>ACM driver should be enabled if it is currently disabled. Enabling an enabled driver does nothing.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_DRIVERPRIORITYF.ACM_DRIVERPRIORITYF_DISABLE">
            <summary>ACM driver should be disabled if it is currently enabled. Disabling a disabled driver does nothing.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_DRIVERPRIORITYF.ACM_DRIVERPRIORITYF_BEGIN">
            <summary>
            Change notification broadcasts should be deferred. An application must reenable notification broadcasts as soon as possible
            with the ACM_DRIVERPRIORITYF_END flag. Note that hadid must be NULL, dwPriority must be zero, and only the
            ACM_DRIVERPRIORITYF_BEGIN flag can be set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_DRIVERPRIORITYF.ACM_DRIVERPRIORITYF_END">
            <summary>
            Calling task wants to reenable change notification broadcasts. An application must call acmDriverPriority with
            ACM_DRIVERPRIORITYF_END for each successful call with the ACM_DRIVERPRIORITYF_BEGIN flag. Note that hadid must be NULL,
            dwPriority must be zero, and only the ACM_DRIVERPRIORITYF_END flag can be set.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_FILTERDETAILSF">
            <summary>Flags for getting the details.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FILTERDETAILSF.ACM_FILTERDETAILSF_INDEX">
            <summary>
            A filter index for the filter tag was given in the dwFilterIndex member of the ACMFILTERDETAILS structure. The filter
            details will be returned in the structure defined by pafd. The index ranges from zero to one less than the cStandardFilters
            member returned in the ACMFILTERTAGDETAILS structure for a filter tag. An application must specify a driver handle for had
            when retrieving filter details with this flag. For information about what members should be initialized before calling this
            function, see the ACMFILTERDETAILS structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FILTERDETAILSF.ACM_FILTERDETAILSF_FILTER">
            <summary>
            A WAVEFILTER structure pointed to by the pwfltr member of the ACMFILTERDETAILS structure was given and the remaining details
            should be returned. The dwFilterTag member of the ACMFILTERDETAILS structure must be initialized to the same filter tag
            pwfltr specifies. This query type can be used to get a string description of an arbitrary filter structure. If an
            application specifies an ACM driver handle for had, details on the filter will be returned for that driver. If an
            application specifies NULL for had, the ACM finds the first acceptable driver to return the details.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_FILTERENUMF">
            <summary>Optional flags for restricting the type of filters listed in the dialog box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FILTERENUMF.ACM_FILTERENUMF_DWFILTERTAG">
            <summary>
            The dwFilterTag member of the WAVEFILTER structure pointed to by the pwfltrEnum member is valid. The enumerator will only
            enumerate a filter that conforms to this attribute.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_FILTERTAGDETAILSF">
            <summary>Flags for getting the details.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FILTERTAGDETAILSF.ACM_FILTERTAGDETAILSF_INDEX">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FILTERTAGDETAILSF.ACM_FILTERTAGDETAILSF_FILTERTAG">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FILTERTAGDETAILSF.ACM_FILTERTAGDETAILSF_LARGESTSIZE">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_FORMATDETAILSF">
            <summary>Flags for getting the waveform-audio format tag details.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATDETAILSF.ACM_FORMATDETAILSF_INDEX">
            <summary>
            A format index for the format tag was given in the dwFormatIndex member of the ACMFORMATDETAILS structure. The format
            details will be returned in the structure defined by pafd. The index ranges from zero to one less than the cStandardFormats
            member returned in the ACMFORMATTAGDETAILS structure for a format tag. An application must specify a driver handle for had
            when retrieving format details with this flag. For information about which members should be initialized before calling this
            function, see the ACMFORMATDETAILS structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATDETAILSF.ACM_FORMATDETAILSF_FORMAT">
            <summary>
            ACMFORMATDETAILS structure was given and the remaining details should be returned. The dwFormatTag member of the
            ACMFORMATDETAILS structure must be initialized to the same format tag as pwfx specifies. This query type can be used to get
            a string description of an arbitrary format structure. If an application specifies an ACM driver handle for had , details on
            the format will be returned for that driver. If an application specifies NULL for had , the ACM finds the first acceptable
            driver to return the details.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_FORMATENUMF">
            <summary>Optional flags for restricting the type of formats listed in the dialog box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATENUMF.ACM_FORMATENUMF_WFORMATTAG">
            <summary>
            The wFormatTag member of the WAVEFORMATEX structure pointed to by the pwfxEnum member is valid. The enumerator will
            enumerate only a format that conforms to this attribute.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATENUMF.ACM_FORMATENUMF_NCHANNELS">
            <summary>
            The nChannels member of the WAVEFORMATEX structure pointed to by the pwfxEnum member is valid. The enumerator will enumerate
            only a format that conforms to this attribute.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATENUMF.ACM_FORMATENUMF_NSAMPLESPERSEC">
            <summary>
            The nSamplesPerSec member of the WAVEFORMATEX structure pointed to by the pwfxEnum member is valid. The enumerator will
            enumerate only a format that conforms to this attribute.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATENUMF.ACM_FORMATENUMF_WBITSPERSAMPLE">
            <summary>
            The wBitsPerSample member of the WAVEFORMATEX structure pointed to by the pwfxEnum member is valid. The enumerator will
            enumerate only a format that conforms to this attribute.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATENUMF.ACM_FORMATENUMF_CONVERT">
            <summary>
            The WAVEFORMATEX structure pointed to by the pwfxEnum member is valid. The enumerator will enumerate only destination
            formats that can be converted from the given pwfxEnum format.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATENUMF.ACM_FORMATENUMF_SUGGEST">
            <summary>
            The WAVEFORMATEX structure pointed to by the pwfxEnum member is valid. The enumerator will enumerate all suggested
            destination formats for the given pwfxEnum format.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATENUMF.ACM_FORMATENUMF_HARDWARE">
            <summary>
            The enumerator should enumerate only formats that are supported in hardware by one or more of the installed waveform-audio
            devices. This flag provides a way for an application to choose only formats native to an installed waveform-audio device.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATENUMF.ACM_FORMATENUMF_INPUT">
            <summary>The enumerator should enumerate only formats that are supported for input (recording).</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATENUMF.ACM_FORMATENUMF_OUTPUT">
            <summary>The enumerator should enumerate only formats that are supported for output (playback).</summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_FORMATSUGGESTF">
            <summary>Flags for matching the desired destination format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATSUGGESTF.ACM_FORMATSUGGESTF_WFORMATTAG">
            <summary>
            The wFormatTag member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that
            can suggest a destination format matching wFormatTag or fail.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATSUGGESTF.ACM_FORMATSUGGESTF_NCHANNELS">
            <summary>
            The nChannels member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that
            can suggest a destination format matching nChannels or fail.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATSUGGESTF.ACM_FORMATSUGGESTF_NSAMPLESPERSEC">
            <summary>
            The nSamplesPerSec member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers
            that can suggest a destination format matching nSamplesPerSec or fail.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATSUGGESTF.ACM_FORMATSUGGESTF_WBITSPERSAMPLE">
            <summary>
            The wBitsPerSample member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers
            that can suggest a destination format matching wBitsPerSample or fail.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_FORMATTAGDETAILSF">
            <summary>Flags for getting the details.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATTAGDETAILSF.ACM_FORMATTAGDETAILSF_INDEX">
            <summary>
            ACMDRIVERDETAILS structure for an ACM driver. An application must specify a driver handle forhadwhen retrieving format tag
            details with this flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATTAGDETAILSF.ACM_FORMATTAGDETAILSF_FORMATTAG">
            <summary>
            ACMFORMATTAGDETAILS structure. The format tag details will be returned in the structure pointed to bypaftd. If an
            application specifies an ACM driver handle forhad, details on the format tag will be returned for that driver. If an
            application specifiesNULLforhad, the ACM finds the first acceptable driver to return the details.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_FORMATTAGDETAILSF.ACM_FORMATTAGDETAILSF_LARGESTSIZE">
            <summary>
            ACMFORMATTAGDETAILS structure must either be WAVE_FORMAT_UNKNOWN or the format tag to find the largest size for. If an
            application specifies an ACM driver handle forhad, details on the largest format tag will be returned for that driver. If an
            application specifiesNULLforhad, the ACM finds an acceptable driver with the largest format tag requested to return the details.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_METRIC">
            <summary>Metric index to be returned in pMetric.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_COUNT_DRIVERS">
            <summary>
            Returned value is the total number of enabled global ACM drivers (of all support types) in the system. The hao parameter
            must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_COUNT_CODECS">
            <summary>
            Returned value is the number of global ACM compressor or decompressor drivers in the system. The hao parameter must be NULL
            for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_COUNT_CONVERTERS">
            <summary>
            Returned value is the number of global ACM converter drivers in the system. The hao parameter must be NULL for this metric
            index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_COUNT_FILTERS">
            <summary>
            Returned value is the number of global ACM filter drivers in the system. The hao parameter must be NULL for this metric
            index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_COUNT_DISABLED">
            <summary>
            Returned value is the total number of global disabled ACM drivers (of all support types) in the system. The hao parameter
            must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. The sum
            of the ACM_METRIC_COUNT_DRIVERS and ACM_METRIC_COUNT_DISABLED metric indices is the total number of globally installed ACM drivers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_COUNT_HARDWARE">
            <summary>
            Returned value is the number of global ACM hardware drivers in the system. The hao parameter must be NULL for this metric
            index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_COUNT_LOCAL_DRIVERS">
            <summary>
            Returned value is the total number of enabled local ACM drivers (of all support types) for the calling task. The hao
            parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_COUNT_LOCAL_CODECS">
            <summary>
            Returned value is the number of local ACM compressor drivers, ACM decompressor drivers, or both for the calling task. The
            hao parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_COUNT_LOCAL_CONVERTERS">
            <summary>
            Returned value is the number of local ACM converter drivers for the calling task. The hao parameter must be NULL for this
            metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_COUNT_LOCAL_FILTERS">
            <summary>
            Returned value is the number of local ACM filter drivers for the calling task. The hao parameter must be NULL for this
            metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_COUNT_LOCAL_DISABLED">
            <summary>
            Returned value is the total number of local disabled ACM drivers, of all support types, for the calling task. The hao
            parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            The sum of the ACM_METRIC_COUNT_LOCAL_DRIVERS and ACM_METRIC_COUNT_LOCAL_DISABLED metric indices is the total number of
            locally installed ACM drivers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_HARDWARE_WAVE_INPUT">
            <summary>
            Returned value is the waveform-audio input device identifier associated with the specified driver. The hao parameter must be
            a valid ACM driver identifier of the HACMDRIVERID data type that supports the ACMDRIVERDETAILS_SUPPORTF_HARDWARE flag. If no
            waveform-audio input device is associated with the driver, MMSYSERR_NOTSUPPORTED is returned. The pMetric parameter must
            point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_HARDWARE_WAVE_OUTPUT">
            <summary>
            Returned value is the waveform-audio output device identifier associated with the specified driver. The hao parameter must
            be a valid ACM driver identifier of the HACMDRIVERID data type that supports the ACMDRIVERDETAILS_SUPPORTF_HARDWARE flag. If
            no waveform-audio output device is associated with the driver, MMSYSERR_NOTSUPPORTED is returned. The pMetric parameter must
            point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_MAX_SIZE_FORMAT">
            <summary>
            Returned value is the size of the largest WAVEFORMATEX structure. If hao is NULL, the return value is the largest
            WAVEFORMATEX structure in the system. If hao identifies an open instance of an ACM driver of the HACMDRIVER data type or an
            ACM driver identifier of the HACMDRIVERID data type, the largest WAVEFORMATEX structure for that driver is returned. The
            pMetric parameter must point to a buffer of a size equal to a DWORD value. This metric is not allowed for an ACM stream
            handle of the HACMSTREAM data type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_MAX_SIZE_FILTER">
            <summary>
            Returned value is the size of the largest WAVEFILTER structure. If hao is NULL, the return value is the largest WAVEFILTER
            structure in the system. If hao identifies an open instance of an ACM driver of the HACMDRIVER data type or an ACM driver
            identifier of the HACMDRIVERID data type, the largest WAVEFILTER structure for that driver is returned. The pMetric
            parameter must point to a buffer of a size equal to a DWORD value. This metric is not allowed for an ACM stream handle of
            the HACMSTREAM data type.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_DRIVER_SUPPORT">
            <summary>
            Returned value is the fdwSupport flags for the specified driver. The hao parameter must be a valid ACM driver identifier of
            the HACMDRIVERID data type. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_METRIC.ACM_METRIC_DRIVER_PRIORITY">
            <summary>
            Returned value is the current priority for the specified driver. The hao parameter must be a valid ACM driver identifier of
            the HACMDRIVERID data type. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_STREAMCONVERTF">
            <summary>Flags for doing the conversion.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_STREAMCONVERTF.ACM_STREAMCONVERTF_BLOCKALIGN">
            <summary>
            Only integral numbers of blocks will be converted. Converted data will end on block-aligned boundaries. An application
            should use this flag for all conversions on a stream until there is not enough source data to convert to a block-aligned
            destination. In this case, the last conversion should be specified without this flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_STREAMCONVERTF.ACM_STREAMCONVERTF_START">
            <summary>
            ACM conversion stream should reinitialize its instance data. For example, if a conversion stream holds instance data, such
            as delta or predictor information, this flag will restore the stream to starting defaults. This flag can be specified with
            the ACM_STREAMCONVERTF_END flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_STREAMCONVERTF.ACM_STREAMCONVERTF_END">
            <summary>
            ACM conversion stream should begin returning pending instance data. For example, if a conversion stream holds instance data,
            such as the end of an echo filter operation, this flag will cause the stream to start returning this remaining data with
            optional source data. This flag can be specified with the ACM_STREAMCONVERTF_START flag.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_STREAMOPENF">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_STREAMOPENF.ACM_STREAMOPENF_QUERY">
            <summary>
            ACM will be queried to determine whether it supports the given conversion. A conversion stream will not be opened, and no
            handle will be returned in the phas parameter.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_STREAMOPENF.ACM_STREAMOPENF_ASYNC">
            <summary>ACMSTREAMHEADER structure for the ACMSTREAMHEADER_STATUSF_DONE flag.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_STREAMOPENF.ACM_STREAMOPENF_NONREALTIME">
            <summary>
            ACM will not consider time constraints when converting the data. By default, the driver will attempt to convert the data in
            real time. For some formats, specifying this flag might improve the audio quality or other characteristics.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_STREAMOPENF.CALLBACK_WINDOW">
            <summary>The dwCallback parameter is a window handle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_STREAMOPENF.CALLBACK_FUNCTION">
            <summary>The dwCallback parameter is a callback procedure address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_STREAMOPENF.CALLBACK_EVENT">
            <summary>The dwCallback parameter is an event handle.</summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACM_STREAMSIZEF">
            <summary>Flags for the stream size query.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_STREAMSIZEF.ACM_STREAMSIZEF_SOURCE">
            <summary>
            The cbInput parameter contains the size of the source buffer. The pdwOutputBytes parameter will receive the recommended
            destination buffer size, in bytes.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACM_STREAMSIZEF.ACM_STREAMSIZEF_DESTINATION">
            <summary>
            The cbInput parameter contains the size of the destination buffer. The pdwOutputBytes parameter will receive the recommended
            source buffer size, in bytes.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS_SUPPORTF">
            <summary>Support flags for the driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS_SUPPORTF.ACMDRIVERDETAILS_SUPPORTF_CODEC">
            <summary>
            Driver supports conversion between two different format tags. For example, if a driver supports compression from
            WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM, this flag is set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS_SUPPORTF.ACMDRIVERDETAILS_SUPPORTF_CONVERTER">
            <summary>
            Driver supports conversion between two different formats of the same format tag. For example, if a driver supports
            resampling of WAVE_FORMAT_PCM, this flag is set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS_SUPPORTF.ACMDRIVERDETAILS_SUPPORTF_FILTER">
            <summary>
            Driver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver
            supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS_SUPPORTF.ACMDRIVERDETAILS_SUPPORTF_HARDWARE">
            <summary>
            Driver supports hardware input, output, or both through a waveform-audio device. An application should use the acmMetrics
            function with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the
            waveform-audio device identifiers associated with the supporting ACM driver.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS_SUPPORTF.ACMDRIVERDETAILS_SUPPORTF_ASYNC">
            <summary>Driver supports asynchronous conversions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS_SUPPORTF.ACMDRIVERDETAILS_SUPPORTF_LOCAL">
            <summary>The driver has been installed locally with respect to the current task.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS_SUPPORTF.ACMDRIVERDETAILS_SUPPORTF_DISABLED">
            <summary>
            Driver has been disabled. This flag is set by the ACM for a driver when it has been disabled for any of a number of reasons.
            Disabled drivers cannot be opened and can be used only under very limited circumstances.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE_STYLEF">
            <summary>Optional style flags for the acmFilterChoose function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE_STYLEF.ACMFILTERCHOOSE_STYLEF_SHOWHELP">
            <summary>
            A help button will appear in the dialog box. To use a custom Help file, an application must register the ACMHELPMSGSTRING
            value with the RegisterWindowMessage function. When the user presses the help button, the registered message is posted to
            the owner.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE_STYLEF.ACMFILTERCHOOSE_STYLEF_ENABLEHOOK">
            <summary>
            Enables the hook function specified in the pfnHook member. An application can use hook functions for a variety of
            customizations, including answering the MM_ACM_FILTERCHOOSE message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE_STYLEF.ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE">
            <summary>Causes the ACM to create the dialog box template identified by the hInstance and pszTemplateName members.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE_STYLEF.ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE">
            <summary>
            The hInstance member identifies a data block that contains a preloaded dialog box template. If this flag is specified, the
            ACM ignores the pszTemplateName member.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE_STYLEF.ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT">
            <summary>
            The buffer pointed to by pwfltr contains a valid WAVEFILTER structure that the dialog box will use as the initial selection.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE_STYLEF.ACMFILTERCHOOSE_STYLEF_CONTEXTHELP">
            <summary>
            Context-sensitive help will be available in the dialog box. To use this feature, an application must register the
            ACMHELPMSGCONTEXTMENU and ACMHELPMSGCONTEXTHELP constants, using the RegisterWindowMessage function. When the user invokes
            help, the registered message will be posted to the owning window. The message will contain the wParam and lParam parameters
            from the original WM_CONTEXTMENU or WM_CONTEXTHELP message.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE_STYLEF">
            <summary>Optional style flags for the acmFormatChoose function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE_STYLEF.ACMFORMATCHOOSE_STYLEF_SHOWHELP">
            <summary>
            A help button will appear in the dialog box. To use a custom Help file, an application must register the ACMHELPMSGSTRING
            constant with the RegisterWindowMessage function. When the user presses the help button, the registered message will be
            posted to the owner.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE_STYLEF.ACMFORMATCHOOSE_STYLEF_ENABLEHOOK">
            <summary>
            Enables the hook function pointed to by the pfnHook member. An application can use hook functions for a variety of
            customizations, including answering the MM_ACM_FORMATCHOOSE message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE_STYLEF.ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE">
            <summary>Causes the ACM to create the dialog box template identified by hInstance and pszTemplateName.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE_STYLEF.ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE">
            <summary>
            The hInstance member identifies a data block that contains a preloaded dialog box template. If this flag is specified, the
            ACM ignores the pszTemplateName member.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE_STYLEF.ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT">
            <summary>
            The buffer pointed to by pwfx contains a valid WAVEFORMATEX structure that the dialog box will use as the initial selection.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE_STYLEF.ACMFORMATCHOOSE_STYLEF_CONTEXTHELP">
            <summary>
            Context-sensitive help will be available in the dialog box. To use this feature, an application must register the
            ACMHELPMSGCONTEXTMENU and ACMHELPMSGCONTEXTHELP constants, using the RegisterWindowMessage function. When the user invokes
            help, the registered message will be posted to the owning window. The message will contain the wParam and lParam parameters
            from the original WM_CONTEXTMENU or WM_CONTEXTHELP message.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER_STATUSF">
            <summary>Flags giving information about the conversion buffers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER_STATUSF.ACMSTREAMHEADER_STATUSF_DONE">
            <summary>
            Set by the ACM or driver to indicate that it is finished with the conversion and is returning the buffers to the application.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER_STATUSF.ACMSTREAMHEADER_STATUSF_PREPARED">
            <summary>Set by the ACM to indicate that the buffers have been prepared by using the acmStreamPrepareHeader function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER_STATUSF.ACMSTREAMHEADER_STATUSF_INQUEUE">
            <summary>Set by the ACM or driver to indicate that the buffers are queued for conversion.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmDriverAdd(Vanara.PInvoke.MsAcm32.HACMDRIVERID@,Vanara.PInvoke.HINSTANCE,System.IntPtr,System.UInt32,Vanara.PInvoke.MsAcm32.ACM_DRIVERADDF)">
            <summary>
            The <c>acmDriverAdd</c> function adds a driver to the list of available ACM drivers. The driver type and location are dependent
            on the flags used to add ACM drivers. After a driver is successfully added, the driver entry function will receive ACM driver messages.
            </summary>
            <param name="phadid">
            Pointer to the buffer that receives a handle identifying the installed driver. This handle is used to identify the driver in
            calls to other ACM functions.
            </param>
            <param name="hinstModule">
            Handle to the instance of the module whose executable or dynamic-link library (DLL) contains the driver entry function.
            </param>
            <param name="lParam">Driver function address or a notification window handle, depending on the fdwAdd flags.</param>
            <param name="dwPriority">
            Window message to send for notification broadcasts. This parameter is used only with the ACM_DRIVERADDF_NOTIFYHWND flag. All
            other flags require this member to be set to zero.
            </param>
            <param name="fdwAdd">
            <para>Flags for adding ACM drivers. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_DRIVERADDF_FUNCTION</term>
            <term>
            The lParam parameter is a driver function address conforming to the acmDriverProc prototype. The function may reside in either
            an executable or DLL file.
            </term>
            </item>
            <item>
            <term>ACM_DRIVERADDF_GLOBAL</term>
            <term>
            Provided for compatibility with 16-bit applications. For the Win32 API, ACM drivers added by the acmDriverAdd function can be
            used only by the application that added the driver. This is true whether or not ACM_DRIVERADDF_GLOBAL is specified. For more
            information, see Adding Drivers Within an Application.
            </term>
            </item>
            <item>
            <term>ACM_DRIVERADDF_LOCAL</term>
            <term>
            The ACM automatically gives a local driver higher priority than a global driver when searching for a driver to satisfy a
            function call. For more information, see Adding Drivers Within an Application.
            </term>
            </item>
            <item>
            <term>ACM_DRIVERADDF_NAME</term>
            <term>
            The lParam parameter is a registry value name in HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Drivers32. The
            value identifies a DLL that implements an ACM codec. Applications can use this flag if new registry entries are created after
            the application has already started using the ACM.
            </term>
            </item>
            <item>
            <term>ACM_DRIVERADDF_NOTIFYHWND</term>
            <term>
            The lParam parameter is a handle of a notification window that receives messages when changes to global driver priorities and
            states are made. The window message to receive is defined by the application and must be passed in dwPriority. The wParam and
            lParam parameters passed with the window message are reserved for future use and should be ignored. ACM_DRIVERADDF_GLOBAL cannot
            be specified in conjunction with this flag. For more information about driver priorities, see the description for the
            acmDriverPriority function.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate resources.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Note</para>
            <para>
            The msacm.h header defines acmDriverAdd as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmDriverClose(Vanara.PInvoke.MsAcm32.HACMDRIVER,System.UInt32)">
            <summary>
            The <c>acmDriverClose</c> function closes a previously opened ACM driver instance. If the function is successful, the handle is invalidated.
            </summary>
            <param name="had">Handle to the open driver instance to be closed.</param>
            <param name="fdwClose">Reserved; must be zero.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_BUSY</term>
            <term>The driver is in use and cannot be closed.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmDriverDetails(Vanara.PInvoke.MsAcm32.HACMDRIVERID,Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS,System.UInt32)">
            <summary>The <c>acmDriverDetails</c> function queries a specified ACM driver to determine its capabilities.</summary>
            <param name="hadid">Handle to the driver identifier of an installed ACM driver. Disabled drivers can be queried for details.</param>
            <param name="padd">
            Pointer to an ACMDRIVERDETAILS structure that will receive the driver details. The <c>cbStruct</c> member must be initialized to
            the size, in bytes, of the structure.
            </param>
            <param name="fdwDetails">Reserved; must be zero.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Note</para>
            <para>
            The msacm.h header defines ACMDRIVERDETAILS as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmDriverEnum(Vanara.PInvoke.MsAcm32.ACMDRIVERENUMCB,System.IntPtr,Vanara.PInvoke.MsAcm32.ACM_DRIVERENUMF)">
            <summary>
            The <c>acmDriverEnum</c> function enumerates the available ACM drivers, continuing until there are no more drivers or the
            callback function returns <c>FALSE</c>.
            </summary>
            <param name="fnCallback">Procedure instance address of the application-defined callback function.</param>
            <param name="dwInstance">
            A 64-bit (DWORD_PTR) or 32-bit (DWORD) application-defined value that is passed to the callback function along with ACM driver information.
            </param>
            <param name="fdwEnum">
            <para>Flags for enumerating ACM drivers. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_DRIVERENUMF_DISABLED</term>
            <term>
            Disabled ACM drivers should be included in the enumeration. Drivers can be disabled by the user through the Control Panel or by
            an application using the acmDriverPriority function. If a driver is disabled, the fdwSupport parameter to the callback function
            will have the ACMDRIVERDETAILS_SUPPORTF_DISABLED flag set.
            </term>
            </item>
            <item>
            <term>ACM_DRIVERENUMF_NOLOCAL</term>
            <term>Only global drivers should be included in the enumeration.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The <c>acmDriverEnum</c> function will return MMSYSERR_NOERROR (zero) if no ACM drivers are installed. Moreover, the callback
            function will not be called.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmDriverID(Vanara.PInvoke.MsAcm32.HACMOBJ,Vanara.PInvoke.MsAcm32.HACMDRIVERID@,System.UInt32)">
            <summary>
            The <c>acmDriverID</c> function returns the handle of an ACM driver identifier associated with an open ACM driver instance or
            stream handle.
            </summary>
            <param name="hao">
            Handle to the open driver instance or stream handle. This is the handle of an ACM object, such as <c>HACMDRIVER</c> or <c>HACMSTREAM</c>.
            </param>
            <param name="phadid">Pointer to a buffer that receives a handle identifying the installed driver that is associated with hao.</param>
            <param name="fdwDriverID">Reserved; must be zero.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmDriverMessage(Vanara.PInvoke.MsAcm32.HACMDRIVER,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>The <c>acmDriverMessage</c> function sends a user-defined message to a given ACM driver instance.</summary>
            <param name="had">Handle to the ACM driver instance to which the message will be sent.</param>
            <param name="uMsg">
            Message that the ACM driver must process. This message must be in the ACMDM_USER message range (above or equal to ACMDM_USER and
            less than ACMDM_RESERVED_LOW). The exceptions to this restriction are the ACMDM_DRIVER_ABOUT, DRV_QUERYCONFIGURE, and
            DRV_CONFIGURE messages.
            </param>
            <param name="lParam1">Message parameter.</param>
            <param name="lParam2">Message parameter.</param>
            <returns>
            <para>
            The return value is specific to the user-defined ACM driver message specified by the uMsg parameter. However, possible error
            values include the following.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>The uMsg parameter is not in the ACMDM_USER range.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>The ACM driver did not process the message.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            To display a custom About dialog box from an ACM driver, an application must send the ACMDM_DRIVER_ABOUT message to the driver.
            The lParam1 parameter should be the handle of the owner window for the custom About dialog box, and lParam2 must be set to zero.
            If the driver does not support a custom About dialog box, MMSYSERR_NOTSUPPORTED will be returned and it is the application's
            responsibility to display its own dialog box. For example, the Control Panel Sound Mapper option will display a default About
            dialog box based on the <c>ACMDRIVERDETAILS</c> structure when an ACM driver returns MMSYSERR_NOTSUPPORTED. An application can
            query a driver for custom About dialog box support without the dialog box being displayed by setting lParam1 to –1L. If the
            driver supports a custom About dialog box, MMSYSERR_NOERROR will be returned. Otherwise, the return value is MMSYSERR_NOTSUPPORTED.
            </para>
            <para>
            User-defined messages must be sent only to an ACM driver that specifically supports the messages. The caller should verify that
            the ACM driver is the correct driver by retrieving the driver details and checking the <c>wMid</c>, <c>wPid</c>, and
            <c>vdwDriver</c> members of the <c>ACMDRIVERDETAILS</c> structure.
            </para>
            <para>Never send user-defined messages to an unknown ACM driver.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmDriverOpen(Vanara.PInvoke.MsAcm32.SafeHACMDRIVER@,Vanara.PInvoke.MsAcm32.HACMDRIVERID,System.UInt32)">
            <summary>
            The <c>acmDriverOpen</c> function opens the specified ACM driver and returns a driver instance handle that can be used to
            communicate with the driver.
            </summary>
            <param name="phad">
            Pointer to a buffer that receives the new driver instance handle that can be used to communicate with the driver.
            </param>
            <param name="hadid">Handle to the driver identifier of an installed and enabled ACM driver.</param>
            <param name="fdwOpen">Reserved; must be zero.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate resources.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTENABLED</term>
            <term>The driver is not enabled.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmDriverPriority(Vanara.PInvoke.MsAcm32.HACMDRIVERID,System.UInt32,Vanara.PInvoke.MsAcm32.ACM_DRIVERPRIORITYF)">
            <summary>The <c>acmDriverPriority</c> function modifies the priority and state of an ACM driver.</summary>
            <param name="hadid">
            Handle to the driver identifier of an installed ACM driver. If the ACM_DRIVERPRIORITYF_BEGIN and ACM_DRIVERPRIORITYF_END flags
            are specified, this parameter must be <c>NULL</c>.
            </param>
            <param name="dwPriority">
            New priority for a global ACM driver identifier. A zero value specifies that the priority of the driver identifier should remain
            unchanged. A value of 1 specifies that the driver should be placed as the highest search priority driver. A value of –1
            specifies that the driver should be placed as the lowest search priority driver. Priorities are used only for global drivers.
            </param>
            <param name="fdwPriority">
            <para>Flags for setting priorities of ACM drivers. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_DRIVERPRIORITYF_BEGIN</term>
            <term>
            Change notification broadcasts should be deferred. An application must reenable notification broadcasts as soon as possible with
            the ACM_DRIVERPRIORITYF_END flag. Note that hadid must be NULL, dwPriority must be zero, and only the ACM_DRIVERPRIORITYF_BEGIN
            flag can be set.
            </term>
            </item>
            <item>
            <term>ACM_DRIVERPRIORITYF_DISABLE</term>
            <term>ACM driver should be disabled if it is currently enabled. Disabling a disabled driver does nothing.</term>
            </item>
            <item>
            <term>ACM_DRIVERPRIORITYF_ENABLE</term>
            <term>ACM driver should be enabled if it is currently disabled. Enabling an enabled driver does nothing.</term>
            </item>
            <item>
            <term>ACM_DRIVERPRIORITYF_END</term>
            <term>
            Calling task wants to reenable change notification broadcasts. An application must call acmDriverPriority with
            ACM_DRIVERPRIORITYF_END for each successful call with the ACM_DRIVERPRIORITYF_BEGIN flag. Note that hadid must be NULL,
            dwPriority must be zero, and only the ACM_DRIVERPRIORITYF_END flag can be set.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_ALLOCATED</term>
            <term>The deferred broadcast lock is owned by a different task.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>
            The requested operation is not supported for the specified driver. For example, local and notify driver identifiers do not
            support priorities (but can be enabled and disabled). If an application specifies a nonzero value for dwPriority for local and
            notify driver identifiers, this error will be returned.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>All driver identifiers can be enabled and disabled, including global, local and notification driver identifiers.</para>
            <para>
            If more than one global driver identifier needs to be enabled, disabled or shifted in priority, an application should defer
            change notification broadcasts by using the ACM_DRIVERPRIORITYF_BEGIN flag. A single change notification will be broadcast when
            the ACM_DRIVERPRIORITYF_END flag is specified.
            </para>
            <para>
            An application can use the function with the <c>acmMetrics</c> ACM_METRIC_DRIVER_PRIORITY metric index to retrieve the current
            priority of a global driver. Drivers are always enumerated from highest to lowest priority by the <c>acmDriverEnum</c> function.
            </para>
            <para>
            All enabled driver identifiers will receive change notifications. An application can register a notification message by using
            the <c>acmDriverAdd</c> function in conjunction with the ACM_DRIVERADDF_NOTIFYHWND flag. Changes to nonglobal driver identifiers
            will not be broadcast.
            </para>
            <para>
            Priorities are simply used for the search order when an application does not specify a driver. Boosting the priority of a driver
            will have no effect on the performance of a driver.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmDriverRemove(Vanara.PInvoke.MsAcm32.HACMDRIVERID,System.UInt32)">
            <summary>
            The <c>acmDriverRemove</c> function removes an ACM driver from the list of available ACM drivers. The driver will be removed for
            the calling application only. If the driver is globally installed, other applications will still be able to use it.
            </summary>
            <param name="hadid">Handle to the driver identifier to be removed.</param>
            <param name="fdwRemove">Reserved; must be zero.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_BUSY</term>
            <term>The driver is in use and cannot be removed.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmFilterChoose(Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE@)">
            <summary>
            The <c>acmFilterChoose</c> function creates an ACM-defined dialog box that enables the user to select a waveform-audio filter.
            </summary>
            <param name="pafltrc">
            <para>
            Pointer to an ACMFILTERCHOOSE structure that contains information used to initialize the dialog box. When <c>acmFilterChoose</c>
            returns, this structure contains information about the user's filter selection.
            </para>
            <para>
            The <c>pwfltr</c> member of this structure must contain a valid pointer to a memory location that will contain the returned
            filter header structure. The <c>cbwfltr</c> member must be filled in with the size, in bytes, of this memory buffer.
            </para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_CANCELED</term>
            <term>The user chose the Cancel button or the Close command on the System menu to close the dialog box.</term>
            </item>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>
            The buffer identified by the [ACMFILTERCHOOSE](./nf-msacm-acmfilterchoose.md) structure is too small to contain the selected filter.
            </term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>A suitable driver is not available to provide valid filter selections.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Note</para>
            <para>
            The msacm.h header defines ACMFILTERCHOOSE as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmFilterDetails(Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.MsAcm32.ACMFILTERDETAILS@,Vanara.PInvoke.MsAcm32.ACM_FILTERDETAILSF)">
            <summary>
            The <c>acmFilterDetails</c> function queries the ACM for details about a filter with a specific waveform-audio filter tag.
            </summary>
            <param name="had">
            Handle to the ACM driver to query for waveform-audio filter details for a filter tag. If this parameter is <c>NULL</c>, the ACM
            uses the details from the first suitable ACM driver.
            </param>
            <param name="pafd">Pointer to the ACMFILTERDETAILS structure that is to receive the filter details for the given filter tag.</param>
            <param name="fdwDetails">
            <para>Flags for getting the details. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_FILTERDETAILSF_FILTER</term>
            <term>
            [ACMFILTERDETAILS](./nf-msacm-acmfilterdetails.md) structure was given and the remaining details should be returned. The
            dwFilterTag member of the ACMFILTERDETAILS structure must be initialized to the same filter tag pwfltr specifies. This query
            type can be used to get a string description of an arbitrary filter structure. If an application specifies an ACM driver handle
            for had , details on the filter will be returned for that driver. If an application specifies NULL for had , the ACM finds the
            first acceptable driver to return the details.
            </term>
            </item>
            <item>
            <term>ACM_FILTERDETAILSF_INDEX</term>
            <term>
            A filter index for the filter tag was given in the dwFilterIndex member of the ACMFILTERDETAILS structure. The filter details
            will be returned in the structure defined by pafd. The index ranges from zero to one less than the cStandardFilters member
            returned in the ACMFILTERTAGDETAILS structure for a filter tag. An application must specify a driver handle for had when
            retrieving filter details with this flag. For information about what members should be initialized before calling this function,
            see the ACMFILTERDETAILS structure.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>The details requested are not available.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Note</para>
            <para>
            The msacm.h header defines ACMFILTERDETAILS as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmFilterEnum(Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.MsAcm32.ACMFILTERDETAILS@,Vanara.PInvoke.MsAcm32.ACMFILTERENUMCB,System.IntPtr,Vanara.PInvoke.MsAcm32.ACM_FILTERENUMF)">
            <summary>
            The <c>acmFilterEnum</c> function enumerates waveform-audio filters available for a given filter tag from an ACM driver. This
            function continues enumerating until there are no more suitable filters for the filter tag or the callback function returns <c>FALSE</c>.
            </summary>
            <param name="had">
            Handle to the ACM driver to query for waveform-audio filter details. If this parameter is <c>NULL</c>, the ACM uses the details
            from the first suitable ACM driver.
            </param>
            <param name="pafd">
            Pointer to the ACMFILTERDETAILS structure that contains the filter details when it is passed to the function specified by
            fnCallback. When your application calls <c>acmFilterEnum</c>, the <c>cbStruct</c>, <c>pwfltr</c>, and <c>cbwfltr</c> members of
            this structure must be initialized. The <c>dwFilterTag</c> member must also be initialized to either WAVE_FILTER_UNKNOWN or a
            valid filter tag.
            </param>
            <param name="fnCallback">Procedure-instance address of the application-defined callback function.</param>
            <param name="dwInstance">
            A 32-bit (DWORD), 64-bit (DWORD_PTR) application-defined value that is passed to the callback function along with ACM filter details.
            </param>
            <param name="fdwEnum">
            <para>Flags for enumerating the filters for a given filter tag. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_FILTERENUMF_DWFILTERTAG</term>
            <term>
            [ACMFILTERDETAILS](./nf-msacm-acmfilterdetails.md) structure is valid. The enumerator will enumerate only a filter that conforms
            to this attribute. The dwFilterTag member of the ACMFILTERDETAILS structure must be equal to the dwFilterTag member of the
            WAVEFILTER structure.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>The details for the filter cannot be returned.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>acmFilterEnum</c> function will return MMSYSERR_NOERROR (zero) if no suitable ACM drivers are installed. Moreover, the
            callback function will not be called.
            </para>
            <para>
            The following functions should not be called from within the callback function: <c>acmDriverAdd</c>, <c>acmDriverRemove</c>, and <c>acmDriverPriority</c>.
            </para>
            <para>
            <para>Note</para>
            <para>
            The msacm.h header defines acmFilterEnum as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmFilterTagDetails(Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.MsAcm32.ACMFILTERTAGDETAILS@,Vanara.PInvoke.MsAcm32.ACM_FILTERTAGDETAILSF)">
            <summary>The <c>acmFilterTagDetails</c> function queries the ACM for details about a specific waveform-audio filter tag.</summary>
            <param name="had">
            Handle to the ACM driver to query for waveform-audio filter tag details. If this parameter is <c>NULL</c>, the ACM uses the
            details from the first suitable ACM driver. An application must specify a valid <c>HACMDRIVER</c> or <c>HACMDRIVERID</c>
            identifier when using the ACM_FILTERTAGDETAILSF_INDEX query type. Driver identifiers for disabled drivers are not allowed.
            </param>
            <param name="paftd">Pointer to the ACMFILTERTAGDETAILS structure that is to receive the filter tag details.</param>
            <param name="fdwDetails">
            <para>Flags for getting the details. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_FILTERTAGDETAILSF_FILTERTAG</term>
            <term>
            [ACMFILTERTAGDETAILS](./nf-msacm-acmfiltertagdetails.md) structure. The filter tag details will be returned in the structure
            pointed to by paftd . If an application specifies an ACM driver handle for had , details on the filter tag will be returned for
            that driver. If an application specifies NULL for had , the ACM finds the first acceptable driver to return the details.
            </term>
            </item>
            <item>
            <term>ACM_FILTERTAGDETAILSF_INDEX</term>
            <term>
            [ACMDRIVERDETAILS](./nf-msacm-acmdriverdetails.md) structure for an ACM driver. An application must specify a driver handle for
            had when retrieving filter tag details with this flag.
            </term>
            </item>
            <item>
            <term>ACM_FILTERTAGDETAILSF_LARGESTSIZE</term>
            <term>
            Details on the filter tag with the largest filter size, in bytes, are to be returned. The dwFilterTag member must either be
            WAVE_FILTER_UNKNOWN or the filter tag to find the largest size for. If an application specifies an ACM driver handle for had,
            details on the largest filter tag will be returned for that driver. If an application specifies NULL for had, the ACM finds an
            acceptable driver with the largest filter tag requested to return the details.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>The details requested are not available.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Note</para>
            <para>
            The msacm.h header defines ACMFILTERTAGDETAILS as an alias which automatically selects the ANSI or Unicode version of this
            function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that
            not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions
            for Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmFilterTagEnum(Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.MsAcm32.ACMFILTERTAGDETAILS@,Vanara.PInvoke.MsAcm32.ACMFILTERTAGENUMCB,System.IntPtr,System.UInt32)">
            <summary>
            The <c>acmFilterTagEnum</c> function enumerates waveform-audio filter tags available from an ACM driver. This function continues
            enumerating until there are no more suitable filter tags or the callback function returns <c>FALSE</c>.
            </summary>
            <param name="had">
            Handle to the ACM driver to query for waveform-audio filter tag details. If this parameter is <c>NULL</c>, the ACM uses the
            details from the first suitable ACM driver.
            </param>
            <param name="paftd">
            Pointer to the ACMFILTERTAGDETAILS structure that contains the filter tag details when it is passed to the <c>fnCallback</c>
            function. When your application calls <c>acmFilterTagEnum</c>, the <c>cbStruct</c> member of this structure must be initialized.
            </param>
            <param name="fnCallback">Procedure instance address of the application-defined callback function.</param>
            <param name="dwInstance">
            A 64-bit (DWORD_PTR) or 32-bit (DWORD) application-defined value that is passed to the callback function along with ACM filter
            tag details.
            </param>
            <param name="fdwEnum">Reserved; must be zero.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function will return MMSYSERR_NOERROR (zero) if no suitable ACM drivers are installed. Moreover, the callback function will
            not be called.
            </para>
            <para>
            <para>Note</para>
            <para>
            The msacm.h header defines acmFilterTagEnum as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmFormatChoose(Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE@)">
            <summary>
            The <c>acmFormatChoose</c> function creates an ACM-defined dialog box that enables the user to select a waveform-audio format.
            </summary>
            <param name="pafmtc">
            <para>
            Pointer to an ACMFORMATCHOOSE structure that contains information used to initialize the dialog box. When this function returns,
            this structure contains information about the user's format selection.
            </para>
            <para>
            The <c>pwfx</c> member of this structure must contain a valid pointer to a memory location that will contain the returned format
            header structure. Moreover, the <c>cbwfx</c> member must be filled in with the size, in bytes, of this memory buffer.
            </para>
            </param>
            <returns>
            <para>Returns MMSYSERR_NOERROR if successful or an error otherwise. Possible return values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_CANCELED</term>
            <term>The user chose the Cancel button or the Close command on the System menu to close the dialog box.</term>
            </item>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>The buffer identified by the pwfx member of the ACMFORMATCHOOSE structure is too small to contain the selected format.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NODRIVER</term>
            <term>A suitable driver is not available to provide valid format selections.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Note</para>
            <para>
            The msacm.h header defines ACMFORMATCHOOSE as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmFormatDetails(Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.MsAcm32.ACMFORMATDETAILS@,Vanara.PInvoke.MsAcm32.ACM_FORMATDETAILSF)">
            <summary>The <c>acmFormatDetails</c> function queries the ACM for format details for a specific waveform-audio format tag.</summary>
            <param name="had">
            Handle to the ACM driver to query for waveform-audio format details for a format tag. If this parameter is <c>NULL</c>, the ACM
            uses the details from the first suitable ACM driver.
            </param>
            <param name="pafd">Pointer to an ACMFORMATDETAILS structure to contain the format details for the given format tag.</param>
            <param name="fdwDetails">
            <para>Flags for getting the waveform-audio format tag details. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_FORMATDETAILSF_FORMAT</term>
            <term>
            ACMFORMATDETAILS structure was given and the remaining details should be returned. The dwFormatTag member of the
            ACMFORMATDETAILS structure must be initialized to the same format tag as pwfx specifies. This query type can be used to get a
            string description of an arbitrary format structure. If an application specifies an ACM driver handle for had , details on the
            format will be returned for that driver. If an application specifies NULL for had , the ACM finds the first acceptable driver to
            return the details.
            </term>
            </item>
            <item>
            <term>ACM_FORMATDETAILSF_INDEX</term>
            <term>
            A format index for the format tag was given in the dwFormatIndex member of the ACMFORMATDETAILS structure. The format details
            will be returned in the structure defined by pafd. The index ranges from zero to one less than the cStandardFormats member
            returned in the ACMFORMATTAGDETAILS structure for a format tag. An application must specify a driver handle for had when
            retrieving format details with this flag. For information about which members should be initialized before calling this
            function, see the ACMFORMATDETAILS structure.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>The details requested are not available.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Note</para>
            <para>
            The msacm.h header defines ACMFORMATDETAILS as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmFormatEnum(Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.MsAcm32.ACMFORMATDETAILS@,Vanara.PInvoke.MsAcm32.ACMFORMATENUMCB,System.IntPtr,Vanara.PInvoke.MsAcm32.ACM_FORMATENUMF)">
            <summary>
            The <c>acmFormatEnum</c> function enumerates waveform-audio formats available for a given format tag from an ACM driver. This
            function continues enumerating until there are no more suitable formats for the format tag or the callback function returns <c>FALSE</c>.
            </summary>
            <param name="had">
            Handle to the ACM driver to query for waveform-audio format details. If this parameter is <c>NULL</c>, the ACM uses the details
            from the first suitable ACM driver.
            </param>
            <param name="pafd">
            <para>
            Pointer to an ACMFORMATDETAILS structure to contain the format details passed to the <c>fnCallback</c> function. This structure
            must have the <c>cbStruct</c>, <c>pwfx</c>, and <c>cbwfx</c> members of the <c>ACMFORMATDETAILS</c> structure initialized. The
            <c>dwFormatTag</c> member must also be initialized to either WAVE_FORMAT_UNKNOWN or a valid format tag.
            </para>
            <para>The <c>fdwSupport</c> member of the structure must be initialized to zero.</para>
            <para>To find the required size of the <c>pwfx</c> buffer, call acmMetrics with the ACM_METRIC_MAX_SIZE_FORMAT flag.</para>
            </param>
            <param name="fnCallback">
            Address of an application-defined callback function. See acmFormatEnumCallback. This parameter cannot be <c>NULL</c>.
            </param>
            <param name="dwInstance">
            A 64-bit (DWORD_PTR) or 32-bit (DWORD) application-defined value that is passed to the callback function along with ACM format details.
            </param>
            <param name="fdwEnum">
            <para>Flags for enumerating the formats for a given format tag. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_FORMATENUMF_CONVERT</term>
            <term>
            ACMFORMATDETAILS structure is valid. The enumerator will only enumerate destination formats that can be converted from the given
            pwfx format.If this flag is used, the wFormatTag member of the WAVEFORMATEX structure cannot be WAVE_FORMAT_UNKNOWN.
            </term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_HARDWARE</term>
            <term>
            The enumerator should only enumerate formats that are supported as native input or output formats on one or more of the
            installed waveform-audio devices. This flag provides a way for an application to choose only formats native to an installed
            waveform-audio device. This flag must be used with one or both of the ACM_FORMATENUMF_INPUT and ACM_FORMATENUMF_OUTPUT flags.
            Specifying both ACM_FORMATENUMF_INPUT and ACM_FORMATENUMF_OUTPUT will enumerate only formats that can be opened for input or
            output. This is true regardless of whether this flag is specified.
            </term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_INPUT</term>
            <term>Enumerator should enumerate only formats that are supported for input (recording).</term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_NCHANNELS</term>
            <term>ACMFORMATDETAILS structure is valid. The enumerator will enumerate only a format that conforms to this attribute.</term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_NSAMPLESPERSEC</term>
            <term>
            The nSamplesPerSec member of the WAVEFORMATEX structure pointed to by the pwfx member of the ACMFORMATDETAILS structure is
            valid. The enumerator will enumerate only a format that conforms to this attribute.
            </term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_OUTPUT</term>
            <term>Enumerator should enumerate only formats that are supported for output (playback).</term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_SUGGEST</term>
            <term>
            ACMFORMATDETAILS structure is valid. The enumerator will enumerate all suggested destination formats for the given pwfx format.
            This mechanism can be used instead of the acmFormatSuggest function to allow an application to choose the best suggested format
            for conversion. The dwFormatIndex member will always be set to zero on return.If this flag is used, the wFormatTag member of the
            WAVEFORMATEX structure cannot be WAVE_FORMAT_UNKNOWN.
            </term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_WBITSPERSAMPLE</term>
            <term>
            The wBitsPerSample member of the WAVEFORMATEX structure pointed to by the pwfx member of the ACMFORMATDETAILS structure is
            valid. The enumerator will enumerate only a format that conforms to this attribute.
            </term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_WFORMATTAG</term>
            <term>
            The wFormatTag member of the WAVEFORMATEX structure pointed to by the pwfx member of the ACMFORMATDETAILS structure is valid.
            The enumerator will enumerate only a format that conforms to this attribute. The dwFormatTag member of the ACMFORMATDETAILS
            structure must be equal to the wFormatTag member.The value of wFormatTag cannot be WAVE_FORMAT_UNKNOWN in this case.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>The details for the format cannot be returned.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function will return MMSYSERR_NOERROR (zero) if no suitable ACM drivers are installed. Moreover, the callback function will
            not be called.
            </para>
            <para>Examples</para>
            <para>The following example shows how to enumerate formats that have the WAVE_FORMAT_MPEGLAYER3 format tag.</para>
            <para>
            <code> MMRESULT EnumerateMP3Codecs() { DWORD cbMaxSize = 0; MMRESULT result = MMSYSERR_NOERROR; ACMFORMATDETAILS acmFormatDetails; // Buffer to hold the format information. BYTE *pFormat = NULL; // Caller allocated. // Find the largest format buffer needed. result = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &amp;cbMaxSize); if (result != MMSYSERR_NOERROR) { return result; } // Allocate the format buffer. pFormat = new BYTE[cbMaxSize]; if (pFormat == NULL) { return MMSYSERR_NOMEM; } ZeroMemory(pFormat, cbMaxSize); // Ask for WAVE_FORMAT_MPEGLAYER3 formats. WAVEFORMATEX* pWaveFormat = (WAVEFORMATEX*)pFormat; pWaveFormat-&gt;wFormatTag = WAVE_FORMAT_MPEGLAYER3; // Set up the acmFormatDetails structure. ZeroMemory(&amp;acmFormatDetails, sizeof(acmFormatDetails)); acmFormatDetails.cbStruct = sizeof(ACMFORMATDETAILS); acmFormatDetails.pwfx = pWaveFormat; acmFormatDetails.cbwfx = cbMaxSize; // For the ACM_FORMATENUMF_WFORMATTAG request, the format // tag in acmFormatDetails must match the format tag in // the pFormat buffer. acmFormatDetails.dwFormatTag = WAVE_FORMAT_MPEGLAYER3; result = acmFormatEnum(NULL, &amp;acmFormatDetails, acmFormatEnumCallback, 0, ACM_FORMATENUMF_WFORMATTAG); delete [] pFormat; return result; }</code>
            </para>
            <para>
            The next example shows the callback function for the previous example. The callback function is called once for each matching
            format or until the callback returns <c>FALSE</c>.
            </para>
            <para>
            <code> BOOL CALLBACK acmFormatEnumCallback( HACMDRIVERID hadid, LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport ) { BOOL bContinue = TRUE; MPEGLAYER3WAVEFORMAT *pMP3WaveFormat = NULL; if (pafd-&gt;pwfx-&gt;wFormatTag == WAVE_FORMAT_MPEGLAYER3) { pMP3WaveFormat = (MPEGLAYER3WAVEFORMAT*)pafd-&gt;pwfx; // TODO: Examine the format. // To halt the enumeration, set bContinue to FALSE. } return bContinue; }</code>
            </para>
            <para>
            <para>Note</para>
            <para>
            The msacm.h header defines acmFormatEnum as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmFormatSuggest(Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.WinMm.WAVEFORMATEX@,Vanara.PInvoke.WinMm.WAVEFORMATEX@,System.UInt32,Vanara.PInvoke.MsAcm32.ACM_FORMATSUGGESTF)">
            <summary>
            The <c>acmFormatSuggest</c> function queries the ACM or a specified ACM driver to suggest a destination format for the supplied
            source format. For example, an application can use this function to determine one or more valid PCM formats to which a
            compressed format can be decompressed.
            </summary>
            <param name="had">
            Handle to an open instance of a driver to query for a suggested destination format. If this parameter is <c>NULL</c>, the ACM
            attempts to find the best driver to suggest a destination format.
            </param>
            <param name="pwfxSrc">
            Pointer to a WAVEFORMATEX structure that identifies the source format for which a destination format will be suggested by the
            ACM or specified driver.
            </param>
            <param name="pwfxDst">
            Pointer to a WAVEFORMATEX structure that will receive the suggested destination format for the pwfxSrc format. Depending on the
            fdwSuggest parameter, some members of the structure pointed to by pwfxDst may require initialization.
            </param>
            <param name="cbwfxDst">
            Size, in bytes, available for the destination format. The acmMetrics and acmFormatTagDetails functions can be used to determine
            the maximum size required for any format available for the specified driver (or for all installed ACM drivers).
            </param>
            <param name="fdwSuggest">
            <para>Flags for matching the desired destination format. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <description>ACM_FORMATSUGGESTF_NCHANNELS</description>
            <description>
            The nChannels member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that can
            suggest a destination format matching nChannels or fail.
            </description>
            </item>
            <item>
            <description>ACM_FORMATSUGGESTF_NSAMPLESPERSEC</description>
            <description>
            The nSamplesPerSec member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that
            can suggest a destination format matching nSamplesPerSec or fail.
            </description>
            </item>
            <item>
            <description>ACM_FORMATSUGGESTF_WBITSPERSAMPLE</description>
            <description>
            The wBitsPerSample member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that
            can suggest a destination format matching wBitsPerSample or fail.
            </description>
            </item>
            <item>
            <description>ACM_FORMATSUGGESTF_WFORMATTAG</description>
            <description>
            The wFormatTag member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that can
            suggest a destination format matching wFormatTag or fail.
            </description>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <description>MMSYSERR_INVALFLAG</description>
            <description>At least one flag is invalid.</description>
            </item>
            <item>
            <description>MMSYSERR_INVALHANDLE</description>
            <description>The specified handle is invalid.</description>
            </item>
            <item>
            <description>MMSYSERR_INVALPARAM</description>
            <description>At least one parameter is invalid.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmFormatSuggest(Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.WinMm.WAVEFORMATEX@,System.IntPtr,System.UInt32,Vanara.PInvoke.MsAcm32.ACM_FORMATSUGGESTF)">
            <summary>
            The <c>acmFormatSuggest</c> function queries the ACM or a specified ACM driver to suggest a destination format for the supplied
            source format. For example, an application can use this function to determine one or more valid PCM formats to which a
            compressed format can be decompressed.
            </summary>
            <param name="had">
            Handle to an open instance of a driver to query for a suggested destination format. If this parameter is <c>NULL</c>, the ACM
            attempts to find the best driver to suggest a destination format.
            </param>
            <param name="pwfxSrc">
            Pointer to a WAVEFORMATEX structure that identifies the source format for which a destination format will be suggested by the
            ACM or specified driver.
            </param>
            <param name="pwfxDst">
            Pointer to a WAVEFORMATEX structure that will receive the suggested destination format for the pwfxSrc format. Depending on the
            fdwSuggest parameter, some members of the structure pointed to by pwfxDst may require initialization.
            </param>
            <param name="cbwfxDst">
            Size, in bytes, available for the destination format. The acmMetrics and acmFormatTagDetails functions can be used to determine
            the maximum size required for any format available for the specified driver (or for all installed ACM drivers).
            </param>
            <param name="fdwSuggest">
            <para>Flags for matching the desired destination format. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <description>ACM_FORMATSUGGESTF_NCHANNELS</description>
            <description>
            The nChannels member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that can
            suggest a destination format matching nChannels or fail.
            </description>
            </item>
            <item>
            <description>ACM_FORMATSUGGESTF_NSAMPLESPERSEC</description>
            <description>
            The nSamplesPerSec member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that
            can suggest a destination format matching nSamplesPerSec or fail.
            </description>
            </item>
            <item>
            <description>ACM_FORMATSUGGESTF_WBITSPERSAMPLE</description>
            <description>
            The wBitsPerSample member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that
            can suggest a destination format matching wBitsPerSample or fail.
            </description>
            </item>
            <item>
            <description>ACM_FORMATSUGGESTF_WFORMATTAG</description>
            <description>
            The wFormatTag member of the structure pointed to by pwfxDst is valid. The ACM will query acceptable installed drivers that can
            suggest a destination format matching wFormatTag or fail.
            </description>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <description>MMSYSERR_INVALFLAG</description>
            <description>At least one flag is invalid.</description>
            </item>
            <item>
            <description>MMSYSERR_INVALHANDLE</description>
            <description>The specified handle is invalid.</description>
            </item>
            <item>
            <description>MMSYSERR_INVALPARAM</description>
            <description>At least one parameter is invalid.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmFormatTagDetails(Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.MsAcm32.ACMFORMATTAGDETAILS@,Vanara.PInvoke.MsAcm32.ACM_FORMATTAGDETAILSF)">
            <summary>The <c>acmFormatTagDetails</c> function queries the ACM for details on a specific waveform-audio format tag.</summary>
            <param name="had">
            Handle to the ACM driver to query for waveform-audio format tag details. If this parameter is <c>NULL</c>, the ACM uses the
            details from the first suitable ACM driver. An application must specify a valid handle or driver identifier when using the
            ACM_FORMATTAGDETAILSF_INDEX query type. Driver identifiers for disabled drivers are not allowed.
            </param>
            <param name="paftd">Pointer to the ACMFORMATTAGDETAILS structure that is to receive the format tag details.</param>
            <param name="fdwDetails">
            <para>Flags for getting the details. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_FORMATTAGDETAILSF_FORMATTAG</term>
            <term>
            ACMFORMATTAGDETAILS structure. The format tag details will be returned in the structure pointed to bypaftd. If an application
            specifies an ACM driver handle forhad, details on the format tag will be returned for that driver. If an application
            specifiesNULLforhad, the ACM finds the first acceptable driver to return the details.
            </term>
            </item>
            <item>
            <term>ACM_FORMATTAGDETAILSF_INDEX</term>
            <term>
            ACMDRIVERDETAILS structure for an ACM driver. An application must specify a driver handle forhadwhen retrieving format tag
            details with this flag.
            </term>
            </item>
            <item>
            <term>ACM_FORMATTAGDETAILSF_LARGESTSIZE</term>
            <term>
            ACMFORMATTAGDETAILS structure must either be WAVE_FORMAT_UNKNOWN or the format tag to find the largest size for. If an
            application specifies an ACM driver handle forhad, details on the largest format tag will be returned for that driver. If an
            application specifiesNULLforhad, the ACM finds an acceptable driver with the largest format tag requested to return the details.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>The details requested are not available.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Note</para>
            <para>
            The msacm.h header defines ACMFORMATTAGDETAILS as an alias which automatically selects the ANSI or Unicode version of this
            function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that
            not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions
            for Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmFormatTagEnum(Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.MsAcm32.ACMFORMATTAGDETAILS@,Vanara.PInvoke.MsAcm32.ACMFORMATTAGENUMCB,System.IntPtr,System.UInt32)">
            <summary>
            The <c>acmFormatTagEnum</c> function enumerates waveform-audio format tags available from an ACM driver. This function continues
            enumerating until there are no more suitable format tags or the callback function returns <c>FALSE</c>.
            </summary>
            <param name="had">
            Handle to the ACM driver to query for waveform-audio format tag details. If this parameter is <c>NULL</c>, the ACM uses the
            details from the first suitable ACM driver.
            </param>
            <param name="paftd">
            Pointer to the ACMFORMATTAGDETAILS structure that is to receive the format tag details passed to the function specified in
            fnCallback. This structure must have the <c>cbStruct</c> member of the <c>ACMFORMATTAGDETAILS</c> structure initialized.
            </param>
            <param name="fnCallback">Procedure instance address of the application-defined callback function.</param>
            <param name="dwInstance">
            A 64-bit (DWORD_PTR) or 32-bit (DWORD) application-defined value that is passed to the callback function along with ACM format
            tag details.
            </param>
            <param name="fdwEnum">Reserved; must be zero.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function will return MMSYSERR_NOERROR (zero) if no suitable ACM drivers are installed. Moreover, the callback function will
            not be called.
            </para>
            <para>
            <para>Note</para>
            <para>
            The msacm.h header defines acmFormatTagEnum as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmGetVersion">
            <summary>The <c>acmGetVersion</c> function returns the version number of the ACM.</summary>
            <returns>
            The version number is returned as a hexadecimal number of the form 0xAABBCCCC, where AA is the major version number, BB is the
            minor version number, and CCCC is the build number.
            </returns>
            <remarks>
            <para>
            Win32 applications must verify that the ACM version is at least 0x03320000 (version 3.50) or greater before attempting to use
            any other ACM functions. The build number (CCCC) is always zero for the retail (non-debug) version of the ACM.
            </para>
            <para>
            To display the ACM version for a user, an application should use the following format (note that the values should be printed as
            unsigned decimals):
            </para>
            <para>
            <code> { DWORD dw; TCHAR ach[10]; dw = acmGetVersion(); _stprintf_s(ach, TEXT("%u.%.02u"), HIWORD(dw) &gt;&gt; 8, HIWORD(dw) &amp; 0x00FF); }</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmMetrics(Vanara.PInvoke.MsAcm32.HACMOBJ,Vanara.PInvoke.MsAcm32.ACM_METRIC,System.IntPtr)">
            <summary>The <c>acmMetrics</c> function returns various metrics for the ACM or related ACM objects.</summary>
            <param name="hao">
            Handle to the ACM object to query for the metric specified in uMetric. For some queries, this parameter can be <c>NULL</c>.
            </param>
            <param name="uMetric">
            <para>Metric index to be returned in pMetric.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_METRIC_COUNT_CODECS</term>
            <term>
            Returned value is the number of global ACM compressor or decompressor drivers in the system. The hao parameter must be NULL for
            this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_CONVERTERS</term>
            <term>
            Returned value is the number of global ACM converter drivers in the system. The hao parameter must be NULL for this metric
            index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_DISABLED</term>
            <term>
            Returned value is the total number of global disabled ACM drivers (of all support types) in the system. The hao parameter must
            be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. The sum of the
            ACM_METRIC_COUNT_DRIVERS and ACM_METRIC_COUNT_DISABLED metric indices is the total number of globally installed ACM drivers.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_DRIVERS</term>
            <term>
            Returned value is the total number of enabled global ACM drivers (of all support types) in the system. The hao parameter must be
            NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_FILTERS</term>
            <term>
            Returned value is the number of global ACM filter drivers in the system. The hao parameter must be NULL for this metric index.
            The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_HARDWARE</term>
            <term>
            Returned value is the number of global ACM hardware drivers in the system. The hao parameter must be NULL for this metric index.
            The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_LOCAL_CODECS</term>
            <term>
            Returned value is the number of local ACM compressor drivers, ACM decompressor drivers, or both for the calling task. The hao
            parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_LOCAL_CONVERTERS</term>
            <term>
            Returned value is the number of local ACM converter drivers for the calling task. The hao parameter must be NULL for this metric
            index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_LOCAL_DISABLED</term>
            <term>
            Returned value is the total number of local disabled ACM drivers, of all support types, for the calling task. The hao parameter
            must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. The sum of
            the ACM_METRIC_COUNT_LOCAL_DRIVERS and ACM_METRIC_COUNT_LOCAL_DISABLED metric indices is the total number of locally installed
            ACM drivers.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_LOCAL_DRIVERS</term>
            <term>
            Returned value is the total number of enabled local ACM drivers (of all support types) for the calling task. The hao parameter
            must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_LOCAL_FILTERS</term>
            <term>
            Returned value is the number of local ACM filter drivers for the calling task. The hao parameter must be NULL for this metric
            index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_DRIVER_PRIORITY</term>
            <term>
            Returned value is the current priority for the specified driver. The hao parameter must be a valid ACM driver identifier of the
            HACMDRIVERID data type. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_DRIVER_SUPPORT</term>
            <term>
            Returned value is the fdwSupport flags for the specified driver. The hao parameter must be a valid ACM driver identifier of the
            HACMDRIVERID data type. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_HARDWARE_WAVE_INPUT</term>
            <term>
            Returned value is the waveform-audio input device identifier associated with the specified driver. The hao parameter must be a
            valid ACM driver identifier of the HACMDRIVERID data type that supports the ACMDRIVERDETAILS_SUPPORTF_HARDWARE flag. If no
            waveform-audio input device is associated with the driver, MMSYSERR_NOTSUPPORTED is returned. The pMetric parameter must point
            to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_HARDWARE_WAVE_OUTPUT</term>
            <term>
            Returned value is the waveform-audio output device identifier associated with the specified driver. The hao parameter must be a
            valid ACM driver identifier of the HACMDRIVERID data type that supports the ACMDRIVERDETAILS_SUPPORTF_HARDWARE flag. If no
            waveform-audio output device is associated with the driver, MMSYSERR_NOTSUPPORTED is returned. The pMetric parameter must point
            to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_MAX_SIZE_FILTER</term>
            <term>
            Returned value is the size of the largest WAVEFILTER structure. If hao is NULL, the return value is the largest WAVEFILTER
            structure in the system. If hao identifies an open instance of an ACM driver of the HACMDRIVER data type or an ACM driver
            identifier of the HACMDRIVERID data type, the largest WAVEFILTER structure for that driver is returned. The pMetric parameter
            must point to a buffer of a size equal to a DWORD value. This metric is not allowed for an ACM stream handle of the HACMSTREAM
            data type.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_MAX_SIZE_FORMAT</term>
            <term>
            Returned value is the size of the largest WAVEFORMATEX structure. If hao is NULL, the return value is the largest WAVEFORMATEX
            structure in the system. If hao identifies an open instance of an ACM driver of the HACMDRIVER data type or an ACM driver
            identifier of the HACMDRIVERID data type, the largest WAVEFORMATEX structure for that driver is returned. The pMetric parameter
            must point to a buffer of a size equal to a DWORD value. This metric is not allowed for an ACM stream handle of the HACMSTREAM
            data type.
            </term>
            </item>
            </list>
            </param>
            <param name="pMetric">Pointer to the buffer to receive the metric details. The exact definition depends on the uMetric index.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>The index specified in uMetric cannot be returned for the specified hao.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>The index specified in uMetric is not supported.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmMetrics(Vanara.PInvoke.MsAcm32.HACMOBJ,Vanara.PInvoke.MsAcm32.ACM_METRIC,System.UInt32@)">
            <summary>The <c>acmMetrics</c> function returns various metrics for the ACM or related ACM objects.</summary>
            <param name="hao">
            Handle to the ACM object to query for the metric specified in uMetric. For some queries, this parameter can be <c>NULL</c>.
            </param>
            <param name="uMetric">
            <para>Metric index to be returned in pMetric.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_METRIC_COUNT_CODECS</term>
            <term>
            Returned value is the number of global ACM compressor or decompressor drivers in the system. The hao parameter must be NULL for
            this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_CONVERTERS</term>
            <term>
            Returned value is the number of global ACM converter drivers in the system. The hao parameter must be NULL for this metric
            index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_DISABLED</term>
            <term>
            Returned value is the total number of global disabled ACM drivers (of all support types) in the system. The hao parameter must
            be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. The sum of the
            ACM_METRIC_COUNT_DRIVERS and ACM_METRIC_COUNT_DISABLED metric indices is the total number of globally installed ACM drivers.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_DRIVERS</term>
            <term>
            Returned value is the total number of enabled global ACM drivers (of all support types) in the system. The hao parameter must be
            NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_FILTERS</term>
            <term>
            Returned value is the number of global ACM filter drivers in the system. The hao parameter must be NULL for this metric index.
            The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_HARDWARE</term>
            <term>
            Returned value is the number of global ACM hardware drivers in the system. The hao parameter must be NULL for this metric index.
            The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_LOCAL_CODECS</term>
            <term>
            Returned value is the number of local ACM compressor drivers, ACM decompressor drivers, or both for the calling task. The hao
            parameter must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_LOCAL_CONVERTERS</term>
            <term>
            Returned value is the number of local ACM converter drivers for the calling task. The hao parameter must be NULL for this metric
            index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_LOCAL_DISABLED</term>
            <term>
            Returned value is the total number of local disabled ACM drivers, of all support types, for the calling task. The hao parameter
            must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value. The sum of
            the ACM_METRIC_COUNT_LOCAL_DRIVERS and ACM_METRIC_COUNT_LOCAL_DISABLED metric indices is the total number of locally installed
            ACM drivers.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_LOCAL_DRIVERS</term>
            <term>
            Returned value is the total number of enabled local ACM drivers (of all support types) for the calling task. The hao parameter
            must be NULL for this metric index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_COUNT_LOCAL_FILTERS</term>
            <term>
            Returned value is the number of local ACM filter drivers for the calling task. The hao parameter must be NULL for this metric
            index. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_DRIVER_PRIORITY</term>
            <term>
            Returned value is the current priority for the specified driver. The hao parameter must be a valid ACM driver identifier of the
            HACMDRIVERID data type. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_DRIVER_SUPPORT</term>
            <term>
            Returned value is the fdwSupport flags for the specified driver. The hao parameter must be a valid ACM driver identifier of the
            HACMDRIVERID data type. The pMetric parameter must point to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_HARDWARE_WAVE_INPUT</term>
            <term>
            Returned value is the waveform-audio input device identifier associated with the specified driver. The hao parameter must be a
            valid ACM driver identifier of the HACMDRIVERID data type that supports the ACMDRIVERDETAILS_SUPPORTF_HARDWARE flag. If no
            waveform-audio input device is associated with the driver, MMSYSERR_NOTSUPPORTED is returned. The pMetric parameter must point
            to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_HARDWARE_WAVE_OUTPUT</term>
            <term>
            Returned value is the waveform-audio output device identifier associated with the specified driver. The hao parameter must be a
            valid ACM driver identifier of the HACMDRIVERID data type that supports the ACMDRIVERDETAILS_SUPPORTF_HARDWARE flag. If no
            waveform-audio output device is associated with the driver, MMSYSERR_NOTSUPPORTED is returned. The pMetric parameter must point
            to a buffer of a size equal to a DWORD value.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_MAX_SIZE_FILTER</term>
            <term>
            Returned value is the size of the largest WAVEFILTER structure. If hao is NULL, the return value is the largest WAVEFILTER
            structure in the system. If hao identifies an open instance of an ACM driver of the HACMDRIVER data type or an ACM driver
            identifier of the HACMDRIVERID data type, the largest WAVEFILTER structure for that driver is returned. The pMetric parameter
            must point to a buffer of a size equal to a DWORD value. This metric is not allowed for an ACM stream handle of the HACMSTREAM
            data type.
            </term>
            </item>
            <item>
            <term>ACM_METRIC_MAX_SIZE_FORMAT</term>
            <term>
            Returned value is the size of the largest WAVEFORMATEX structure. If hao is NULL, the return value is the largest WAVEFORMATEX
            structure in the system. If hao identifies an open instance of an ACM driver of the HACMDRIVER data type or an ACM driver
            identifier of the HACMDRIVERID data type, the largest WAVEFORMATEX structure for that driver is returned. The pMetric parameter
            must point to a buffer of a size equal to a DWORD value. This metric is not allowed for an ACM stream handle of the HACMSTREAM
            data type.
            </term>
            </item>
            </list>
            </param>
            <param name="pMetric">Pointer to the buffer to receive the metric details. The exact definition depends on the uMetric index.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>The index specified in uMetric cannot be returned for the specified hao.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOTSUPPORTED</term>
            <term>The index specified in uMetric is not supported.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmStreamClose(Vanara.PInvoke.MsAcm32.HACMSTREAM,System.UInt32)">
            <summary>
            The <c>acmStreamClose</c> function closes an ACM conversion stream. If the function is successful, the handle is invalidated.
            </summary>
            <param name="has">Handle to the open conversion stream to be closed.</param>
            <param name="fdwClose">Reserved; must be zero.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_BUSY</term>
            <term>The conversion stream cannot be closed because an asynchronous conversion is still in progress.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmStreamConvert(Vanara.PInvoke.MsAcm32.HACMSTREAM,Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER@,Vanara.PInvoke.MsAcm32.ACM_STREAMCONVERTF)">
            <summary>
            The <c>acmStreamConvert</c> function requests the ACM to perform a conversion on the specified conversion stream. A conversion
            may be synchronous or asynchronous, depending on how the stream was opened.
            </summary>
            <param name="has">Handle to the open conversion stream.</param>
            <param name="pash">
            Pointer to a stream header that describes source and destination buffers for a conversion. This header must have been prepared
            previously by using the acmStreamPrepareHeader function.
            </param>
            <param name="fdwConvert">
            <para>Flags for doing the conversion. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_STREAMCONVERTF_BLOCKALIGN</term>
            <term>
            Only integral numbers of blocks will be converted. Converted data will end on block-aligned boundaries. An application should
            use this flag for all conversions on a stream until there is not enough source data to convert to a block-aligned destination.
            In this case, the last conversion should be specified without this flag.
            </term>
            </item>
            <item>
            <term>ACM_STREAMCONVERTF_END</term>
            <term>
            ACM conversion stream should begin returning pending instance data. For example, if a conversion stream holds instance data,
            such as the end of an echo filter operation, this flag will cause the stream to start returning this remaining data with
            optional source data. This flag can be specified with the ACM_STREAMCONVERTF_START flag.
            </term>
            </item>
            <item>
            <term>ACM_STREAMCONVERTF_START</term>
            <term>
            ACM conversion stream should reinitialize its instance data. For example, if a conversion stream holds instance data, such as
            delta or predictor information, this flag will restore the stream to starting defaults. This flag can be specified with the
            ACM_STREAMCONVERTF_END flag.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_BUSY</term>
            <term>The stream header specified in pash is currently in use and cannot be reused.</term>
            </item>
            <item>
            <term>ACMERR_UNPREPARED</term>
            <term>The stream header specified in pash is currently not prepared by the acmStreamPrepareHeader function.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            You must use the acmStreamPrepareHeader function to prepare the source and destination buffers before they are passed to <c>acmStreamConvert</c>.
            </para>
            <para>
            If an asynchronous conversion request is successfully queued by the ACM or driver and the conversion is later determined to be
            impossible, the ACMSTREAMHEADER structure is posted back to the application's callback function with the <c>cbDstLengthUsed</c>
            member set to zero.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmStreamMessage(Vanara.PInvoke.MsAcm32.HACMSTREAM,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>The <c>acmStreamMessage</c> function sends a driver-specific message to an ACM driver.</summary>
            <param name="has">Handle to an open conversion stream.</param>
            <param name="uMsg">Message to send.</param>
            <param name="lParam1">Message parameter.</param>
            <param name="lParam2">Message parameter.</param>
            <returns>Returns the value returned by the ACM device driver.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmStreamOpen(Vanara.PInvoke.MsAcm32.SafeHACMSTREAM@,Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.WinMm.WAVEFORMATEX@,Vanara.PInvoke.WinMm.WAVEFORMATEX@,Vanara.PInvoke.WinMm.WAVEFILTER@,System.IntPtr,System.IntPtr,Vanara.PInvoke.MsAcm32.ACM_STREAMOPENF)">
            <summary>
            The <c>acmStreamOpen</c> function opens an ACM conversion stream. Conversion streams are used to convert data from one specified
            audio format to another.
            </summary>
            <param name="phas">
            Pointer to a handle that will receive the new stream handle that can be used to perform conversions. This handle is used to
            identify the stream in calls to other ACM stream conversion functions. If the ACM_STREAMOPENF_QUERY flag is specified, this
            parameter should be <c>NULL</c>.
            </param>
            <param name="had">
            Handle to an ACM driver. If this handle is specified, it identifies a specific driver to be used for a conversion stream. If
            this parameter is <c>NULL</c>, all suitable installed ACM drivers are queried until a match is found.
            </param>
            <param name="pwfxSrc">Pointer to a WAVEFORMATEX structure that identifies the desired source format for the conversion.</param>
            <param name="pwfxDst">Pointer to a WAVEFORMATEX structure that identifies the desired destination format for the conversion.</param>
            <param name="pwfltr">
            Pointer to a WAVEFILTER structure that identifies the desired filtering operation to perform on the conversion stream. If no
            filtering operation is desired, this parameter can be <c>NULL</c>. If a filter is specified, the source (pwfxSrc) and
            destination (pwfxDst) formats must be the same.
            </param>
            <param name="dwCallback">
            Pointer to a callback function, a handle of a window, or a handle of an event. A callback function will be called only if the
            conversion stream is opened with the ACM_STREAMOPENF_ASYNC flag. A callback function is notified when the conversion stream is
            opened or closed and after each buffer is converted. If the conversion stream is opened without the ACM_STREAMOPENF_ASYNC flag,
            this parameter should be set to zero.
            </param>
            <param name="dwInstance">
            User-instance data passed to the callback function specified by the dwCallback parameter. This parameter is not used with window
            and event callbacks. If the conversion stream is opened without the ACM_STREAMOPENF_ASYNC flag, this parameter should be set to zero.
            </param>
            <param name="fdwOpen">
            <para>Flags for opening the conversion stream. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_STREAMOPENF_ASYNC</term>
            <term>ACMSTREAMHEADER structure for the ACMSTREAMHEADER_STATUSF_DONE flag.</term>
            </item>
            <item>
            <term>ACM_STREAMOPENF_NONREALTIME</term>
            <term>
            ACM will not consider time constraints when converting the data. By default, the driver will attempt to convert the data in real
            time. For some formats, specifying this flag might improve the audio quality or other characteristics.
            </term>
            </item>
            <item>
            <term>ACM_STREAMOPENF_QUERY</term>
            <term>
            ACM will be queried to determine whether it supports the given conversion. A conversion stream will not be opened, and no handle
            will be returned in the phas parameter.
            </term>
            </item>
            <item>
            <term>CALLBACK_EVENT</term>
            <term>The dwCallback parameter is a handle of an event.</term>
            </item>
            <item>
            <term>CALLBACK_FUNCTION</term>
            <term>
            The dwCallback parameter is a callback procedure address. The function prototype must conform to the acmStreamConvertCallback prototype.
            </term>
            </item>
            <item>
            <term>CALLBACK_WINDOW</term>
            <term>The dwCallback parameter is a window handle.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>The requested operation cannot be performed.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate resources.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If an ACM driver cannot perform real-time conversions and the ACM_STREAMOPENF_NONREALTIME flag is not specified for the fdwOpen
            parameter, the open operation will fail returning an ACMERR_NOTPOSSIBLE error code. An application can use the
            ACM_STREAMOPENF_QUERY flag to determine if real-time conversions are supported for input.
            </para>
            <para>
            If an application uses a window to receive callback information, the MM_ACM_OPEN, MM_ACM_CLOSE, and MM_ACM_DONE messages are
            sent to the window procedure function to indicate the progress of the conversion stream. In this case, the ACMSTREAMHEADER
            structure for MM_ACM_DONE, but it is not used for MM_ACM_OPEN and MM_ACM_CLOSE.
            </para>
            <para>
            If an application uses a function to receive callback information, the MM_ACM_OPEN, MM_ACM_CLOSE, and MM_ACM_DONE messages are
            sent to the function to indicate the progress of waveform-audio output. The callback function must reside in a dynamic-link
            library (DLL).
            </para>
            <para>
            If an application uses an event for callback notification, the event is signaled to indicate the progress of the conversion
            stream. The event will be signaled when a stream is opened, after each buffer is converted, and when the stream is closed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmStreamOpen(Vanara.PInvoke.MsAcm32.SafeHACMSTREAM@,Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.WinMm.WAVEFORMATEX@,Vanara.PInvoke.WinMm.WAVEFORMATEX@,System.IntPtr,System.IntPtr,System.IntPtr,Vanara.PInvoke.MsAcm32.ACM_STREAMOPENF)">
            <summary>
            The <c>acmStreamOpen</c> function opens an ACM conversion stream. Conversion streams are used to convert data from one specified
            audio format to another.
            </summary>
            <param name="phas">
            Pointer to a handle that will receive the new stream handle that can be used to perform conversions. This handle is used to
            identify the stream in calls to other ACM stream conversion functions. If the ACM_STREAMOPENF_QUERY flag is specified, this
            parameter should be <c>NULL</c>.
            </param>
            <param name="had">
            Handle to an ACM driver. If this handle is specified, it identifies a specific driver to be used for a conversion stream. If
            this parameter is <c>NULL</c>, all suitable installed ACM drivers are queried until a match is found.
            </param>
            <param name="pwfxSrc">Pointer to a WAVEFORMATEX structure that identifies the desired source format for the conversion.</param>
            <param name="pwfxDst">Pointer to a WAVEFORMATEX structure that identifies the desired destination format for the conversion.</param>
            <param name="pwfltr">
            Pointer to a WAVEFILTER structure that identifies the desired filtering operation to perform on the conversion stream. If no
            filtering operation is desired, this parameter can be <c>NULL</c>. If a filter is specified, the source (pwfxSrc) and
            destination (pwfxDst) formats must be the same.
            </param>
            <param name="dwCallback">
            Pointer to a callback function, a handle of a window, or a handle of an event. A callback function will be called only if the
            conversion stream is opened with the ACM_STREAMOPENF_ASYNC flag. A callback function is notified when the conversion stream is
            opened or closed and after each buffer is converted. If the conversion stream is opened without the ACM_STREAMOPENF_ASYNC flag,
            this parameter should be set to zero.
            </param>
            <param name="dwInstance">
            User-instance data passed to the callback function specified by the dwCallback parameter. This parameter is not used with window
            and event callbacks. If the conversion stream is opened without the ACM_STREAMOPENF_ASYNC flag, this parameter should be set to zero.
            </param>
            <param name="fdwOpen">
            <para>Flags for opening the conversion stream. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_STREAMOPENF_ASYNC</term>
            <term>ACMSTREAMHEADER structure for the ACMSTREAMHEADER_STATUSF_DONE flag.</term>
            </item>
            <item>
            <term>ACM_STREAMOPENF_NONREALTIME</term>
            <term>
            ACM will not consider time constraints when converting the data. By default, the driver will attempt to convert the data in real
            time. For some formats, specifying this flag might improve the audio quality or other characteristics.
            </term>
            </item>
            <item>
            <term>ACM_STREAMOPENF_QUERY</term>
            <term>
            ACM will be queried to determine whether it supports the given conversion. A conversion stream will not be opened, and no handle
            will be returned in the phas parameter.
            </term>
            </item>
            <item>
            <term>CALLBACK_EVENT</term>
            <term>The dwCallback parameter is a handle of an event.</term>
            </item>
            <item>
            <term>CALLBACK_FUNCTION</term>
            <term>
            The dwCallback parameter is a callback procedure address. The function prototype must conform to the acmStreamConvertCallback prototype.
            </term>
            </item>
            <item>
            <term>CALLBACK_WINDOW</term>
            <term>The dwCallback parameter is a window handle.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>The requested operation cannot be performed.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate resources.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If an ACM driver cannot perform real-time conversions and the ACM_STREAMOPENF_NONREALTIME flag is not specified for the fdwOpen
            parameter, the open operation will fail returning an ACMERR_NOTPOSSIBLE error code. An application can use the
            ACM_STREAMOPENF_QUERY flag to determine if real-time conversions are supported for input.
            </para>
            <para>
            If an application uses a window to receive callback information, the MM_ACM_OPEN, MM_ACM_CLOSE, and MM_ACM_DONE messages are
            sent to the window procedure function to indicate the progress of the conversion stream. In this case, the ACMSTREAMHEADER
            structure for MM_ACM_DONE, but it is not used for MM_ACM_OPEN and MM_ACM_CLOSE.
            </para>
            <para>
            If an application uses a function to receive callback information, the MM_ACM_OPEN, MM_ACM_CLOSE, and MM_ACM_DONE messages are
            sent to the function to indicate the progress of waveform-audio output. The callback function must reside in a dynamic-link
            library (DLL).
            </para>
            <para>
            If an application uses an event for callback notification, the event is signaled to indicate the progress of the conversion
            stream. The event will be signaled when a stream is opened, after each buffer is converted, and when the stream is closed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmStreamPrepareHeader(Vanara.PInvoke.MsAcm32.HACMSTREAM,Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER@,System.UInt32)">
            <summary>
            The ACMSTREAMHEADER structure for an ACM stream conversion. This function must be called for every stream header before it can
            be used in a conversion stream. An application needs to prepare a stream header only once for the life of a given stream. The
            stream header can be reused as long as the sizes of the source and destination buffers do not exceed the sizes used when the
            stream header was originally prepared.
            </summary>
            <param name="has">Handle to the conversion steam.</param>
            <param name="pash">Pointer to an ACMSTREAMHEADER structure that identifies the source and destination buffers to be prepared.</param>
            <param name="fdwPrepare">Reserved; must be zero.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_NOMEM</term>
            <term>The system is unable to allocate resources.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Preparing a stream header that has already been prepared has no effect, and the function returns zero. Nevertheless, you should
            ensure your application does not prepare a stream header multiple times.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmStreamReset(Vanara.PInvoke.MsAcm32.HACMSTREAM,System.UInt32)">
            <summary>
            The <c>acmStreamReset</c> function stops conversions for a given ACM stream. All pending buffers are marked as done and returned
            to the application.
            </summary>
            <param name="has">Handle to the conversion stream.</param>
            <param name="fdwReset">Reserved; must be zero.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            Resetting an ACM conversion stream is necessary only for asynchronous conversion streams. Resetting a synchronous conversion
            stream will succeed, but no action will be taken.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmStreamSize(Vanara.PInvoke.MsAcm32.HACMSTREAM,System.UInt32,System.UInt32@,Vanara.PInvoke.MsAcm32.ACM_STREAMSIZEF)">
            <summary>The <c>acmStreamSize</c> function returns a recommended size for a source or destination buffer on an ACM stream.</summary>
            <param name="has">Handle to the conversion stream.</param>
            <param name="cbInput">
            Size, in bytes, of the source or destination buffer. The fdwSize flags specify what the input parameter defines. This parameter
            must be nonzero.
            </param>
            <param name="pdwOutputBytes">
            Pointer to a variable that contains the size, in bytes, of the source or destination buffer. The fdwSize flags specify what the
            output parameter defines. If the <c>acmStreamSize</c> function succeeds, this location will always be filled with a nonzero value.
            </param>
            <param name="fdwSize">
            <para>Flags for the stream size query. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ACM_STREAMSIZEF_DESTINATION</term>
            <term>
            The cbInput parameter contains the size of the destination buffer. The pdwOutputBytes parameter will receive the recommended
            source buffer size, in bytes.
            </term>
            </item>
            <item>
            <term>ACM_STREAMSIZEF_SOURCE</term>
            <term>
            The cbInput parameter contains the size of the source buffer. The pdwOutputBytes parameter will receive the recommended
            destination buffer size, in bytes.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_NOTPOSSIBLE</term>
            <term>The requested operation cannot be performed.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            An application can use this function to determine suggested buffer sizes for either source or destination buffers. The buffer
            sizes returned might be only an estimation of the actual sizes required for conversion. Because actual conversion sizes cannot
            always be determined without performing the conversion, the sizes returned will usually be overestimated.
            </para>
            <para>
            In the event of an error, the location pointed to by pdwOutputBytes will receive zero. This assumes that the pointer specified
            by pdwOutputBytes is valid.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.acmStreamUnprepareHeader(Vanara.PInvoke.MsAcm32.HACMSTREAM,Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER@,System.UInt32)">
            <summary>
            The <c>acmStreamUnprepareHeader</c> function cleans up the preparation performed by the acmStreamPrepareHeader function for an
            ACM stream. This function must be called after the ACM is finished with the given buffers. An application must call this
            function before freeing the source and destination buffers.
            </summary>
            <param name="has">Handle to the conversion steam.</param>
            <param name="pash">Pointer to an ACMSTREAMHEADER structure that identifies the source and destination buffers to be unprepared.</param>
            <param name="fdwUnprepare">Reserved; must be zero.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMERR_BUSY</term>
            <term>The stream header specified in pash is currently in use and cannot be unprepared.</term>
            </item>
            <item>
            <term>ACMERR_UNPREPARED</term>
            <term>The stream header specified in pash is currently not prepared by the acmStreamPrepareHeader function.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALFLAG</term>
            <term>At least one flag is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALHANDLE</term>
            <term>The specified handle is invalid.</term>
            </item>
            <item>
            <term>MMSYSERR_INVALPARAM</term>
            <term>At least one parameter is invalid.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Unpreparing a stream header that has already been unprepared is an error. An application must specify the source and destination
            buffer lengths ( <c>cbSrcLength</c> and <c>cbDstLength</c>, respectively) that were used during a call to the corresponding
            acmStreamPrepareHeader. Failing to reset these member values will cause <c>acmStreamUnprepareHeader</c> to fail with an
            MMSYSERR_INVALPARAM error.
            </para>
            <para>
            The ACM can recover from some errors. The ACM will return a nonzero error, yet the stream header will be properly unprepared. To
            determine whether the stream header was actually unprepared, an application can examine the ACMSTREAMHEADER_STATUSF_PREPARED
            flag. If <c>acmStreamUnprepareHeader</c> returns success, the header will always be unprepared.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS">
            <summary>The <c>ACMDRIVERDETAILS</c> structure describes the features of an ACM driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.cbStruct">
            <summary>
            Size, in bytes, of the valid information contained in the <c>ACMDRIVERDETAILS</c> structure. An application should
            initialize this member to the size, in bytes, of the desired information. The size specified in this member must be large
            enough to contain the <c>cbStruct</c> member of the <c>ACMDRIVERDETAILS</c> structure. When the acmDriverDetails function
            returns, this member contains the actual size of the information returned. The returned information will never exceed the
            requested size.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.fccType">
            <summary>Type of the driver. For ACM drivers, set this member to ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.fccComp">
            <summary>Subtype of the driver. This member is currently set to ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (zero).</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.wMid">
            <summary>Manufacturer identifier. Manufacturer identifiers are defined in Manufacturer and Product Identifiers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.wPid">
            <summary>Product identifier. Product identifiers are defined in Manufacturer and Product Identifiers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.vdwACM">
            <summary>
            Version of the ACM for which this driver was compiled. The version number is a hexadecimal number in the format 0xAABBCCCC,
            where AA is the major version number, BB is the minor version number, and CCCC is the build number. The version parts
            (major, minor, and build) should be displayed as decimal numbers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.vdwDriver">
            <summary>
            Version of the driver. The version number is a hexadecimal number in the format 0xAABBCCCC, where AA is the major version
            number, BB is the minor version number, and CCCC is the build number. The version parts (major, minor, and build) should be
            displayed as decimal numbers.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.fdwSupport">
            <summary>
            <para>Support flags for the driver. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_ASYNC</term>
            <term>Driver supports asynchronous conversions.</term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CODEC</term>
            <term>
            Driver supports conversion between two different format tags. For example, if a driver supports compression from
            WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CONVERTER</term>
            <term>
            Driver supports conversion between two different formats of the same format tag. For example, if a driver supports
            resampling of WAVE_FORMAT_PCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_DISABLED</term>
            <term>
            Driver has been disabled. This flag is set by the ACM for a driver when it has been disabled for any of a number of reasons.
            Disabled drivers cannot be opened and can be used only under very limited circumstances.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_FILTER</term>
            <term>
            Driver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver
            supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_HARDWARE</term>
            <term>
            Driver supports hardware input, output, or both through a waveform-audio device. An application should use the acmMetrics
            function with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the
            waveform-audio device identifiers associated with the supporting ACM driver.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_LOCAL</term>
            <term>The driver has been installed locally with respect to the current task.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.cFormatTags">
            <summary>Number of unique format tags supported by this driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.cFilterTags">
            <summary>Number of unique filter tags supported by this driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.hicon">
            <summary>
            Handle to a custom icon for this driver. An application can use this icon for referencing the driver visually. This member
            can be <c>NULL</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.szShortName">
            <summary>
            Null-terminated string that describes the name of the driver. This string is intended to be displayed in small spaces.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.szLongName">
            <summary>
            Null-terminated string that describes the full name of the driver. This string is intended to be displayed in large
            (descriptive) spaces.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.szCopyright">
            <summary>Null-terminated string that provides copyright information for the driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.szLicensing">
            <summary>Null-terminated string that provides special licensing information for the driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMDRIVERDETAILS.szFeatures">
            <summary>Null-terminated string that provides special feature information for the driver.</summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE">
            <summary>
            The <c>ACMFILTERCHOOSE</c> structure contains information the ACM uses to initialize the system-defined waveform-audio filter
            selection dialog box. After the user closes the dialog box, the system returns information about the user's selection in this structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.cbStruct">
            <summary>
            Size, in bytes, of the <c>ACMFILTERCHOOSE</c> structure. This member must be initialized before an application calls the
            acmFilterChoose function. The size specified in this member must be large enough to contain the base <c>ACMFILTERCHOOSE</c> structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.fdwStyle">
            <summary>
            <para>
            Optional style flags for the acmFilterChoose function. This member must be initialized to a valid combination of the
            following flags before an application calls the <c>acmFilterChoose</c> function. The following values are defined:
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMFILTERCHOOSE_STYLEF_CONTEXTHELP</term>
            <term>
            Context-sensitive help will be available in the dialog box. To use this feature, an application must register the
            ACMHELPMSGCONTEXTMENU and ACMHELPMSGCONTEXTHELP constants, using the RegisterWindowMessage function. When the user invokes
            help, the registered message will be posted to the owning window. The message will contain the wParam and lParam parameters
            from the original WM_CONTEXTMENU or WM_CONTEXTHELP message.
            </term>
            </item>
            <item>
            <term>ACMFILTERCHOOSE_STYLEF_ENABLEHOOK</term>
            <term>
            Enables the hook function specified in the pfnHook member. An application can use hook functions for a variety of
            customizations, including answering the MM_ACM_FILTERCHOOSE message.
            </term>
            </item>
            <item>
            <term>ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE</term>
            <term>Causes the ACM to create the dialog box template identified by the hInstance and pszTemplateName members.</term>
            </item>
            <item>
            <term>ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE</term>
            <term>
            The hInstance member identifies a data block that contains a preloaded dialog box template. If this flag is specified, the
            ACM ignores the pszTemplateName member.
            </term>
            </item>
            <item>
            <term>ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT</term>
            <term>
            The buffer pointed to by pwfltr contains a valid WAVEFILTER structure that the dialog box will use as the initial selection.
            </term>
            </item>
            <item>
            <term>ACMFILTERCHOOSE_STYLEF_SHOWHELP</term>
            <term>
            A help button will appear in the dialog box. To use a custom Help file, an application must register the ACMHELPMSGSTRING
            value with the RegisterWindowMessage function. When the user presses the help button, the registered message is posted to
            the owner.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.hwndOwner">
            <summary>
            Handle to the window that owns the dialog box. This member can be any valid window handle or <c>NULL</c> if the dialog box
            has no owner. This member must be initialized before calling the acmFilterChoose function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.pwfltr">
            <summary>
            Pointer to a WAVEFILTER structure. If the ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT flag is specified in the <c>fdwStyle</c>
            member, this structure must be initialized to a valid filter. When the acmFilterChoose function returns, this buffer
            contains the selected filter. If the user cancels the dialog box, no changes will be made to this buffer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.cbwfltr">
            <summary>
            Size, in bytes, of the buffer pointed to by the <c>pwfltr</c> member. The acmFilterChoose function returns
            ACMERR_NOTPOSSIBLE if the buffer is too small to contain the filter information; the ACM also copies the required size into
            this member. An application can use the acmMetrics and acmFilterTagDetails functions to determine the largest size required
            for this buffer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.pszTitle">
            <summary>
            Pointer to a string to be placed in the title bar of the dialog box. If this member is <c>NULL</c>, the ACM uses the default
            title (that is, "Filter Selection").
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.szFilterTag">
            <summary>
            Buffer containing a null-terminated string describing the filter tag of the filter selection when the ACMFILTERTAGDETAILS
            structure returned by acmFilterTagDetails. If the user cancels the dialog box, this member will contain a null-terminated string.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.szFilter">
            <summary>
            Buffer containing a null-terminated string describing the filter attributes of the filter selection when the
            ACMFILTERDETAILS structure returned by acmFilterDetails. If the user cancels the dialog box, this member will contain a
            null-terminated string.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.pszName">
            <summary>
            <para>
            Pointer to a string for a user-defined filter name. If this is a non-null-terminated string, the ACM attempts to match the
            name with a previously saved user-defined filter name. If a match is found, the dialog box is initialized to that filter. If
            a match is not found or this member is a null-terminated string, this member is ignored for input. When the acmFilterChoose
            function returns, this buffer contains a null-terminated string describing the user-defined filter. If the filter name is
            untitled (that is, the user has not given a name for the filter), this member will be a null-terminated string on return. If
            the user cancels the dialog box, no changes will be made to this buffer.
            </para>
            <para>
            If the ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT flag is specified by the <c>fdwStyle</c> member, the <c>pszName</c> member
            is ignored as an input member.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.cchName">
            <summary>
            Size, in characters, of the buffer identified by the <c>pszName</c> member. This buffer should be at least 128 characters
            long. If <c>pszName</c> is <c>NULL</c>, this member is ignored.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.fdwEnum">
            <summary>
            <para>
            Optional flags for restricting the type of filters listed in the dialog box. These flags are identical to the fdwEnum flags
            for the acmFilterEnum function. If <c>pwfltrEnum</c> is <c>NULL</c>, this member should be zero.
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACM_FILTERENUMF_DWFILTERTAG</term>
            <term>
            The dwFilterTag member of the WAVEFILTER structure pointed to by the pwfltrEnum member is valid. The enumerator will only
            enumerate a filter that conforms to this attribute.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.pwfltrEnum">
            <summary>
            Pointer to a WAVEFILTER structure that will be used to restrict the filters listed in the dialog box. The <c>fdwEnum</c>
            member defines which members of this structure should be used for the enumeration restrictions. The <c>cbStruct</c> member
            of this <c>WAVEFILTER</c> structure must be initialized to the size of the <c>WAVEFILTER</c> structure. If no special
            restrictions are desired, this member can be <c>NULL</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.hInstance">
            <summary>
            Handle to a data block that contains a dialog box template specified by the <c>pszTemplateName</c> member. This member is
            used only if the <c>fdwStyle</c> member specifies the ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE or
            ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE flag; otherwise, this member should be <c>NULL</c> on input.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.pszTemplateName">
            <summary>
            Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that is to be
            substituted for the dialog box template in the ACM. An application can use the MAKEINTRESOURCE macro for numbered dialog box
            resources. This member is used only if the <c>fdwStyle</c> member specifies the ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE flag;
            otherwise, this member should be <c>NULL</c> on input.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.lCustData">
            <summary>
            Application-defined data that the ACM passes to the hook function identified by the <c>pfnHook</c> member. The system passes
            the data in the lParam parameter of the WM_INITDIALOG message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERCHOOSE.pfnHook">
            <summary>
            Pointer to a callback function that processes messages intended for the dialog box. An application must specify the
            ACMFILTERCHOOSE_STYLEF_ENABLEHOOK flag in the <c>fdwStyle</c> member to enable the hook; otherwise, this member should be
            <c>NULL</c>. The hook function should return <c>FALSE</c> to pass a message to the standard dialog box procedure or
            <c>TRUE</c> to discard the message. The callback function type is acmFilterChooseHookProc.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFILTERDETAILS">
            <summary>The <c>ACMFILTERDETAILS</c> structure details a waveform-audio filter for a specific filter tag for an ACM driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERDETAILS.cbStruct">
            <summary>
            Size, in bytes, of the <c>ACMFILTERDETAILS</c> structure. This member must be initialized before calling the
            acmFilterDetails or acmFilterEnum functions. The size specified in this member must be large enough to contain the base
            <c>ACMFILTERDETAILS</c> structure. When the <c>acmFilterDetails</c> function returns, this member contains the actual size
            of the information returned. The returned information will never exceed the requested size.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERDETAILS.dwFilterIndex">
            <summary>
            Index of the filter about which details will be retrieved. The index ranges from zero to one less than the number of
            standard filters supported by an ACM driver for a filter tag. The number of standard filters supported by a driver for a
            filter tag is contained in the ACMFILTERTAGDETAILS structure. The <c>dwFilterIndex</c> member is used only when querying
            standard filter details about a driver by index; otherwise, this member should be zero. Also, this member will be set to
            zero by the ACM when an application queries for details on a filter; in other words, this member is used only for input and
            is never returned by the ACM or an ACM driver.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERDETAILS.dwFilterTag">
            <summary>
            Waveform-audio filter tag that the <c>ACMFILTERDETAILS</c> structure describes. This member is used as an input for the
            ACM_FILTERDETAILSF_INDEX query flag. For the ACM_FILTERDETAILSF_FORMAT query flag, this member must be initialized to the
            same filter tag as the <c>pwfltr</c> member specifies. If the acmFilterDetails function is successful, this member is always
            returned. This member should be set to WAVE_FILTER_UNKNOWN for all other query flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERDETAILS.fdwSupport">
            <summary>
            <para>
            Driver-support flags specific to the specified filter. These flags are identical to the ACMDRIVERDETAILS structure, but they
            are specific to the filter that is being queried. This member can be a combination of the following values and identifies
            which operations the driver supports for the filter tag:
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_ASYNC</term>
            <term>Driver supports asynchronous conversions.</term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CODEC</term>
            <term>
            Driver supports conversion between two different format tags while using the specified filter. For example, if a driver
            supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specified filter, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CONVERTER</term>
            <term>
            Driver supports conversion between two different formats of the same format tag while using the specified filter. For
            example, if a driver supports resampling of WAVE_FORMAT_PCM with the specified filter, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_FILTER</term>
            <term>
            Driver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver
            supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_HARDWARE</term>
            <term>
            Driver supports hardware input, output, or both with the specified filter through a waveform-audio device. An application
            should use the acmMetrics function with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric
            indexes to retrieve the waveform-audio device identifiers associated with the supporting ACM driver.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERDETAILS.pwfltr">
            <summary>
            Pointer to a WAVEFILTER structure that will receive the filter details. This structure requires no initialization by the
            application unless the ACM_FILTERDETAILSF_FILTER flag is specified with the acmFilterDetails function. In this case, the
            <c>dwFilterTag</c> member of the <c>WAVEFILTER</c> structure must be equal to the <c>dwFilterTag</c> member of the
            <c>ACMFILTERDETAILS</c> structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERDETAILS.cbwfltr">
            <summary>
            Size, in bytes, available for <c>pwfltr</c> to receive the filter details. The acmMetrics and acmFilterTagDetails functions
            can be used to determine the maximum size required for any filter available for the specified driver (or for all installed
            ACM drivers).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERDETAILS.szFilter">
            <summary>
            String that describes the filter for the <c>dwFilterTag</c> type. If the acmFilterDetails function is successful, this
            string is always returned.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFILTERTAGDETAILS">
            <summary>The <c>ACMFILTERTAGDETAILS</c> structure details a waveform-audio filter tag for an ACM filter driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERTAGDETAILS.cbStruct">
            <summary>
            Size, in bytes, of the <c>ACMFILTERTAGDETAILS</c> structure. This member must be initialized before an application calls the
            acmFilterTagDetails or acmFilterTagEnum function. The size specified in this member must be large enough to contain the base
            <c>ACMFILTERTAGDETAILS</c> structure. When the <c>acmFilterTagDetails</c> function returns, this member contains the actual
            size of the information returned. The returned information will never exceed the requested size.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERTAGDETAILS.dwFilterTagIndex">
            <summary>
            Index of the filter tag to retrieve details for. The index ranges from zero to one less than the number of filter tags
            supported by an ACM driver. The number of filter tags supported by a driver is contained in the ACMDRIVERDETAILS structure.
            The <c>dwFilterTagIndex</c> member is used only when querying filter tag details about a driver by index; otherwise, this
            member should be zero.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERTAGDETAILS.dwFilterTag">
            <summary>
            Waveform-audio filter tag that the <c>ACMFILTERTAGDETAILS</c> structure describes. This member is used as an input for the
            ACM_FILTERTAGDETAILSF_FILTERTAG and ACM_FILTERTAGDETAILSF_LARGESTSIZE query flags. This member is always returned if the
            acmFilterTagDetails function is successful. This member should be set to WAVE_FILTER_UNKNOWN for all other query flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERTAGDETAILS.cbFilterSize">
            <summary>
            Largest total size, in bytes, of a waveform-audio filter of the <c>dwFilterTag</c> type. For example, this member will be 40
            for WAVE_FILTER_ECHO and 36 for WAVE_FILTER_VOLUME.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERTAGDETAILS.fdwSupport">
            <summary>
            <para>
            Driver-support flags specific to the filter tag. These flags are identical to the ACMDRIVERDETAILS structure. This member
            can be a combination of the following values and identifies which operations the driver supports with the filter tag:
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_ASYNC</term>
            <term>Driver supports asynchronous conversions.</term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CODEC</term>
            <term>
            Driver supports conversion between two different format tags while using the specified filter tag. For example, if a driver
            supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specified filter tag, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CONVERTER</term>
            <term>
            Driver supports conversion between two different formats of the same format tag while using the specified filter tag. For
            example, if a driver supports resampling of WAVE_FORMAT_PCM with the specified filter tag, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_FILTER</term>
            <term>
            Driver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver
            supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_HARDWARE</term>
            <term>
            Driver supports hardware input, output, or both with the specified filter tag through a waveform-audio device. An
            application should use the acmMetrics function with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT
            metric indexes to get the waveform-audio device identifiers associated with the supporting ACM driver.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERTAGDETAILS.cStandardFilters">
            <summary>
            Number of standard filters of the <c>dwFilterTag</c> type (that is, the combination of all filter characteristics). This
            value cannot specify all filters supported by the driver.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFILTERTAGDETAILS.szFilterTag">
            <summary>
            String that describes the <c>dwFilterTag</c> type. This string is always returned if the acmFilterTagDetails function is successful.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE">
            <summary>
            The <c>ACMFORMATCHOOSE</c> structure contains information the ACM uses to initialize the system-defined waveform-audio format
            selection dialog box. After the user closes the dialog box, the system returns information about the user's selection in this structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.cbStruct">
            <summary>
            Size, in bytes, of the <c>ACMFORMATCHOOSE</c> structure. This member must be initialized before an application calls the
            acmFormatChoose function. The size specified in this member must be large enough to contain the base <c>ACMFORMATCHOOSE</c> structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.fdwStyle">
            <summary>
            <para>
            Optional style flags for the acmFormatChoose function. This member must be initialized to a valid combination of the
            following flags before an application calls the <c>acmFormatChoose</c> function:
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMFORMATCHOOSE_STYLEF_CONTEXTHELP</term>
            <term>
            Context-sensitive help will be available in the dialog box. To use this feature, an application must register the
            ACMHELPMSGCONTEXTMENU and ACMHELPMSGCONTEXTHELP constants, using the RegisterWindowMessage function. When the user invokes
            help, the registered message will be posted to the owning window. The message will contain the wParam and lParam parameters
            from the original WM_CONTEXTMENU or WM_CONTEXTHELP message.
            </term>
            </item>
            <item>
            <term>ACMFORMATCHOOSE_STYLEF_ENABLEHOOK</term>
            <term>
            Enables the hook function pointed to by the pfnHook member. An application can use hook functions for a variety of
            customizations, including answering the MM_ACM_FORMATCHOOSE message.
            </term>
            </item>
            <item>
            <term>ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE</term>
            <term>Causes the ACM to create the dialog box template identified by hInstance and pszTemplateName.</term>
            </item>
            <item>
            <term>ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE</term>
            <term>
            The hInstance member identifies a data block that contains a preloaded dialog box template. If this flag is specified, the
            ACM ignores the pszTemplateName member.
            </term>
            </item>
            <item>
            <term>ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT</term>
            <term>
            The buffer pointed to by pwfx contains a valid WAVEFORMATEX structure that the dialog box will use as the initial selection.
            </term>
            </item>
            <item>
            <term>ACMFORMATCHOOSE_STYLEF_SHOWHELP</term>
            <term>
            A help button will appear in the dialog box. To use a custom Help file, an application must register the ACMHELPMSGSTRING
            constant with the RegisterWindowMessage function. When the user presses the help button, the registered message will be
            posted to the owner.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.hwndOwner">
            <summary>
            Handle to the window that owns the dialog box. This member can be any valid window handle, or <c>NULL</c> if the dialog box
            has no owner. This member must be initialized before calling the acmFormatChoose function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.pwfx">
            <summary>
            Pointer to a WAVEFORMATEX structure. If the ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT flag is specified in the <c>fdwStyle</c>
            member, this structure must be initialized to a valid format. When the acmFormatChoose function returns, this buffer
            contains the selected format. If the user cancels the dialog box, no changes will be made to this buffer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.cbwfx">
            <summary>
            Size, in bytes, of the buffer pointed to by <c>pwfx</c>. If the buffer is too small to contain the format information, the
            acmFormatChoose function returns ACMERR_NOTPOSSIBLE. Also, the ACM copies the required size into this member. An application
            can use the acmMetrics and acmFormatTagDetails functions to determine the largest size required for this buffer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.pszTitle">
            <summary>
            Pointer to a string to be placed in the title bar of the dialog box. If this member is <c>NULL</c>, the ACM uses the default
            title (that is, "Sound Selection").
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.szFormatTag">
            <summary>
            Buffer containing a null-terminated string describing the format tag of the format selection when the ACMFORMATTAGDETAILS
            structure returned by the acmFormatTagDetails function. If the user cancels the dialog box, this member will contain a
            null-terminated string.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.szFormat">
            <summary>
            Buffer containing a null-terminated string describing the format attributes of the format selection when the
            ACMFORMATDETAILS structure returned by the acmFormatDetails function. If the user cancels the dialog box, this member will
            contain a null-terminated string.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.pszName">
            <summary>
            Pointer to a string for a user-defined format name. If this is a non-null-terminated string, the ACM will attempt to match
            the name with a previously saved user-defined format name. If a match is found, the dialog box is initialized to that
            format. If a match is not found or this member is a null-terminated string, this member is ignored on input. When the
            acmFormatChoose function returns, this buffer contains a null-terminated string describing the user-defined format. If the
            format name is untitled (that is, the user has not given a name for the format), this member will be a null-terminated
            string on return. If the user cancels the dialog box, no changes will be made to this buffer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.cchName">
            <summary>
            Size, in characters, of the buffer identified by the <c>pszName</c> member. This buffer should be at least 128 characters
            long. If the <c>pszName</c> member is <c>NULL</c>, this member is ignored.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.fdwEnum">
            <summary>
            <para>
            Optional flags for restricting the type of formats listed in the dialog box. These flags are identical to the fdwEnum flags
            for the acmFormatEnum function. If <c>pwfxEnum</c> is <c>NULL</c>, this member should be zero. The following values are defined:
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACM_FORMATENUMF_CONVERT</term>
            <term>
            The WAVEFORMATEX structure pointed to by the pwfxEnum member is valid. The enumerator will enumerate only destination
            formats that can be converted from the given pwfxEnum format.
            </term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_HARDWARE</term>
            <term>
            The enumerator should enumerate only formats that are supported in hardware by one or more of the installed waveform-audio
            devices. This flag provides a way for an application to choose only formats native to an installed waveform-audio device.
            </term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_INPUT</term>
            <term>The enumerator should enumerate only formats that are supported for input (recording).</term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_NCHANNELS</term>
            <term>
            The nChannels member of the WAVEFORMATEX structure pointed to by the pwfxEnum member is valid. The enumerator will enumerate
            only a format that conforms to this attribute.
            </term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_NSAMPLESPERSEC</term>
            <term>
            The nSamplesPerSec member of the WAVEFORMATEX structure pointed to by the pwfxEnum member is valid. The enumerator will
            enumerate only a format that conforms to this attribute.
            </term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_OUTPUT</term>
            <term>The enumerator should enumerate only formats that are supported for output (playback).</term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_SUGGEST</term>
            <term>
            The WAVEFORMATEX structure pointed to by the pwfxEnum member is valid. The enumerator will enumerate all suggested
            destination formats for the given pwfxEnum format.
            </term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_WBITSPERSAMPLE</term>
            <term>
            The wBitsPerSample member of the WAVEFORMATEX structure pointed to by the pwfxEnum member is valid. The enumerator will
            enumerate only a format that conforms to this attribute.
            </term>
            </item>
            <item>
            <term>ACM_FORMATENUMF_WFORMATTAG</term>
            <term>
            The wFormatTag member of the WAVEFORMATEX structure pointed to by the pwfxEnum member is valid. The enumerator will
            enumerate only a format that conforms to this attribute.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.pwfxEnum">
            <summary>
            Pointer to a <c>WAVEFORMATEX</c> structure that will be used to restrict the formats listed in the dialog box. The
            <c>fdwEnum</c> member defines the members of the structure pointed to by <c>pwfxEnum</c> that should be used for the
            enumeration restrictions. If no special restrictions are desired, this member can be <c>NULL</c>. For other requirements
            associated with the <c>pwfxEnum</c> member, see the description for the acmFormatEnum function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.hInstance">
            <summary>
            Handle to a data block that contains a dialog box template specified by the <c>pszTemplateName</c> member. This member is
            used only if the <c>fdwStyle</c> member specifies the ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE or
            ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE flag; otherwise, this member should be <c>NULL</c> on input.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.pszTemplateName">
            <summary>
            Pointer to a null-terminated string that specifies the name of the resource file for the dialog box template that is to be
            substituted for the dialog box template in the ACM. An application can use the MAKEINTRESOURCE macro for numbered dialog box
            resources. This member is used only if the <c>fdwStyle</c> member specifies the ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE flag;
            otherwise, this member should be <c>NULL</c> on input.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.lCustData">
            <summary>
            Application-defined data that the ACM passes to the hook function identified by the <c>pfnHook</c> member. The system passes
            the data in the lParam parameter of the WM_INITDIALOG message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATCHOOSE.pfnHook">
            <summary>
            Pointer to a callback function that processes messages intended for the dialog box. An application must specify the
            ACMFORMATCHOOSE_STYLEF_ENABLEHOOK flag in the <c>fdwStyle</c> member to enable the hook; otherwise, this member should be
            <c>NULL</c>. The hook function should return <c>FALSE</c> to pass a message to the standard dialog box procedure or
            <c>TRUE</c> to discard the message. The callback function type is acmFormatChooseHookProc.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFORMATDETAILS">
            <summary>The <c>ACMFORMATDETAILS</c> structure details a waveform-audio format for a specific format tag for an ACM driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATDETAILS.cbStruct">
            <summary>
            Size, in bytes, of the <c>ACMFORMATDETAILS</c> structure. This member must be initialized before an application calls the
            acmFormatDetails or acmFormatEnum function. The size specified by this member must be large enough to contain the base
            <c>ACMFORMATDETAILS</c> structure. When the <c>acmFormatDetails</c> function returns, this member contains the actual size
            of the information returned. The returned information will never exceed the requested size.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATDETAILS.dwFormatIndex">
            <summary>
            Index of the format to retrieve details for. The index ranges from zero to one less than the number of standard formats
            supported by an ACM driver for a format tag. The number of standard formats supported by a driver for a format tag is
            contained in the ACMFORMATTAGDETAILS structure. The <c>dwFormatIndex</c> member is used only when an application queries
            standard format details about a driver by index; otherwise, this member should be zero. Also, this member will be set to
            zero by the ACM when an application queries for details on a format; in other words, this member is used only for input and
            is never returned by the ACM or an ACM driver.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATDETAILS.dwFormatTag">
            <summary>
            Waveform-audio format tag that the <c>ACMFORMATDETAILS</c> structure describes. This member is used for input for the
            ACM_FORMATDETAILSF_INDEX query flag. For the ACM_FORMATDETAILSF_FORMAT query flag, this member must be initialized to the
            same format tag as the <c>pwfx</c> member specifies. If a call to the acmFormatDetails function is successful, this member
            is always returned. This member should be set to WAVE_FORMAT_UNKNOWN for all other query flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATDETAILS.fdwSupport">
            <summary>
            <para>
            Driver-support flags specific to the specified format. These flags are identical to the ACMDRIVERDETAILS structure. This
            member can be a combination of the following values and indicates which operations the driver supports for the format tag:
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_ASYNC</term>
            <term>Driver supports asynchronous conversions with the specified format tag.</term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CODEC</term>
            <term>
            Driver supports conversion between two different format tags for the specified format. For example, if a driver supports
            compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specified format, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CONVERTER</term>
            <term>
            Driver supports conversion between two different formats of the same format tag while using the specified format. For
            example, if a driver supports resampling of WAVE_FORMAT_PCM to the specified format, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_FILTER</term>
            <term>
            Driver supports a filter (which modifies data without changing any format attributes) with the specified format. For
            example, if a driver supports volume or echo operations on WAVE_FORMAT_PCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_HARDWARE</term>
            <term>
            Driver supports hardware input and/or output of the specified format through a waveform-audio device. An application should
            use acmMetrics with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the
            waveform-audio device identifiers associated with the supporting ACM driver.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATDETAILS.pwfx">
            <summary>
            Pointer to a WAVEFORMATEX structure that will receive the format details. This structure requires no initialization by the
            application unless the ACM_FORMATDETAILSF_FORMAT flag is specified in the acmFormatDetails function. In this case, the
            <c>wFormatTag</c> member of the <c>WAVEFORMATEX</c> structure must be equal to the <c>dwFormatTag</c> of the
            <c>ACMFORMATDETAILS</c> structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATDETAILS.cbwfx">
            <summary>
            Size, in bytes, available for <c>pwfx</c> to receive the format details. The acmMetrics and acmFormatTagDetails functions
            can be used to determine the maximum size required for any format available for the specified driver (or for all installed
            ACM drivers).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATDETAILS.szFormat">
            <summary>
            String that describes the format for the <c>dwFormatTag</c> type. If the acmFormatDetails function is successful, this
            string is always returned.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMFORMATTAGDETAILS">
            <summary>The <c>ACMFORMATTAGDETAILS</c> structure details a waveform-audio format tag for an ACM driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATTAGDETAILS.cbStruct">
            <summary>
            Size, in bytes, of the <c>ACMFORMATTAGDETAILS</c> structure. This member must be initialized before an application calls the
            acmFormatTagDetails or acmFormatTagEnum function. The size specified by this member must be large enough to contain the base
            <c>ACMFORMATTAGDETAILS</c> structure. When the <c>acmFormatTagDetails</c> function returns, this member contains the actual
            size of the information returned. The returned information will never exceed the requested size.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATTAGDETAILS.dwFormatTagIndex">
            <summary>
            Index of the format tag for which details will be retrieved. The index ranges from zero to one less than the number of
            format tags supported by an ACM driver. The number of format tags supported by a driver is contained in the ACMDRIVERDETAILS
            structure. The <c>dwFormatTagIndex</c> member is used only when querying format tag details on a driver by index; otherwise,
            this member should be zero.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATTAGDETAILS.dwFormatTag">
            <summary>
            Waveform-audio format tag that the <c>ACMFORMATTAGDETAILS</c> structure describes. This member is used for input for the
            ACM_FORMATTAGDETAILSF_FORMATTAG and ACM_FORMATTAGDETAILSF_LARGESTSIZE query flags. If the acmFormatTagDetails function is
            successful, this member is always returned. This member should be set to WAVE_FORMAT_UNKNOWN for all other query flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATTAGDETAILS.cbFormatSize">
            <summary>
            Largest total size, in bytes, of a waveform-audio format of the <c>dwFormatTag</c> type. For example, this member will be 16
            for WAVE_FORMAT_PCM and 50 for WAVE_FORMAT_ADPCM.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATTAGDETAILS.fdwSupport">
            <summary>
            <para>
            Driver-support flags specific to the format tag. These flags are identical to the ACMDRIVERDETAILS structure. This member
            may be some combination of the following values and refer to what operations the driver supports with the format tag:
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_ASYNC</term>
            <term>Driver supports asynchronous conversions with the specified format tag.</term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CODEC</term>
            <term>
            Driver supports conversion between two different format tags where one of the tags is the specified format tag. For example,
            if a driver supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_CONVERTER</term>
            <term>
            Driver supports conversion between two different formats of the specified format tag. For example, if a driver supports
            resampling of WAVE_FORMAT_PCM, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_FILTER</term>
            <term>
            Driver supports a filter (modification of the data without changing any of the format attributes). For example, if a driver
            supports volume or echo operations on the specified format tag, this flag is set.
            </term>
            </item>
            <item>
            <term>ACMDRIVERDETAILS_SUPPORTF_HARDWARE</term>
            <term>
            Driver supports hardware input, output, or both of the specified format tag through a waveform-audio device. An application
            should use the acmMetrics function with the ACM_METRIC_HARDWARE_WAVE_INPUT and ACM_METRIC_HARDWARE_WAVE_OUTPUT metric
            indexes to get the waveform-audio device identifiers associated with the supporting ACM driver.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATTAGDETAILS.cStandardFormats">
            <summary>
            Number of standard formats of the <c>dwFormatTag</c> type; that is, the combination of all sample rates, bits per sample,
            channels, and so on. This value can specify all formats supported by the driver, but not necessarily.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMFORMATTAGDETAILS.szFormatTag">
            <summary>
            String that describes the <c>dwFormatTag</c> type. If the acmFormatTagDetails function is successful, this string is always returned.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER">
            <summary>
            The <c>ACMSTREAMHEADER</c> structure defines the header used to identify an ACM conversion source and destination buffer pair
            for a conversion stream.
            </summary>
            <remarks>
            Before an <c>ACMSTREAMHEADER</c> structure can be used for a conversion, it must be prepared by using the acmStreamPrepareHeader
            function. When an application is finished with an <c>ACMSTREAMHEADER</c> structure, it must call the acmStreamUnprepareHeader
            function before freeing the source and destination buffers.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER.cbStruct">
            <summary>
            Size, in bytes, of the <c>ACMSTREAMHEADER</c> structure. This member must be initialized before the application calls any
            ACM stream functions using this structure. The size specified in this member must be large enough to contain the base
            <c>ACMSTREAMHEADER</c> structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER.fdwStatus">
            <summary>
            <para>
            Flags giving information about the conversion buffers. This member must be initialized to zero before the application calls
            the acmStreamPrepareHeader function and should not be modified by the application while the stream header remains prepared.
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ACMSTREAMHEADER_STATUSF_DONE</term>
            <term>Set by the ACM or driver to indicate that it is finished with the conversion and is returning the buffers to the application.</term>
            </item>
            <item>
            <term>ACMSTREAMHEADER_STATUSF_INQUEUE</term>
            <term>Set by the ACM or driver to indicate that the buffers are queued for conversion.</term>
            </item>
            <item>
            <term>ACMSTREAMHEADER_STATUSF_PREPARED</term>
            <term>Set by the ACM to indicate that the buffers have been prepared by using the acmStreamPrepareHeader function.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER.dwUser">
            <summary>User data. This can be any instance data specified by the application.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER.pbSrc">
            <summary>
            Pointer to the source buffer. This pointer must always refer to the same location while the stream header remains prepared.
            If an application needs to change the source location, it must unprepare the header and reprepare it with the alternate location.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER.cbSrcLength">
            <summary>
            Length, in bytes, of the source buffer pointed to by <c>pbSrc</c>. When the header is prepared, this member must specify the
            maximum size that will be used in the source buffer. Conversions can be performed on source lengths less than or equal to
            the original prepared size. However, this member must be reset to the original size when an application unprepares the header.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER.cbSrcLengthUsed">
            <summary>
            Amount of data, in bytes, used for the conversion. This member is not valid until the conversion is complete. This value can
            be less than or equal to <c>cbSrcLength</c>. An application must use the <c>cbSrcLengthUsed</c> member when advancing to the
            next piece of source data for the conversion stream.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER.dwSrcUser">
            <summary>User data. This can be any instance data specified by the application.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER.pbDst">
            <summary>
            Pointer to the destination buffer. This pointer must always refer to the same location while the stream header remains
            prepared. If an application needs to change the destination location, it must unprepare the header and reprepare it with the
            alternate location.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER.cbDstLength">
            <summary>
            Length, in bytes, of the destination buffer pointed to by <c>pbDst</c>. When the header is prepared, this member must
            specify the maximum size that will be used in the destination buffer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER.cbDstLengthUsed">
            <summary>
            Amount of data, in bytes, returned by a conversion. This member is not valid until the conversion is complete. This value
            can be less than or equal to <c>cbDstLength</c>. An application must use the <c>cbDstLengthUsed</c> member when advancing to
            the next destination location for the conversion stream.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER.dwDstUser">
            <summary>User data. This can be any instance data specified by the application.</summary>
        </member>
        <member name="F:Vanara.PInvoke.MsAcm32.ACMSTREAMHEADER.dwReservedDriver1">
            <summary>
            Reserved; do not use. This member requires no initialization by the application and should never be modified while the
            header remains prepared.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.HACMDRIVER">
            <summary>Provides a handle to an ACM driver.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVER.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.MsAcm32.HACMDRIVER"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.MsAcm32.HACMDRIVER.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.MsAcm32.HACMDRIVER"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.MsAcm32.HACMDRIVER.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVER.op_Explicit(Vanara.PInvoke.MsAcm32.HACMDRIVER)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.MsAcm32.HACMDRIVER"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVER.op_Implicit(System.IntPtr)~Vanara.PInvoke.MsAcm32.HACMDRIVER">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.MsAcm32.HACMDRIVER"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVER.op_Inequality(Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.MsAcm32.HACMDRIVER)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVER.op_Equality(Vanara.PInvoke.MsAcm32.HACMDRIVER,Vanara.PInvoke.MsAcm32.HACMDRIVER)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVER.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVER.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVER.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.HACMDRIVERID">
            <summary>Provides a handle to an ACM driver.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVERID.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.MsAcm32.HACMDRIVERID"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.MsAcm32.HACMDRIVERID.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.MsAcm32.HACMDRIVERID"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.MsAcm32.HACMDRIVERID.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVERID.op_Explicit(Vanara.PInvoke.MsAcm32.HACMDRIVERID)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.MsAcm32.HACMDRIVERID"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVERID.op_Implicit(System.IntPtr)~Vanara.PInvoke.MsAcm32.HACMDRIVERID">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.MsAcm32.HACMDRIVERID"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVERID.op_Inequality(Vanara.PInvoke.MsAcm32.HACMDRIVERID,Vanara.PInvoke.MsAcm32.HACMDRIVERID)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVERID.op_Equality(Vanara.PInvoke.MsAcm32.HACMDRIVERID,Vanara.PInvoke.MsAcm32.HACMDRIVERID)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVERID.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVERID.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMDRIVERID.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.HACMOBJ">
            <summary>Provides a handle to an ACM object.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMOBJ.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.MsAcm32.HACMOBJ"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.MsAcm32.HACMOBJ.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.MsAcm32.HACMOBJ"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.MsAcm32.HACMOBJ.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMOBJ.op_Explicit(Vanara.PInvoke.MsAcm32.HACMOBJ)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.MsAcm32.HACMOBJ"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMOBJ.op_Implicit(System.IntPtr)~Vanara.PInvoke.MsAcm32.HACMOBJ">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.MsAcm32.HACMOBJ"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMOBJ.op_Inequality(Vanara.PInvoke.MsAcm32.HACMOBJ,Vanara.PInvoke.MsAcm32.HACMOBJ)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMOBJ.op_Equality(Vanara.PInvoke.MsAcm32.HACMOBJ,Vanara.PInvoke.MsAcm32.HACMOBJ)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMOBJ.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMOBJ.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMOBJ.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.HACMSTREAM">
            <summary>Provides a handle to an ACM stream.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMSTREAM.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.MsAcm32.HACMSTREAM"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.MsAcm32.HACMSTREAM.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.MsAcm32.HACMSTREAM"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.MsAcm32.HACMSTREAM.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMSTREAM.op_Explicit(Vanara.PInvoke.MsAcm32.HACMSTREAM)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.MsAcm32.HACMSTREAM"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMSTREAM.op_Implicit(System.IntPtr)~Vanara.PInvoke.MsAcm32.HACMSTREAM">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.MsAcm32.HACMSTREAM"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMSTREAM.op_Inequality(Vanara.PInvoke.MsAcm32.HACMSTREAM,Vanara.PInvoke.MsAcm32.HACMSTREAM)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMSTREAM.op_Equality(Vanara.PInvoke.MsAcm32.HACMSTREAM,Vanara.PInvoke.MsAcm32.HACMSTREAM)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMSTREAM.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMSTREAM.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.HACMSTREAM.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.SafeHACMDRIVER">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.MsAcm32.HACMDRIVER"/> that is disposed using <see cref="M:Vanara.PInvoke.MsAcm32.acmDriverClose(Vanara.PInvoke.MsAcm32.HACMDRIVER,System.UInt32)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.SafeHACMDRIVER.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.MsAcm32.SafeHACMDRIVER"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle"><see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).</param>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.SafeHACMDRIVER.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.MsAcm32.SafeHACMDRIVER"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.SafeHACMDRIVER.op_Implicit(Vanara.PInvoke.MsAcm32.SafeHACMDRIVER)~Vanara.PInvoke.MsAcm32.HACMDRIVER">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.MsAcm32.SafeHACMDRIVER"/> to <see cref="T:Vanara.PInvoke.MsAcm32.HACMDRIVER"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.SafeHACMDRIVER.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.MsAcm32.SafeHACMSTREAM">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.MsAcm32.HACMSTREAM"/> that is disposed using <see cref="M:Vanara.PInvoke.MsAcm32.acmStreamClose(Vanara.PInvoke.MsAcm32.HACMSTREAM,System.UInt32)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.SafeHACMSTREAM.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.MsAcm32.SafeHACMSTREAM"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.SafeHACMSTREAM.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.MsAcm32.SafeHACMSTREAM"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.SafeHACMSTREAM.op_Implicit(Vanara.PInvoke.MsAcm32.SafeHACMSTREAM)~Vanara.PInvoke.MsAcm32.HACMSTREAM">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.MsAcm32.SafeHACMSTREAM"/> to <see cref="T:Vanara.PInvoke.MsAcm32.HACMSTREAM"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.MsAcm32.SafeHACMSTREAM.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32">
            <summary>Items from the AviFil32.dll</summary>
            <summary>Items from the AviFil32.dll</summary>
            <summary>Items from the AviFil32.dll</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMREAD_CONVENIENT">
            <summary>Let the stream handler determine the number of samples to read.</summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.AVISAVECALLBACK">
            <summary>
            A callback function (referenced by using lpfnCallback) can display status information and let the user cancel the save operation.
            </summary>
            <param name="nPercent">Specifies the percentage of the file saved.</param>
            <returns>
            The callback function should return <see langword="false"/> if the operation should continue and <see langword="true"/> if the
            user wishes to abort the save operation.
            </returns>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.AVICOMPRESSF">
            <summary>Flags used for compression.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSF.AVICOMPRESSF_INTERLEAVE">
            <summary>Interleaves this stream every dwInterleaveEvery frames with respect to the first stream.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSF.AVICOMPRESSF_DATARATE">
            <summary>Compresses this video stream using the data rate specified in dwBytesPerSecond.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSF.AVICOMPRESSF_KEYFRAMES">
            <summary>
            Saves this video stream with key frames at least every dwKeyFrameEvery frames. By default, every frame will be a key frame.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSF.AVICOMPRESSF_VALID">
            <summary>
            Uses the data in this structure to set the default compression values for AVISaveOptions. If an empty structure is passed
            and this flag is not set, some defaults will be chosen.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.AVIFILECAPS">
            <summary>Capability flags for <see cref="T:Vanara.PInvoke.AviFil32.AVIFILEINFO"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILECAPS.AVIFILECAPS_CANREAD">
            <summary>An application can open the AVI file with the read privilege.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILECAPS.AVIFILECAPS_CANWRITE">
            <summary>An application can open the AVI file with the write privilege.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILECAPS.AVIFILECAPS_ALLKEYFRAMES">
            <summary>Every frame in the AVI file is a key frame.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILECAPS.AVIFILECAPS_NOCOMPRESSION">
            <summary>The AVI file does not use a compression method.</summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.AVIFILEINFOF">
            <summary>Flags for <see cref="T:Vanara.PInvoke.AviFil32.AVIFILEINFO"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFOF.AVIFILEINFO_HASINDEX">
            <summary>The AVI file has an index at the end of the file. For good performance, all AVI files should contain an index.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFOF.AVIFILEINFO_MUSTUSEINDEX">
            <summary>
            The file index contains the playback order for the chunks in the file. Use the index rather than the physical ordering of
            the chunks when playing back the data. This could be used for creating a list of frames for editing.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFOF.AVIFILEINFO_ISINTERLEAVED">
            <summary>The AVI file is interleaved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFOF.AVIFILEINFO_WASCAPTUREFILE">
            <summary>
            The AVI file is a specially allocated file used for capturing real-time video. Applications should warn the user before
            writing over a file with this flag set because the user probably defragmented this file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFOF.AVIFILEINFO_COPYRIGHTED">
            <summary>
            The AVI file contains copyrighted data and software. When this flag is used, software should not permit the data to be duplicated.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.AVIIF">
            <summary>Flag associated with this data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIIF.AVIIF_LIST">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIIF.AVIIF_TWOCC">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIIF.AVIIF_KEYFRAME">
            <summary>Indicates this data does not rely on preceding data in the file.</summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.AVISTREAMINFOF">
            <summary>Applicable flags for the stream.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFOF.AVISTREAMINFO_DISABLED">
            <summary>Indicates this stream should be rendered when explicitly enabled by the user.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFOF.AVISTREAMINFO_FORMATCHANGES">
            <summary>
            Indicates this video stream contains palette changes. This flag warns the playback software that it will need to animate the palette.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.AVSTREAMMASTER">
            <summary>Indicates whether the audio stream controls the clock when writing an AVI file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVSTREAMMASTER.AVSTREAMMASTER_AUDIO">
            <summary>
            The audio stream is considered the master stream and the video stream duration is forced to match the audio duration.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVSTREAMMASTER.AVSTREAMMASTER_NONE">
            <summary>The durations of audio and video streams can differ.</summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.FINDF">
            <summary>
            Flags that designate the type of frame to locate, the direction in the stream to search, and the type of return information.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_DIR">
            <summary>direction</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_NEXT">
            <summary>
            Finds nearest sample, frame, or format change searching forward. The current sample is included in the search. Use this flag
            with the FIND_ANY, FIND_KEY, or FIND_FORMAT flag. This flag supersedes the SEARCH_FORWARD flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_PREV">
            <summary>
            Finds nearest sample, frame, or format change searching backward. The current sample is included in the search. Use this
            flag with the FIND_ANY, FIND_KEY, or FIND_FORMAT flag. This flag supersedes the SEARCH_NEAREST and SEARCH_BACKWARD flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_FROM_START">
            <summary>
            Finds first sample, frame, or format change beginning from the start of the stream. Use this flag with the FIND_ANY,
            FIND_KEY, or FIND_FORMAT flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_TYPE">
            <summary>type mask</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_KEY">
            <summary>Finds a key frame. This flag supersedes the SEARCH_KEY flag.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_ANY">
            <summary>Finds a nonempty frame. This flag supersedes the SEARCH_ANY flag.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_FORMAT">
            <summary>Finds a format change.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_RET">
            <summary>return mask</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_POS">
            <summary>return logical position</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_LENGTH">
            <summary>return logical size</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_OFFSET">
            <summary>return physical position</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_SIZE">
            <summary>return physical size</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.FINDF.FIND_INDEX">
            <summary>return physical index position</summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.ICMF_CHOOSE">
            <summary>Flags for displaying the Compression Options dialog box.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.ICMF_CHOOSE.ICMF_CHOOSE_KEYFRAME">
            <summary>
            Displays a Key Frame Every dialog box for the video options. This is the same flag used in the ICCompressorChoose function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.ICMF_CHOOSE.ICMF_CHOOSE_DATARATE">
            <summary>Displays a Data Rate dialog box for the video options. This is the same flag used in ICCompressorChoose.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.ICMF_CHOOSE.ICMF_CHOOSE_PREVIEW">
            <summary>
            Displays a Preview button for the video options. This button previews the compression by using a frame from the stream. This
            is the same flag used in ICCompressorChoose.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.ICMF_CHOOSE.ICMF_CHOOSE_ALLCOMPRESSORS">
            <summary>Don't only show those that can handle the input format or input data.</summary>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIBuildFilter(System.Text.StringBuilder,System.Int32,System.Boolean)">
            <summary>
            The <c>AVIBuildFilter</c> function builds a filter specification that is subsequently used by the GetOpenFileName or
            GetSaveFileName function.
            </summary>
            <param name="lpszFilter">Pointer to the buffer containing the filter string.</param>
            <param name="cbFilter">Size, in characters, of buffer pointed to by lpszFilter.</param>
            <param name="fSaving">
            Flag that indicates whether the filter should include read or write formats. Specify <c>TRUE</c> to include write formats or
            <c>FALSE</c> to include read formats.
            </param>
            <returns>
            <para>Returns AVIERR_OK if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AVIERR_BUFFERTOOSMALL</term>
            <term>The buffer size cbFilter was smaller than the generated filter specification.</term>
            </item>
            <item>
            <term>AVIERR_MEMORY</term>
            <term>There was not enough memory to complete the read operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This function accesses the registry for all filter types that the AVIFile library can use to open, read, or write multimedia
            files. It does not search the hard disk for filter DLLs and formats.
            </para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines AVIBuildFilter as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIClearClipboard">
            <summary>The <c>AVIClearClipboard</c> function removes an AVI file from the clipboard.</summary>
            <returns>Returns zero if successful or an error otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIFileAddRef(Vanara.PInvoke.AviFil32.IAVIFile)">
            <summary>The <c>AVIFileAddRef</c> function increments the reference count of an AVI file.</summary>
            <param name="pfile">Handle to an open AVI file.</param>
            <returns>Returns the updated reference count for the file interface.</returns>
            <remarks>The argument pfile is a pointer to an IAVIFile interface.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIFileCreateStream(Vanara.PInvoke.AviFil32.IAVIFile,Vanara.PInvoke.AviFil32.IAVIStream@,Vanara.PInvoke.AviFil32.AVISTREAMINFO@)">
            <summary>
            The <c>AVIFileCreateStream</c> function creates a new stream in an existing file and creates an interface to the new stream.
            </summary>
            <param name="pfile">Handle to an open AVI file.</param>
            <param name="ppavi">Pointer to the new stream interface.</param>
            <param name="psi">
            Pointer to a structure containing information about the new stream, including the stream type and its sample rate.
            </param>
            <returns>
            Returns zero if successful or an error otherwise. Unless the file has been opened with write permission, this function returns AVIERR_READONLY.
            </returns>
            <remarks>
            <para>This function starts a reference count for the new stream.</para>
            <para>The argument pfile is a pointer to an IAVIFile interface. The argument ppavi is a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIFileEndRecord(Vanara.PInvoke.AviFil32.IAVIFile)">
            <summary>
            The <c>AVIFileEndRecord</c> function marks the end of a record when writing an interleaved file that uses a 1:1 interleave
            factor of video to audio data. (Each frame of video is interspersed with an equivalent amount of audio data.)
            </summary>
            <param name="pfile">Handle to an open AVI file.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>The AVISave function uses this function internally. In general, applications should not need to use this function.</para>
            <para>The argument pfile is a pointer to an IAVIFile interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIFileExit">
            <summary>
            <para>The <c>AVIFileExit</c> function exits the AVIFile library and decrements the reference count for the library.</para>
            <para>This function supersedes the obsolete <c>AVIStreamExit</c> function.</para>
            </summary>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIFileGetStream(Vanara.PInvoke.AviFil32.IAVIFile,Vanara.PInvoke.AviFil32.IAVIStream@,System.UInt32,System.Int32)">
            <summary>
            The <c>AVIFileGetStream</c> function returns the address of a stream interface that is associated with a specified AVI file.
            </summary>
            <param name="pfile">Handle to an open AVI file.</param>
            <param name="ppavi">Pointer to the new stream interface.</param>
            <param name="fccType">
            <para>
            Four-character code indicating the type of stream to open. Zero indicates any stream can be opened. The following definitions
            apply to the data commonly found in AVI streams.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>streamtypeAUDIO</term>
            <term>Indicates an audio stream.</term>
            </item>
            <item>
            <term>streamtypeMIDI</term>
            <term>Indicates a MIDI stream.</term>
            </item>
            <item>
            <term>streamtypeTEXT</term>
            <term>Indicates a text stream.</term>
            </item>
            <item>
            <term>streamtypeVIDEO</term>
            <term>Indicates a video stream.</term>
            </item>
            </list>
            </param>
            <param name="lParam">Count of the stream type. Identifies which occurrence of the specified stream type to access.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AVIERR_NODATA</term>
            <term>The file does not contain a stream corresponding to the values of fccType and lParam.</term>
            </item>
            <item>
            <term>AVIERR_MEMORY</term>
            <term>Not enough memory.</term>
            </item>
            </list>
            </returns>
            <remarks>The argument pfile is a pointer to an IAVIFile interface. The argument ppavi is a pointer to an IAVIStream interface.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIFileInfo(Vanara.PInvoke.AviFil32.IAVIFile,Vanara.PInvoke.AviFil32.AVIFILEINFO@,System.Int32)">
            <summary>The <c>AVIFileInfo</c> function obtains information about an AVI file.</summary>
            <param name="pfile">Handle to an open AVI file.</param>
            <param name="pfi">
            Pointer to the structure used to return file information. Typically, this parameter points to an AVIFILEINFO structure.
            </param>
            <param name="lSize">Size, in bytes, of the structure.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>The argument pfile is a pointer to an IAVIFile interface.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIFileInit">
            <summary>
            <para>The <c>AVIFileInit</c> function initializes the AVIFile library.</para>
            <para>
            The AVIFile library maintains a count of the number of times it is initialized, but not the number of times it was released. Use
            the AVIFileExit function to release the AVIFile library and decrement the reference count. Call <c>AVIFileInit</c> before using
            any other AVIFile functions.
            </para>
            <para>This function supersedes the obsolete <c>AVIStreamInit</c> function.</para>
            </summary>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIFileOpen(Vanara.PInvoke.AviFil32.IAVIFile@,System.String,Vanara.PInvoke.Kernel32.OpenFileAction,System.Guid@)">
            <summary>
            The <c>AVIFileOpen</c> function opens an AVI file and returns the address of a file interface used to access it. The AVIFile
            library maintains a count of the number of times a file is opened, but not the number of times it was released. Use the
            AVIFileRelease function to release the file and decrement the count.
            </summary>
            <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
            <param name="szFile">Null-terminated string containing the name of the file to open.</param>
            <param name="uMode">
            <para>
            Access mode to use when opening the file. The default access mode is OF_READ. The following access modes can be specified with <c>AVIFileOpen</c>.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>OF_CREATE</term>
            <term>Creates a new file. If the file already exists, it is truncated to zero length.</term>
            </item>
            <item>
            <term>OF_PARSE</term>
            <term>
            Skips time-consuming operations, such as building an index. Set this flag if you want the function to return as quickly as
            possible—for example, if you are going to query the file properties but not read the file.
            </term>
            </item>
            <item>
            <term>OF_READ</term>
            <term>Opens the file for reading.</term>
            </item>
            <item>
            <term>OF_READWRITE</term>
            <term>Opens the file for reading and writing.</term>
            </item>
            <item>
            <term>OF_SHARE_DENY_NONE</term>
            <term>
            Opens the file nonexclusively. Other processes can open the file with read or write access. AVIFileOpen fails if another process
            has opened the file in compatibility mode.
            </term>
            </item>
            <item>
            <term>OF_SHARE_DENY_READ</term>
            <term>
            Opens the file nonexclusively. Other processes can open the file with write access. AVIFileOpen fails if another process has
            opened the file in compatibility mode or has read access to it.
            </term>
            </item>
            <item>
            <term>OF_SHARE_DENY_WRITE</term>
            <term>
            Opens the file nonexclusively. Other processes can open the file with read access. AVIFileOpen fails if another process has
            opened the file in compatibility mode or has write access to it.
            </term>
            </item>
            <item>
            <term>OF_SHARE_EXCLUSIVE</term>
            <term>Opens the file and denies other processes any access to it. AVIFileOpen fails if any other process has opened the file.</term>
            </item>
            <item>
            <term>OF_WRITE</term>
            <term>Opens the file for writing.</term>
            </item>
            </list>
            </param>
            <param name="lpHandler">
            Pointer to a class identifier of the standard or custom handler you want to use. If the value is <c>NULL</c>, the system chooses
            a handler from the registry based on the file extension or the RIFF type specified in the file.
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AVIERR_BADFORMAT</term>
            <term>The file couldn't be read, indicating a corrupt file or an unrecognized format.</term>
            </item>
            <item>
            <term>AVIERR_MEMORY</term>
            <term>The file could not be opened because of insufficient memory.</term>
            </item>
            <item>
            <term>AVIERR_FILEREAD</term>
            <term>A disk error occurred while reading the file.</term>
            </item>
            <item>
            <term>AVIERR_FILEOPEN</term>
            <term>A disk error occurred while opening the file.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>According to the registry, the type of file specified in AVIFileOpen does not have a handler to process it.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIFileOpen(Vanara.PInvoke.AviFil32.IAVIFile@,System.String,Vanara.PInvoke.Kernel32.OpenFileAction,Vanara.InteropServices.GuidPtr)">
            <summary>
            The <c>AVIFileOpen</c> function opens an AVI file and returns the address of a file interface used to access it. The AVIFile
            library maintains a count of the number of times a file is opened, but not the number of times it was released. Use the
            AVIFileRelease function to release the file and decrement the count.
            </summary>
            <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
            <param name="szFile">Null-terminated string containing the name of the file to open.</param>
            <param name="uMode">
            <para>
            Access mode to use when opening the file. The default access mode is OF_READ. The following access modes can be specified with <c>AVIFileOpen</c>.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>OF_CREATE</term>
            <term>Creates a new file. If the file already exists, it is truncated to zero length.</term>
            </item>
            <item>
            <term>OF_PARSE</term>
            <term>
            Skips time-consuming operations, such as building an index. Set this flag if you want the function to return as quickly as
            possible—for example, if you are going to query the file properties but not read the file.
            </term>
            </item>
            <item>
            <term>OF_READ</term>
            <term>Opens the file for reading.</term>
            </item>
            <item>
            <term>OF_READWRITE</term>
            <term>Opens the file for reading and writing.</term>
            </item>
            <item>
            <term>OF_SHARE_DENY_NONE</term>
            <term>
            Opens the file nonexclusively. Other processes can open the file with read or write access. AVIFileOpen fails if another process
            has opened the file in compatibility mode.
            </term>
            </item>
            <item>
            <term>OF_SHARE_DENY_READ</term>
            <term>
            Opens the file nonexclusively. Other processes can open the file with write access. AVIFileOpen fails if another process has
            opened the file in compatibility mode or has read access to it.
            </term>
            </item>
            <item>
            <term>OF_SHARE_DENY_WRITE</term>
            <term>
            Opens the file nonexclusively. Other processes can open the file with read access. AVIFileOpen fails if another process has
            opened the file in compatibility mode or has write access to it.
            </term>
            </item>
            <item>
            <term>OF_SHARE_EXCLUSIVE</term>
            <term>Opens the file and denies other processes any access to it. AVIFileOpen fails if any other process has opened the file.</term>
            </item>
            <item>
            <term>OF_WRITE</term>
            <term>Opens the file for writing.</term>
            </item>
            </list>
            </param>
            <param name="lpHandler">
            Pointer to a class identifier of the standard or custom handler you want to use. If the value is <c>NULL</c>, the system chooses
            a handler from the registry based on the file extension or the RIFF type specified in the file.
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AVIERR_BADFORMAT</term>
            <term>The file couldn't be read, indicating a corrupt file or an unrecognized format.</term>
            </item>
            <item>
            <term>AVIERR_MEMORY</term>
            <term>The file could not be opened because of insufficient memory.</term>
            </item>
            <item>
            <term>AVIERR_FILEREAD</term>
            <term>A disk error occurred while reading the file.</term>
            </item>
            <item>
            <term>AVIERR_FILEOPEN</term>
            <term>A disk error occurred while opening the file.</term>
            </item>
            <item>
            <term>REGDB_E_CLASSNOTREG</term>
            <term>According to the registry, the type of file specified in AVIFileOpen does not have a handler to process it.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIFileReadData(Vanara.PInvoke.AviFil32.IAVIFile,System.UInt32,System.IntPtr,System.Int32@)">
            <summary>
            The <c>AVIFileReadData</c> function reads optional header data that applies to the entire file, such as author or copyright information.
            </summary>
            <param name="pfile">Handle to an open AVI file.</param>
            <param name="ckid">RIFF chunk identifier (four-character code) of the data.</param>
            <param name="lpData">Pointer to the buffer used to return the data read.</param>
            <param name="lpcbData">
            Pointer to a location indicating the size of the memory block referenced by lpData. If the data is read successfully, the value
            is changed to indicate the amount of data read.
            </param>
            <returns>
            Returns zero if successful or an error otherwise. The return value AVIERR_NODATA indicates that data with the requested chunk
            identifier does not exist.
            </returns>
            <remarks>
            <para>The optional header information is custom and does not have a set format.</para>
            <para>The argument pfile is a pointer to an IAVIFile interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIFileRelease(Vanara.PInvoke.AviFil32.IAVIFile)">
            <summary>
            <para>
            The <c>AVIFileRelease</c> function decrements the reference count of an AVI file interface handle and closes the file if the
            count reaches zero.
            </para>
            <para>This function supersedes the obsolete <c>AVIFileClose</c> function.</para>
            </summary>
            <param name="pfile">Handle to an open AVI file.</param>
            <returns>Returns the reference count of the file. This return value should be used only for debugging purposes.</returns>
            <remarks>The argument pfile is a pointer to an IAVIFile interface.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIFileWriteData(Vanara.PInvoke.AviFil32.IAVIFile,System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            The <c>AVIFileWriteData</c> function writes supplementary data (other than normal header, format, and stream data) to the file.
            </summary>
            <param name="pfile">Handle to an open AVI file.</param>
            <param name="ckid">RIFF chunk identifier (four-character code) of the data.</param>
            <param name="lpData">Pointer to the buffer used to write the data.</param>
            <param name="cbData">Size, in bytes, of the memory block referenced by lpData.</param>
            <returns>
            Returns zero if successful or an error otherwise. In an application has read-only access to the file, the error code
            AVIERR_READONLY is returned.
            </returns>
            <remarks>
            <para>Use the AVIStreamWriteData function to write data that applies to an individual stream.</para>
            <para>The argument pfile is a pointer to an IAVIFile interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIGetFromClipboard(Vanara.PInvoke.AviFil32.IAVIFile@)">
            <summary>The <c>AVIGetFromClipboard</c> function copies an AVI file from the clipboard.</summary>
            <param name="lppf">Pointer to the location used to return the handle created for the AVI file.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>
            If the clipboard does not contain an AVI file, <c>AVIGetFromClipboard</c> also can copy data with the CF_DIB or CF_WAVE
            clipboard flags to an AVI file. In this case, the function creates an AVI file with one DIB stream and one waveform-audio
            stream, and fills each stream with the data from the clipboard.
            </para>
            <para>The argument lppf is the address of a pointer to an IAVIFile interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIMakeCompressedStream(Vanara.PInvoke.AviFil32.IAVIStream@,Vanara.PInvoke.AviFil32.IAVIStream,Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS@,System.Guid@)">
            <summary>
            The <c>AVIMakeCompressedStream</c> function creates a compressed stream from an uncompressed stream and a compression filter,
            and returns the address of a pointer to the compressed stream. This function supports audio and video compression.
            </summary>
            <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
            <param name="ppsSource">Pointer to the stream to be compressed.</param>
            <param name="lpOptions">
            Pointer to a structure that identifies the type of compression to use and the options to apply. You can specify video
            compression by identifying an appropriate handler in the AVICOMPRESSOPTIONS structure. For audio compression, specify the
            compressed data format.
            </param>
            <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
            <returns>
            <para>Returns AVIERR_OK if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AVIERR_NOCOMPRESSOR</term>
            <term>A suitable compressor cannot be found.</term>
            </item>
            <item>
            <term>AVIERR_MEMORY</term>
            <term>There is not enough memory to complete the operation.</term>
            </item>
            <item>
            <term>AVIERR_UNSUPPORTED</term>
            <term>
            Compression is not supported for this type of data. This error might be returned if you try to compress data that is not audio
            or video.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Applications can read from or write to the compressed stream.</para>
            <para>A <c>IAVIStream</c> is a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIMakeCompressedStream(Vanara.PInvoke.AviFil32.IAVIStream@,Vanara.PInvoke.AviFil32.IAVIStream,Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS@,Vanara.InteropServices.GuidPtr)">
            <summary>
            The <c>AVIMakeCompressedStream</c> function creates a compressed stream from an uncompressed stream and a compression filter,
            and returns the address of a pointer to the compressed stream. This function supports audio and video compression.
            </summary>
            <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
            <param name="ppsSource">Pointer to the stream to be compressed.</param>
            <param name="lpOptions">
            Pointer to a structure that identifies the type of compression to use and the options to apply. You can specify video
            compression by identifying an appropriate handler in the AVICOMPRESSOPTIONS structure. For audio compression, specify the
            compressed data format.
            </param>
            <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
            <returns>
            <para>Returns AVIERR_OK if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AVIERR_NOCOMPRESSOR</term>
            <term>A suitable compressor cannot be found.</term>
            </item>
            <item>
            <term>AVIERR_MEMORY</term>
            <term>There is not enough memory to complete the operation.</term>
            </item>
            <item>
            <term>AVIERR_UNSUPPORTED</term>
            <term>
            Compression is not supported for this type of data. This error might be returned if you try to compress data that is not audio
            or video.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>Applications can read from or write to the compressed stream.</para>
            <para>A <c>IAVIStream</c> is a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIMakeFileFromStreams(Vanara.PInvoke.AviFil32.IAVIFile@,System.Int32,Vanara.PInvoke.AviFil32.IAVIStream[])">
            <summary>The <c>AVIMakeFileFromStreams</c> function constructs an AVIFile interface pointer from separate streams.</summary>
            <param name="ppfile">Pointer to a buffer that receives the new file interface pointer.</param>
            <param name="nStreams">Count of the number of streams in the array of stream interface pointers referenced by papStreams.</param>
            <param name="papStreams">Pointer to an array of stream interface pointers.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>Use the AVIFileRelease function to close the file.</para>
            <para>
            Other functions can use the AVIFile interface created by this function to copy and edit the streams associated with the
            interface. For example, you can retrieve a specific stream by using AVIFileGetStream with the file interface pointer.
            </para>
            <para>
            The argument pfile is the address of a pointer to an IAVIFile interface. The argument papStreams is the address of a pointer to
            an IAVIStream interface.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIMakeStreamFromClipboard(System.UInt32,Vanara.PInvoke.Kernel32.HGLOBAL,Vanara.PInvoke.AviFil32.IAVIStream@)">
            <summary>The <c>AVIMakeStreamFromClipboard</c> function creates an editable stream from stream data on the clipboard.</summary>
            <param name="cfFormat">Clipboard flag.</param>
            <param name="hGlobal">Handle to stream data on the clipboard.</param>
            <param name="ppstream">Handle to the created stream.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>
            When an application finishes using the editable stream, it must release the stream to free the resources associated with it.
            </para>
            <para>The argument ppstream is the address of a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIPutFileOnClipboard(Vanara.PInvoke.AviFil32.IAVIFile)">
            <summary>The <c>AVIPutFileOnClipboard</c> function copies an AVI file to the clipboard.</summary>
            <param name="pf">Handle to an open AVI file.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>
            This function also copies data with the CF_DIB, CF_PALETTE, and CF_WAVE clipboard flags onto the clipboard using the first frame
            of the first video stream of the file as a DIB and using the audio stream as CF_WAVE.
            </para>
            <para>The argument pf is a pointer to an IAVIFile interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVISave(System.String,System.Guid@,Vanara.PInvoke.AviFil32.AVISAVECALLBACK,System.Int32,Vanara.PInvoke.AviFil32.IAVIStream,Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS@)">
            <summary>The <c>AVISave</c> function builds a file by combining data streams from other files or from memory.</summary>
            <param name="szFile">Null-terminated string containing the name of the file to save.</param>
            <param name="pclsidHandler">
            Pointer to the file handler used to write the file. The file is created by calling the AVIFileOpen function using this handler.
            If a handler is not specified, a default is selected from the registry based on the file extension.
            </param>
            <param name="lpfnCallback">Pointer to a callback function for the save operation.</param>
            <param name="nStreams">Number of streams saved in the file.</param>
            <param name="pfile">
            Pointer to an AVI stream. This parameter is paired with lpOptions. The parameter pair can be repeated as a variable number of arguments.
            </param>
            <param name="lpOptions">
            Pointer to an application-defined AVICOMPRESSOPTIONS structure containing the compression options for the stream referenced by
            pavi. This parameter is paired with pavi. The parameter pair can be repeated as a variable number of arguments.
            </param>
            <returns>Returns AVIERR_OK if successful or an error otherwise.</returns>
            <remarks>
            <para>
            This function creates a file, copies stream data into the file, closes the file, and releases the resources used by the new
            file. The last two parameters of this function identify a stream to save in the file and define the compression options of that
            stream. When saving more than one stream in an AVI file, repeat these two stream-specific parameters for each stream in the file.
            </para>
            <para>
            A callback function (referenced by using lpfnCallback) can display status information and let the user cancel the save
            operation. The callback function uses the following format:
            </para>
            <para>
            <code> LONG PASCAL SaveCallback(int nPercent)</code>
            </para>
            <para>The nPercent parameter specifies the percentage of the file saved.</para>
            <para>
            The callback function should return AVIERR_OK if the operation should continue and AVIERR_USERABORT if the user wishes to abort
            the save operation.
            </para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines AVISave as an alias which automatically selects the ANSI or Unicode version of this function based on
            the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVISave(System.String,Vanara.InteropServices.GuidPtr,Vanara.PInvoke.AviFil32.AVISAVECALLBACK,System.Int32,Vanara.PInvoke.AviFil32.IAVIStream,Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS@)">
            <summary>The <c>AVISave</c> function builds a file by combining data streams from other files or from memory.</summary>
            <param name="szFile">Null-terminated string containing the name of the file to save.</param>
            <param name="pclsidHandler">
            Pointer to the file handler used to write the file. The file is created by calling the AVIFileOpen function using this handler.
            If a handler is not specified, a default is selected from the registry based on the file extension.
            </param>
            <param name="lpfnCallback">Pointer to a callback function for the save operation.</param>
            <param name="nStreams">Number of streams saved in the file.</param>
            <param name="pfile">
            Pointer to an AVI stream. This parameter is paired with lpOptions. The parameter pair can be repeated as a variable number of arguments.
            </param>
            <param name="lpOptions">
            Pointer to an application-defined AVICOMPRESSOPTIONS structure containing the compression options for the stream referenced by
            pavi. This parameter is paired with pavi. The parameter pair can be repeated as a variable number of arguments.
            </param>
            <returns>Returns AVIERR_OK if successful or an error otherwise.</returns>
            <remarks>
            <para>
            This function creates a file, copies stream data into the file, closes the file, and releases the resources used by the new
            file. The last two parameters of this function identify a stream to save in the file and define the compression options of that
            stream. When saving more than one stream in an AVI file, repeat these two stream-specific parameters for each stream in the file.
            </para>
            <para>
            A callback function (referenced by using lpfnCallback) can display status information and let the user cancel the save
            operation. The callback function uses the following format:
            </para>
            <para>
            <code> LONG PASCAL SaveCallback(int nPercent)</code>
            </para>
            <para>The nPercent parameter specifies the percentage of the file saved.</para>
            <para>
            The callback function should return AVIERR_OK if the operation should continue and AVIERR_USERABORT if the user wishes to abort
            the save operation.
            </para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines AVISave as an alias which automatically selects the ANSI or Unicode version of this function based on
            the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVISaveOptions(Vanara.PInvoke.HWND,Vanara.PInvoke.AviFil32.ICMF_CHOOSE,System.Int32,Vanara.PInvoke.AviFil32.IAVIStream[],System.IntPtr[])">
            <summary>The <c>AVISaveOptions</c> function retrieves the save options for a file and returns them in a buffer.</summary>
            <param name="hwnd">Handle to the parent window for the Compression Options dialog box.</param>
            <param name="uiFlags">
            <para>Flags for displaying the Compression Options dialog box. The following flags are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICMF_CHOOSE_KEYFRAME</term>
            <term>Displays a Key Frame Every dialog box for the video options. This is the same flag used in the ICCompressorChoose function.</term>
            </item>
            <item>
            <term>ICMF_CHOOSE_DATARATE</term>
            <term>Displays a Data Rate dialog box for the video options. This is the same flag used in ICCompressorChoose.</term>
            </item>
            <item>
            <term>ICMF_CHOOSE_PREVIEW</term>
            <term>
            Displays a Preview button for the video options. This button previews the compression by using a frame from the stream. This is
            the same flag used in ICCompressorChoose.
            </term>
            </item>
            </list>
            </param>
            <param name="nStreams">Number of streams that have their options set by the dialog box.</param>
            <param name="ppavi">
            Pointer to an array of stream interface pointers. The nStreams parameter indicates the number of pointers in the array.
            </param>
            <param name="plpOptions">
            Pointer to an array of pointers to AVICOMPRESSOPTIONS structures. These structures hold the compression options set by the
            dialog box. The nStreams parameter indicates the number of pointers in the array.
            </param>
            <returns>Returns <c>TRUE</c> if the user pressed OK, <c>FALSE</c> for CANCEL, or an error otherwise.</returns>
            <remarks>
            <para>
            This function presents a standard Compression Options dialog box using hwnd as the parent window handle. When the user is
            finished selecting the compression options for each stream, the options are returned in the AVICOMPRESSOPTIONS structure in the
            array referenced by plpOptions. The calling application must pass the interface pointers for the streams in the array referenced
            by ppavi.
            </para>
            <para>An application must allocate memory for the AVICOMPRESSOPTIONS structures and the array of pointers to these structures.</para>
            <para>The argument ppavi contains the address of a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVISaveOptions(Vanara.PInvoke.HWND,Vanara.PInvoke.AviFil32.ICMF_CHOOSE,System.Int32,Vanara.PInvoke.AviFil32.IAVIStream[],Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS**)">
            <summary>The <c>AVISaveOptions</c> function retrieves the save options for a file and returns them in a buffer.</summary>
            <param name="hwnd">Handle to the parent window for the Compression Options dialog box.</param>
            <param name="uiFlags">
            <para>Flags for displaying the Compression Options dialog box. The following flags are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICMF_CHOOSE_KEYFRAME</term>
            <term>Displays a Key Frame Every dialog box for the video options. This is the same flag used in the ICCompressorChoose function.</term>
            </item>
            <item>
            <term>ICMF_CHOOSE_DATARATE</term>
            <term>Displays a Data Rate dialog box for the video options. This is the same flag used in ICCompressorChoose.</term>
            </item>
            <item>
            <term>ICMF_CHOOSE_PREVIEW</term>
            <term>
            Displays a Preview button for the video options. This button previews the compression by using a frame from the stream. This is
            the same flag used in ICCompressorChoose.
            </term>
            </item>
            </list>
            </param>
            <param name="nStreams">Number of streams that have their options set by the dialog box.</param>
            <param name="ppavi">
            Pointer to an array of stream interface pointers. The nStreams parameter indicates the number of pointers in the array.
            </param>
            <param name="plpOptions">
            Pointer to an array of pointers to AVICOMPRESSOPTIONS structures. These structures hold the compression options set by the
            dialog box. The nStreams parameter indicates the number of pointers in the array.
            </param>
            <returns>Returns <c>TRUE</c> if the user pressed OK, <c>FALSE</c> for CANCEL, or an error otherwise.</returns>
            <remarks>
            <para>
            This function presents a standard Compression Options dialog box using hwnd as the parent window handle. When the user is
            finished selecting the compression options for each stream, the options are returned in the AVICOMPRESSOPTIONS structure in the
            array referenced by plpOptions. The calling application must pass the interface pointers for the streams in the array referenced
            by ppavi.
            </para>
            <para>An application must allocate memory for the AVICOMPRESSOPTIONS structures and the array of pointers to these structures.</para>
            <para>The argument ppavi contains the address of a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVISaveOptionsFree(System.Int32,System.IntPtr[])">
            <summary>The <c>AVISaveOptionsFree</c> function frees the resources allocated by the AVISaveOptions function.</summary>
            <param name="nStreams">Count of the AVICOMPRESSOPTIONS structures referenced in plpOptions.</param>
            <param name="plpOptions">
            Pointer to an array of pointers to AVICOMPRESSOPTIONS structures. These structures hold the compression options set by the
            dialog box. The resources allocated by AVISaveOptions for each of these structures will be freed.
            </param>
            <returns>Returns AVIERR_OK.</returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVISaveOptionsFree(System.Int32,Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS**)">
            <summary>The <c>AVISaveOptionsFree</c> function frees the resources allocated by the AVISaveOptions function.</summary>
            <param name="nStreams">Count of the AVICOMPRESSOPTIONS structures referenced in plpOptions.</param>
            <param name="plpOptions">
            Pointer to an array of pointers to AVICOMPRESSOPTIONS structures. These structures hold the compression options set by the
            dialog box. The resources allocated by AVISaveOptions for each of these structures will be freed.
            </param>
            <returns>Returns AVIERR_OK.</returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVISaveV(System.String,System.Guid@,Vanara.PInvoke.AviFil32.AVISAVECALLBACK,System.Int32,Vanara.PInvoke.AviFil32.IAVIStream[],System.IntPtr[])">
            <summary>The <c>AVISaveV</c> function builds a file by combining data streams from other files or from memory.</summary>
            <param name="szFile">Null-terminated string containing the name of the file to save.</param>
            <param name="pclsidHandler">
            Pointer to the file handler used to write the file. The file is created by calling the AVIFileOpen function using this handler.
            If a handler is not specified, a default is selected from the registry based on the file extension.
            </param>
            <param name="lpfnCallback">
            Pointer to a callback function used to display status information and to let the user cancel the save operation.
            </param>
            <param name="nStreams">Number of streams to save.</param>
            <param name="ppavi">
            Pointer to an array of pointers to the <c>AVISTREAM</c> function structures. The array uses one pointer for each stream.
            </param>
            <param name="plpOptions">
            Pointer to an array of pointers to AVICOMPRESSOPTIONS structures. The array uses one pointer for each stream.
            </param>
            <returns>Returns AVIERR_OK if successful or an error otherwise.</returns>
            <remarks>
            <para>
            This function is equivalent to the AVISave function except the streams are passed in an array instead of as a variable number of arguments.
            </para>
            <para>
            This function creates a file, copies stream data into the file, closes the file, and releases the resources used by the new
            file. The last two parameters of this function are arrays that identify the streams to save in the file and define the
            compression options of those streams.
            </para>
            <para>An application must allocate memory for the AVICOMPRESSOPTIONS structures and the array of pointers to these structures.</para>
            <para>The argument ppavi contains the address of a pointer to an IAVIStream interface.</para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines AVISaveV as an alias which automatically selects the ANSI or Unicode version of this function based on
            the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVISaveV(System.String,Vanara.InteropServices.GuidPtr,Vanara.PInvoke.AviFil32.AVISAVECALLBACK,System.Int32,Vanara.PInvoke.AviFil32.IAVIStream[],System.IntPtr[])">
            <summary>The <c>AVISaveV</c> function builds a file by combining data streams from other files or from memory.</summary>
            <param name="szFile">Null-terminated string containing the name of the file to save.</param>
            <param name="pclsidHandler">
            Pointer to the file handler used to write the file. The file is created by calling the AVIFileOpen function using this handler.
            If a handler is not specified, a default is selected from the registry based on the file extension.
            </param>
            <param name="lpfnCallback">
            Pointer to a callback function used to display status information and to let the user cancel the save operation.
            </param>
            <param name="nStreams">Number of streams to save.</param>
            <param name="ppavi">
            Pointer to an array of pointers to the <c>AVISTREAM</c> function structures. The array uses one pointer for each stream.
            </param>
            <param name="plpOptions">
            Pointer to an array of pointers to AVICOMPRESSOPTIONS structures. The array uses one pointer for each stream.
            </param>
            <returns>Returns AVIERR_OK if successful or an error otherwise.</returns>
            <remarks>
            <para>
            This function is equivalent to the AVISave function except the streams are passed in an array instead of as a variable number of arguments.
            </para>
            <para>
            This function creates a file, copies stream data into the file, closes the file, and releases the resources used by the new
            file. The last two parameters of this function are arrays that identify the streams to save in the file and define the
            compression options of those streams.
            </para>
            <para>An application must allocate memory for the AVICOMPRESSOPTIONS structures and the array of pointers to these structures.</para>
            <para>The argument ppavi contains the address of a pointer to an IAVIStream interface.</para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines AVISaveV as an alias which automatically selects the ANSI or Unicode version of this function based on
            the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVISaveV(System.String,System.Guid*,Vanara.PInvoke.AviFil32.AVISAVECALLBACK,System.Int32,Vanara.PInvoke.AviFil32.IAVIStream[],Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS**)">
            <summary>The <c>AVISaveV</c> function builds a file by combining data streams from other files or from memory.</summary>
            <param name="szFile">Null-terminated string containing the name of the file to save.</param>
            <param name="pclsidHandler">
            Pointer to the file handler used to write the file. The file is created by calling the AVIFileOpen function using this handler.
            If a handler is not specified, a default is selected from the registry based on the file extension.
            </param>
            <param name="lpfnCallback">
            Pointer to a callback function used to display status information and to let the user cancel the save operation.
            </param>
            <param name="nStreams">Number of streams to save.</param>
            <param name="ppavi">
            Pointer to an array of pointers to the <c>AVISTREAM</c> function structures. The array uses one pointer for each stream.
            </param>
            <param name="plpOptions">
            Pointer to an array of pointers to AVICOMPRESSOPTIONS structures. The array uses one pointer for each stream.
            </param>
            <returns>Returns AVIERR_OK if successful or an error otherwise.</returns>
            <remarks>
            <para>
            This function is equivalent to the AVISave function except the streams are passed in an array instead of as a variable number of arguments.
            </para>
            <para>
            This function creates a file, copies stream data into the file, closes the file, and releases the resources used by the new
            file. The last two parameters of this function are arrays that identify the streams to save in the file and define the
            compression options of those streams.
            </para>
            <para>An application must allocate memory for the AVICOMPRESSOPTIONS structures and the array of pointers to these structures.</para>
            <para>The argument ppavi contains the address of a pointer to an IAVIStream interface.</para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines AVISaveV as an alias which automatically selects the ANSI or Unicode version of this function based on
            the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamAddRef(Vanara.PInvoke.AviFil32.IAVIStream)">
            <summary>The <c>AVIStreamAddRef</c> function increments the reference count of an AVI stream.</summary>
            <param name="pavi">Handle to an open AVI stream.</param>
            <returns>Returns the current reference count of the stream. This value should be used only for debugging purposes.</returns>
            <remarks>The argument pavi contains a pointer to an IAVIStream interface.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamBeginStreaming(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32,System.Int32,System.Int32)">
            <summary>
            The <c>AVIStreamBeginStreaming</c> function specifies the parameters used in streaming and lets a stream handler prepare for streaming.
            </summary>
            <param name="pavi">Pointer to a stream.</param>
            <param name="lStart">Starting frame for streaming.</param>
            <param name="lEnd">Ending frame for streaming.</param>
            <param name="lRate">
            Speed at which the file is read relative to its natural speed. Specify 1000 for the normal speed. Values less than 1000 indicate
            a slower-than-normal speed; values greater than 1000 indicate a faster-than-normal speed.
            </param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>The argument pavi is a pointer to an IAVIStream interface.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamCreate(Vanara.PInvoke.AviFil32.IAVIStream@,System.Int32,System.Int32,System.Guid@)">
            <summary>The <c>AVIStreamCreate</c> function creates a stream not associated with any file.</summary>
            <param name="ppavi">Pointer to a buffer that receives the new stream interface.</param>
            <param name="lParam1">Stream-handler specific information.</param>
            <param name="lParam2">Stream-handler specific information.</param>
            <param name="pclsidHandler">Pointer to the class identifier used for the stream.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>
            You should not need to call this function. Some functions, such as CreateEditableStream and AVIMakeCompressedStream, use it internally.
            </para>
            <para>The argument ppavi contains the address of a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamCreate(Vanara.PInvoke.AviFil32.IAVIStream@,System.Int32,System.Int32,Vanara.InteropServices.GuidPtr)">
            <summary>The <c>AVIStreamCreate</c> function creates a stream not associated with any file.</summary>
            <param name="ppavi">Pointer to a buffer that receives the new stream interface.</param>
            <param name="lParam1">Stream-handler specific information.</param>
            <param name="lParam2">Stream-handler specific information.</param>
            <param name="pclsidHandler">Pointer to the class identifier used for the stream.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>
            You should not need to call this function. Some functions, such as CreateEditableStream and AVIMakeCompressedStream, use it internally.
            </para>
            <para>The argument ppavi contains the address of a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamDataSize(Vanara.PInvoke.AviFil32.IAVIStream,System.UInt32,System.Int32@)">
            <summary>
            The <c>AVIStreamDataSize</c> macro determines the buffer size, in bytes, needed to retrieve optional header data for a specified stream.
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="fcc">Four-character code specifying the stream type.</param>
            <param name="plSize">Address to contain the buffer size for the optional header data.</param>
            <returns>None</returns>
            <remarks>
            <para>The <c>AVIStreamDataSize</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamDataSize(pavi, fcc, plSize) \ AVIStreamReadData(pavi, fcc, NULL, plSize)</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamEnd(Vanara.PInvoke.AviFil32.IAVIStream)">
            <summary>The <c>AVIStreamEnd</c> macro calculates the sample associated with the end of a stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <returns>Returns the number if successful or -1 otherwise.</returns>
            <remarks>
            <para>
            The sample number returned is not a valid sample number for reading data. It represents the end of the file. (The end of the
            file is equal to the start of the file plus its length.)
            </para>
            <para>The <c>AVIStreamEnd</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamEnd(pavi) \ (AVIStreamStart(pavi) + AVIStreamLength(pavi))</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamEndStreaming(Vanara.PInvoke.AviFil32.IAVIStream)">
            <summary>The <c>AVIStreamEndStreaming</c> function ends streaming.</summary>
            <param name="pavi">Pointer to a stream.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>Many stream implementations ignore this function.</para>
            <para>The argument pavi contains a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamEndTime(Vanara.PInvoke.AviFil32.IAVIStream)">
            <summary>The <c>AVIStreamEndTime</c> macro returns the time representing the end of the stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <returns>Returns the converted time if successful or −1 otherwise.</returns>
            <remarks>
            <para>The <c>AVIStreamEndTime</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamEndTime(pavi) \ AVIStreamSampleToTime(pavi, AVIStreamEnd(pavi))</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamFindSample(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32,Vanara.PInvoke.AviFil32.FINDF)">
            <summary>
            <para>
            The <c>AVIStreamFindSample</c> function returns the position of a sample (key frame, nonempty frame, or a frame containing a
            format change) relative to the specified position.
            </para>
            <para>This function supersedes the obsolete <c>AVIStreamFindKeyFrame</c> function.</para>
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lPos">Starting frame for the search.</param>
            <param name="lFlags">
            <para>
            Flags that designate the type of frame to locate, the direction in the stream to search, and the type of return information. The
            following flags are defined.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>FIND_ANY</term>
            <term>Finds a nonempty frame. This flag supersedes the SEARCH_ANY flag.</term>
            </item>
            <item>
            <term>FIND_KEY</term>
            <term>Finds a key frame. This flag supersedes the SEARCH_KEY flag.</term>
            </item>
            <item>
            <term>FIND_FORMAT</term>
            <term>Finds a format change.</term>
            </item>
            <item>
            <term>FIND_NEXT</term>
            <term>
            Finds nearest sample, frame, or format change searching forward. The current sample is included in the search. Use this flag
            with the FIND_ANY, FIND_KEY, or FIND_FORMAT flag. This flag supersedes the SEARCH_FORWARD flag.
            </term>
            </item>
            <item>
            <term>FIND_PREV</term>
            <term>
            Finds nearest sample, frame, or format change searching backward. The current sample is included in the search. Use this flag
            with the FIND_ANY, FIND_KEY, or FIND_FORMAT flag. This flag supersedes the SEARCH_NEAREST and SEARCH_BACKWARD flags.
            </term>
            </item>
            <item>
            <term>FIND_FROM_START</term>
            <term>
            Finds first sample, frame, or format change beginning from the start of the stream. Use this flag with the FIND_ANY, FIND_KEY,
            or FIND_FORMAT flag.
            </term>
            </item>
            </list>
            </param>
            <returns>Returns the position of the frame found or -1 if the search is unsuccessful.</returns>
            <remarks>
            <para>The FIND_KEY, FIND_ANY, and FIND_FORMAT flags are mutually exclusive, as are the FIND_NEXT and FIND_PREV flags.</para>
            <para>The argument pavi contains a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamFormatSize(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32,System.Int32@)">
            <summary>
            The <c>AVIStreamFormatSize</c> macro determines the buffer size, in bytes, needed to store format information for a sample in a stream.
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lPos">Position of a sample in the stream.</param>
            <param name="plSize">Address to contain the buffer size.</param>
            <returns>None</returns>
            <remarks>
            <para>The <c>AVIStreamFormatSize</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamFormatSize(pavi, lPos, plSize) \ AVIStreamReadFormat(pavi, lPos, NULL, plSize)</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamGetFrame(Vanara.PInvoke.AviFil32.IGetFrame,System.Int32)">
            <summary>The <c>AVIStreamGetFrame</c> function returns the address of a decompressed video frame.</summary>
            <param name="pg">Pointer to the IGetFrame interface.</param>
            <param name="lPos">Position, in samples, within the stream of the desired frame.</param>
            <returns>
            Returns a pointer to the frame data if successful or <c>NULL</c> otherwise. The frame data is returned as a packed DIB.
            </returns>
            <remarks>The returned frame is valid only until the next call to this function or the AVIStreamGetFrameClose function.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamGetFrameClose(Vanara.PInvoke.AviFil32.IGetFrame)">
            <summary>The <c>AVIStreamGetFrameClose</c> function releases resources used to decompress video frames.</summary>
            <param name="pg">Handle returned from the AVIStreamGetFrameOpen function. After calling this function, the handle is invalid.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamGetFrameOpen(Vanara.PInvoke.AviFil32.IAVIStream,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@)">
            <summary>The <c>AVIStreamGetFrameOpen</c> function prepares to decompress video frames from the specified video stream.</summary>
            <param name="pavi">Pointer to the video stream used as the video source.</param>
            <param name="lpbiWanted">
            Pointer to a structure that defines the desired video format. Specify <c>NULL</c> to use a default format. You can also specify
            AVIGETFRAMEF_BESTDISPLAYFMT to decode the frames to the best format for your display.
            </param>
            <returns>
            <para>
            Returns a <c>GetFrame</c> object that can be used with the AVIStreamGetFrame function. If the system cannot find a decompressor
            that can decompress the stream to the given format, or to any RGB format, the function returns <c>NULL</c>.
            </para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamGetFrameOpen(Vanara.PInvoke.AviFil32.IAVIStream,System.IntPtr)">
            <summary>The <c>AVIStreamGetFrameOpen</c> function prepares to decompress video frames from the specified video stream.</summary>
            <param name="pavi">Pointer to the video stream used as the video source.</param>
            <param name="lpbiWanted">
            Pointer to a structure that defines the desired video format. Specify <c>NULL</c> to use a default format. You can also specify
            AVIGETFRAMEF_BESTDISPLAYFMT to decode the frames to the best format for your display.
            </param>
            <returns>
            <para>
            Returns a <c>GetFrame</c> object that can be used with the AVIStreamGetFrame function. If the system cannot find a decompressor
            that can decompress the stream to the given format, or to any RGB format, the function returns <c>NULL</c>.
            </para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamInfo(Vanara.PInvoke.AviFil32.IAVIStream,Vanara.PInvoke.AviFil32.AVISTREAMINFO@,System.Int32)">
            <summary>The <c>AVIStreamInfo</c> function obtains stream header information.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="psi">Pointer to a structure to contain the stream information.</param>
            <param name="lSize">Size, in bytes, of the structure used for psi.</param>
            <returns>
            <para>Returns zero if successful or an error otherwise.</para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            </returns>
            <remarks>
            <para>Note</para>
            <para>
            The vfw.h header defines AVISTREAMINFO as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamIsKeyFrame(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>The <c>AVIStreamIsKeyFrame</c> macro indicates whether a sample in a specified stream is a key frame.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lPos">Position to search in the stream.</param>
            <returns><see langword="true"/> if a sample in a specified stream is a key frame.</returns>
            <remarks>
            <para>The <c>AVIStreamIsKeyFrame</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamIsKeyFrame(pavi, lPos) \ (AVIStreamNearestKeyFrame(pavi, lPos) == 1)</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamLength(Vanara.PInvoke.AviFil32.IAVIStream)">
            <summary>The <c>AVIStreamLength</c> function returns the length of the stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <returns>
            <para>Returns the stream's length, in samples, if successful or -1 otherwise.</para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamLengthTime(Vanara.PInvoke.AviFil32.IAVIStream)">
            <summary>The <c>AVIStreamLengthTime</c> macro returns the length of a stream in time.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <returns>Returns the converted time if successful or −1 otherwise.</returns>
            <remarks>
            <para>The <c>AVIStreamLengthTime</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamLengthTime(pavi) \ AVIStreamSampleToTime(pavi, AVIStreamLength(pavi))</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamNearestKeyFrame(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>The <c>AVIStreamNearestKeyFrame</c> macro locates the key frame at or preceding a specified position in a stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lPos">Starting position to search in the stream.</param>
            <returns>Returns the position of the frame found or -1 if the search is unsuccessful.</returns>
            <remarks>
            <para>The <c>AVIStreamNearestKeyFrame</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamNearestKeyFrame(pavi, lPos) \ AVIStreamFindSample(pavi, lPos , FIND_PREV | FIND_KEY)</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamNearestKeyFrameTime(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>
            The <c>AVIStreamNearestKeyFrameTime</c> macro determines the time corresponding to the beginning of the key frame nearest (at or
            preceding) a specified time in a stream.
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lTime">Starting time, in milliseconds, to search in the stream.</param>
            <returns>Returns the converted time if successful or -1 otherwise.</returns>
            <remarks>
            <para>The <c>AVIStreamNearestKeyFrameTime</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamNearestKeyFrameTime(pavi, lTime) \ AVIStreamSampleToTime(pavi, AVIStreamNearestKeyFrame(pavi, AVIStreamTimeToSample(pavi, lTime)))</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamNearestSample(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>
            The <c>AVIStreamNearestSample</c> macro locates the nearest nonempty sample at or preceding a specified position in a stream.
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lPos">Starting position to search in the stream.</param>
            <returns>Returns the position of the frame found or -1 if the search is unsuccessful.</returns>
            <remarks>
            <para>The <c>AVIStreamNearestSample</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamNearestSample(pavi, lPos) \ AVIStreamFindSample(pavi, lPos, FIND_PREV | FIND_ANY)</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamNearestSampleTime(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>
            The <c>AVIStreamNearestSampleTime</c> macro determines the time corresponding to the beginning of a sample that is nearest to a
            specified time in a stream.
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lTime">Starting time, in milliseconds, to search in the stream.</param>
            <returns>Returns the converted time if successful or −1 otherwise.</returns>
            <remarks>
            <para>The <c>AVIStreamNearestSampleTime</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamNearestSampleTime(pavi, lTime) \ AVIStreamSampleToTime(pavi, AVIStreamNearestSample(pavi, AVIStreamTimeToSample(pavi, lTime)))</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamNextKeyFrame(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>The <c>AVIStreamNextKeyFrame</c> macro locates the next key frame following a specified position in a stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lPos">Starting position to search in the stream.</param>
            <returns>Returns the position of the frame found or -1 if the search is unsuccessful.</returns>
            <remarks>
            <para>The search performed by this macro does not include the frame at the specified position.</para>
            <para>The <c>AVIStreamNextKeyFrame</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamNextKeyFrame(pavi, lPos) \ AVIStreamFindSample(pavi, lPos + 1, FIND_NEXT | FIND_KEY)</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamNextKeyFrameTime(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>
            The <c>AVIStreamNextKeyFrameTime</c> macro returns the time of the next key frame in the stream, starting at a given time.
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="t">Position in the stream to begin searching.</param>
            <returns>Returns the converted time if successful or −1 otherwise.</returns>
            <remarks>
            <para>The search performed by this macro includes the frame that corresponds to the specified time.</para>
            <para>The <c>AVIStreamNextKeyFrameTime</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamNextKeyFrameTime(pavi, time) \ AVIStreamSampleToTime(pavi, \ AVIStreamNextKeyFrame(pavi, \ AVIStreamTimeToSample(pavi, time)))</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamNextSample(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>The <c>AVIStreamNextSample</c> macro locates the next nonempty sample from a specified position in a stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="l">Starting position to search in the stream.</param>
            <returns>Returns the position of the frame found or -1 if the search is unsuccessful.</returns>
            <remarks>
            <para>The sample position returned does not include the sample specified by lPos.</para>
            <para>The <c>AVIStreamNextSample</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamNextSample(pavi, lPos) \ AVIStreamFindSample(pavi, lPos + 1, FIND_NEXT | FIND_ANY)</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamNextSampleTime(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>
            The <c>AVIStreamNextSampleTime</c> macro returns the time that a sample changes to the next sample in the stream. This macro
            finds the next interesting time in a stream.
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="t">Position information of the sample in the stream.</param>
            <returns>Returns the converted time if successful or −1 otherwise.</returns>
            <remarks>
            <para>The <c>AVIStreamNextSampleTime</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamNextSampleTime(pavi, time) \ AVIStreamSampleToTime(pavi, \ AVIStreamNextSample(pavi, \ AVIStreamTimeToSample(pavi, t)))</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamOpenFromFile(Vanara.PInvoke.AviFil32.IAVIStream@,System.String,System.UInt32,System.Int32,Vanara.PInvoke.Kernel32.OpenFileAction,System.Guid@)">
            <summary>The <c>AVIStreamOpenFromFile</c> function opens a single stream from a file.</summary>
            <param name="ppavi">Pointer to a buffer that receives the new stream handle.</param>
            <param name="szFile">Null-terminated string containing the name of the file to open.</param>
            <param name="fccType">
            <para>
            Four-character code indicating the type of stream to be opened. Zero indicates that any stream can be opened. The following
            definitions apply to the data commonly found in AVI streams:
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>streamtypeAUDIO</term>
            <term>Indicates an audio stream.</term>
            </item>
            <item>
            <term>streamtypeMIDI</term>
            <term>Indicates a MIDI stream.</term>
            </item>
            <item>
            <term>streamtypeTEXT</term>
            <term>Indicates a text stream.</term>
            </item>
            <item>
            <term>streamtypeVIDEO</term>
            <term>Indicates a video stream.</term>
            </item>
            </list>
            </param>
            <param name="lParam">
            Stream of the type specified in fccType to access. This parameter is zero-based; use zero to specify the first occurrence.
            </param>
            <param name="mode">
            Access mode to use when opening the file. This function can open only existing streams, so the OF_CREATE mode flag cannot be
            used. For more information about the available flags for the mode parameter, see the <c>OpenFile</c> function.
            </param>
            <param name="pclsidHandler">
            Pointer to a class identifier of the handler you want to use. If the value is <c>NULL</c>, the system chooses one from the
            registry based on the file extension or the file RIFF type.
            </param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>This function calls the AVIFileOpen, AVIFileGetStream, and AVIFileRelease functions.</para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines AVIStreamOpenFromFile as an alias which automatically selects the ANSI or Unicode version of this
            function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that
            not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions
            for Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamOpenFromFile(Vanara.PInvoke.AviFil32.IAVIStream@,System.String,System.UInt32,System.Int32,Vanara.PInvoke.Kernel32.OpenFileAction,Vanara.InteropServices.GuidPtr)">
            <summary>The <c>AVIStreamOpenFromFile</c> function opens a single stream from a file.</summary>
            <param name="ppavi">Pointer to a buffer that receives the new stream handle.</param>
            <param name="szFile">Null-terminated string containing the name of the file to open.</param>
            <param name="fccType">
            <para>
            Four-character code indicating the type of stream to be opened. Zero indicates that any stream can be opened. The following
            definitions apply to the data commonly found in AVI streams:
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>streamtypeAUDIO</term>
            <term>Indicates an audio stream.</term>
            </item>
            <item>
            <term>streamtypeMIDI</term>
            <term>Indicates a MIDI stream.</term>
            </item>
            <item>
            <term>streamtypeTEXT</term>
            <term>Indicates a text stream.</term>
            </item>
            <item>
            <term>streamtypeVIDEO</term>
            <term>Indicates a video stream.</term>
            </item>
            </list>
            </param>
            <param name="lParam">
            Stream of the type specified in fccType to access. This parameter is zero-based; use zero to specify the first occurrence.
            </param>
            <param name="mode">
            Access mode to use when opening the file. This function can open only existing streams, so the OF_CREATE mode flag cannot be
            used. For more information about the available flags for the mode parameter, see the <c>OpenFile</c> function.
            </param>
            <param name="pclsidHandler">
            Pointer to a class identifier of the handler you want to use. If the value is <c>NULL</c>, the system chooses one from the
            registry based on the file extension or the file RIFF type.
            </param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>This function calls the AVIFileOpen, AVIFileGetStream, and AVIFileRelease functions.</para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines AVIStreamOpenFromFile as an alias which automatically selects the ANSI or Unicode version of this
            function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that
            not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions
            for Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamPrevKeyFrame(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>The <c>AVIStreamPrevKeyFrame</c> macro locates the key frame that precedes a specified position in a stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="l">Starting position to search in the stream.</param>
            <returns>Returns the position of the frame found or -1 if the search is unsuccessful.</returns>
            <remarks>
            <para>The search performed by this macro does not include the frame at the specified position.</para>
            <para>The <c>AVIStreamPrevKeyFrame</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamPrevKeyFrame(pavi, lPos) \ AVIStreamFindSample(pavi, lPos - 1, FIND_PREV | FIND_KEY)</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamPrevKeyFrameTime(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>
            The <c>AVIStreamPrevKeyFrameTime</c> macro returns the time of the previous key frame in the stream, starting at a given time.
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="t">Position in the stream to begin searching.</param>
            <returns>Returns the converted time if successful or −1 otherwise.</returns>
            <remarks>
            <para>The search performed by this macro includes the frame that corresponds to the specified time.</para>
            <para>The <c>AVIStreamPrevKeyFrameTime</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamPrevKeyFrameTime(pavi, time) \ AVIStreamSampleToTime(pavi, AVIStreamPrevKeyFrame(pavi, AVIStreamTimeToSample(pavi, time)))</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamPrevSample(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>
            The <c>AVIStreamPrevSample</c> macro locates the nearest nonempty sample that precedes a specified position in a stream.
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="l">Starting position to search in the stream.</param>
            <returns>None</returns>
            <remarks>
            <para>The sample position returned does not include the sample specified by lPos.</para>
            <para>The <c>AVIStreamPrevSample</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamPrevSample(pavi, lPos) \ AVIStreamFindSample(pavi, lPos - 1, FIND_PREV | FIND_ANY)</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamPrevSampleTime(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>
            The <c>AVIStreamPrevSampleTime</c> macro determines the time of the nearest nonempty sample that precedes a specified time in a stream.
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="t">Position information of the sample in the stream.</param>
            <returns>None</returns>
            <remarks>
            <para>The <c>AVIStreamPrevSampleTime</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamPrevSampleTime(pavi, time) \ AVIStreamSampleToTime(pavi, \ AVIStreamPrevSample(pavi, \ AVIStreamTimeToSample(pavi, t)))</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamRead(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32@,System.Int32@)">
            <summary>The <c>AVIStreamRead</c> function reads audio, video or other data from a stream according to the stream type.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lStart">First sample to read.</param>
            <param name="lSamples">
            Number of samples to read. You can also specify the value AVISTREAMREAD_CONVENIENT to let the stream handler determine the
            number of samples to read.
            </param>
            <param name="lpBuffer">Pointer to a buffer to contain the data.</param>
            <param name="cbBuffer">Size, in bytes, of the buffer pointed to by lpBuffer.</param>
            <param name="plBytes">
            Pointer to a buffer that receives the number of bytes of data written in the buffer referenced by lpBuffer. This value can be <c>NULL</c>.
            </param>
            <param name="plSamples">
            Pointer to a buffer that receives the number of samples written in the buffer referenced by lpBuffer. This value can be <c>NULL</c>.
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise. Possible error values include the following.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AVIERR_BUFFERTOOSMALL</term>
            <term>The buffer size cbBuffer was smaller than a single sample of data.</term>
            </item>
            <item>
            <term>AVIERR_MEMORY</term>
            <term>There was not enough memory to complete the read operation.</term>
            </item>
            <item>
            <term>AVIERR_FILEREAD</term>
            <term>A disk error occurred while reading the file.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            If lpBuffer is <c>NULL</c>, this function does not read any data; it returns information about the size of data that would be read.
            </para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamReadData(Vanara.PInvoke.AviFil32.IAVIStream,System.UInt32,System.IntPtr,System.Int32@)">
            <summary>The <c>AVIStreamReadData</c> function reads optional header data from a stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="fcc">Four-character code identifying the data.</param>
            <param name="lp">Pointer to the buffer to contain the optional header data.</param>
            <param name="lpcb">
            Pointer to the location that specifies the buffer size used for lpData. If the read is successful, AVIFile changes this value to
            indicate the amount of data written into the buffer for lpData.
            </param>
            <returns>
            Returns zero if successful or an error otherwise. The return value AVIERR_NODATA indicates the system could not find any data
            with the specified chunk identifier.
            </returns>
            <remarks>
            <para>
            This function retrieves only optional header information from the stream. This information is custom and does not have a set format.
            </para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamReadFormat(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32,System.IntPtr,System.Int32@)">
            <summary>The <c>AVIStreamReadFormat</c> function reads the stream format data.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lPos">Position in the stream used to obtain the format data.</param>
            <param name="lpFormat">Pointer to a buffer to contain the format data.</param>
            <param name="lpcbFormat">
            Pointer to a location indicating the size of the memory block referenced by lpFormat. On return, the value is changed to
            indicate the amount of data read. If lpFormat is <c>NULL</c>, this parameter can be used to obtain the amount of memory needed
            to return the format.
            </param>
            <returns>
            <para>Returns zero if successful or an error otherwise.</para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            </returns>
            <remarks>
            Standard video stream handlers provide format information in a BITMAPINFOHEADER structure. Standard audio stream handlers
            provide format information in a PCMWAVEFORMAT structure. Other data streams can use other structures that describe the stream data.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamRelease(Vanara.PInvoke.AviFil32.IAVIStream)">
            <summary>
            <para>
            The <c>AVIStreamRelease</c> function decrements the reference count of an AVI stream interface handle, and closes the stream if
            the count reaches zero.
            </para>
            <para>This function supersedes the obsolete <c>AVIStreamClose</c> function.</para>
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <returns>
            <para>Returns the current reference count of the stream. This value should be used only for debugging purposes.</para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamSampleSize(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32,System.Int32@)">
            <summary>
            The AVIStreamRelease macro determines the size of the buffer needed to store one sample of information from a stream. The size
            corresponds to the sample at the position specified by lPos.
            </summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lPos">Position of a sample in the stream.</param>
            <param name="plSize">Address to contain the buffer size.</param>
            <returns>None</returns>
            <remarks>
            <para>The <c>AVIStreamSampleSize</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamSampleSize(pavi, lPos, plSize) \ AVIStreamRead(pavi, lPos, 1, NULL, 0, plSize, NULL)</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamSampleToSample(Vanara.PInvoke.AviFil32.IAVIStream,Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>
            The <c>AVIStreamSampleToSample</c> macro returns the sample in a stream that occurs at the same time as a sample that occurs in
            a second stream.
            </summary>
            <param name="pavi1">Handle to an open stream that contains the sample that is returned.</param>
            <param name="pavi2">Handle to a second stream that contains the reference sample.</param>
            <param name="l">Position information of the sample in the stream referenced by pavi2.</param>
            <returns>Returns the converted time if successful or -1 otherwise.</returns>
            <remarks>
            <para>The <c>AVIStreamSampleToSample</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamSampleToSample(pavi1, pavi2, lsample) \ AVIStreamTimeToSample(pavi1, AVIStreamSampleToTime \ (pavi2, lsample))</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamSampleToTime(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>The <c>AVIStreamSampleToTime</c> function converts a stream position from samples to milliseconds.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lSample">
            Position information. A sample can correspond to blocks of audio, a video frame, or other format, depending on the stream type.
            </param>
            <returns>Returns the converted time if successful or −1 otherwise.</returns>
            <remarks>The argument pavi is a pointer to an IAVIStream interface.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamSetFormat(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32,System.IntPtr,System.Int32)">
            <summary>The <c>AVIStreamSetFormat</c> function sets the format of a stream at the specified position.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lPos">Position in the stream to receive the format.</param>
            <param name="lpFormat">Pointer to a structure containing the new format.</param>
            <param name="cbFormat">Size, in bytes, of the block of memory referenced by lpFormat.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>
            The handler for writing AVI files does not accept format changes. Besides setting the initial format for a stream, only changes
            in the palette of a video stream are allowed in an AVI file. The palette change must occur after any frames already written to
            the AVI file. Other handlers might impose different restrictions.
            </para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamStart(Vanara.PInvoke.AviFil32.IAVIStream)">
            <summary>The <c>AVIStreamStart</c> function returns the starting sample number for the stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <returns>Returns the number if successful or -1 otherwise.</returns>
            <remarks>The argument pavi is a pointer to an IAVIStream interface.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamStartTime(Vanara.PInvoke.AviFil32.IAVIStream)">
            <summary>The <c>AVIStreamStartTime</c> macro returns the starting time of a stream's first sample.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <returns>None</returns>
            <remarks>
            <para>The <c>AVIStreamStartTime</c> macro is defined as follows:</para>
            <para>
            <code> #define AVIStreamStartTime(pavi) \ AVIStreamSampleToTime(pavi, AVIStreamStart(pavi))</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamTimeToSample(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32)">
            <summary>The <c>AVIStreamTimeToSample</c> function converts from milliseconds to samples.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lTime">Time, expressed in milliseconds.</param>
            <returns>Returns the converted time if successful or -1 otherwise.</returns>
            <remarks>
            <para>
            Samples typically correspond to audio samples or video frames. Other stream types might support different formats than these.
            </para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamWrite(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32,System.Int32,System.IntPtr,System.Int32,Vanara.PInvoke.AviFil32.AVIIF,System.Int32@,System.Int32@)">
            <summary>The <c>AVIStreamWrite</c> function writes data to a stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lStart">First sample to write.</param>
            <param name="lSamples">Number of samples to write.</param>
            <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
            <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
            <param name="dwFlags">
            <para>Flag associated with this data. The following flag is defined:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AVIIF_KEYFRAME</term>
            <term>Indicates this data does not rely on preceding data in the file.</term>
            </item>
            </list>
            </param>
            <param name="plSampWritten">Pointer to a buffer that receives the number of samples written. This can be set to <c>NULL</c>.</param>
            <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written. This can be set to <c>NULL</c>.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>The default AVI file handler supports writing only at the end of a stream. The "WAVE" file handler supports writing anywhere.</para>
            <para>This function overwrites existing data, rather than inserting new data.</para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.AVIStreamWriteData(Vanara.PInvoke.AviFil32.IAVIStream,System.UInt32,System.IntPtr,System.Int32)">
            <summary>The <c>AVIStreamWriteData</c> function writes optional header information to the stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="fcc">Four-character code identifying the data.</param>
            <param name="lp">Pointer to a buffer containing the data to write.</param>
            <param name="cb">Number of bytes of data to write into the stream.</param>
            <returns>
            Returns zero if successful or an error otherwise. The return value AVIERR_READONLY indicates the file was opened without write access.
            </returns>
            <remarks>
            <para>
            Use the AVIStreamWrite function to write the multimedia content of the stream. Use AVIFileWriteData to write data that applies
            to an entire file.
            </para>
            <para>The argument pavi is a pointer to an IAVIStream interface.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.aviTWOCC(System.Char,System.Char)">
            <summary>Macro to make a TWOCC out of two characters</summary>
            <param name="ch0">The first character.</param>
            <param name="ch1">The second character.</param>
            <returns>A <see cref="T:System.UInt16"/> TWOCC value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.CreateEditableStream(Vanara.PInvoke.AviFil32.IAVIStream@,Vanara.PInvoke.AviFil32.IAVIStream)">
            <summary>
            The <c>CreateEditableStream</c> function creates an editable stream. Use this function before using other stream editing functions.
            </summary>
            <param name="ppsEditable">Pointer to a buffer that receives the new stream handle.</param>
            <param name="psSource">
            Handle to the stream supplying data for the new stream. Specify <c>NULL</c> to create an empty editable string that you can copy
            and paste data into.
            </param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>The stream pointer returned in ppsEditable must be used as the source stream in the other stream editing functions.</para>
            <para>
            Internally, this function creates tables to keep track of changes to a stream. The original stream is never changed by the
            stream editing functions. The stream pointer created by this function can be used in any AVIFile function that accepts stream
            pointers. You can use this function on the same stream multiple times. A copy of a stream is not affected by changes in another copy.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.EditStreamClone(Vanara.PInvoke.AviFil32.IAVIStream,Vanara.PInvoke.AviFil32.IAVIStream@)">
            <summary>The <c>EditStreamClone</c> function creates a duplicate editable stream.</summary>
            <param name="pavi">Handle to an editable stream that will be copied.</param>
            <param name="ppResult">Pointer to a buffer that receives the new stream handle.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>
            The editable stream that is being cloned must have been created by the <c>CreateEditableStream</c> function or one of the stream
            editing functions.
            </para>
            <para>The new stream can be treated as any other AVI stream.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.EditStreamCopy(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32@,System.Int32@,Vanara.PInvoke.AviFil32.IAVIStream@)">
            <summary>The <c>EditStreamCopy</c> function copies an editable stream (or a portion of it) into a temporary stream.</summary>
            <param name="pavi">Handle to the stream being copied.</param>
            <param name="plStart">Starting position within the stream being copied. The starting position is returned.</param>
            <param name="plLength">Amount of data to copy from the stream referenced by pavi. The length of the copied data is returned.</param>
            <param name="ppResult">Pointer to a buffer that receives the handle created for the new stream.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>The stream that is copied must be created by the <c>CreateEditableStream</c> function or one of the stream editing functions.</para>
            <para>The temporary stream can be treated as any other AVI stream.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.EditStreamCut(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32@,System.Int32@,Vanara.PInvoke.AviFil32.IAVIStream@)">
            <summary>
            The <c>EditStreamCut</c> function deletes all or part of an editable stream and creates a temporary editable stream from the
            deleted portion of the stream.
            </summary>
            <param name="pavi">Handle to the stream being edited.</param>
            <param name="plStart">Starting position of the data to cut from the stream referenced by pavi.</param>
            <param name="plLength">Amount of data to cut from the stream referenced by pavi.</param>
            <param name="ppResult">Pointer to the handle created for the new stream.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>
            The stream being edited must have been created by the <c>CreateEditableStream</c> function or one of the stream editing functions.
            </para>
            <para>
            The temporary stream is an editable stream and can be treated as any other AVI stream. An application must release the temporary
            stream to free the resources associated with it.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.EditStreamPaste(Vanara.PInvoke.AviFil32.IAVIStream,System.Int32@,System.Int32@,Vanara.PInvoke.AviFil32.IAVIStream,System.Int32,System.Int32)">
            <summary>
            The <c>EditStreamPaste</c> function copies a stream (or a portion of it) from one stream and pastes it within another stream at
            a specified location.
            </summary>
            <param name="pavi">Handle to an editable stream that will receive the copied stream data.</param>
            <param name="plPos">Starting position to paste the data within the destination stream (referenced by pavi).</param>
            <param name="plLength">Pointer to a buffer that receives the amount of data pasted in the stream.</param>
            <param name="pstream">Handle to a stream supplying the data to paste. This stream does not need to be an editable stream.</param>
            <param name="lStart">Starting position of the data to copy within the source stream.</param>
            <param name="lEnd">
            Amount of data to copy from the source stream. If lLength is -1, the entire stream referenced by pstream is pasted in the other stream.
            </param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>
            The stream referenced by pavi must have been created by the <c>CreateEditableStream</c> function or one of the stream editing functions.
            </para>
            <para>
            This function inserts data into the specified stream as a continuous block of data. It opens the specified data stream at the
            insertion point, pastes the specified stream segment at the insertion point, and appends the stream segment that trails the
            insertion point to the end of pasted segment.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.EditStreamSetInfo(Vanara.PInvoke.AviFil32.IAVIStream,Vanara.PInvoke.AviFil32.AVISTREAMINFO@,System.Int32)">
            <summary>The <c>EditStreamSetInfo</c> function changes characteristics of an editable stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lpInfo">Pointer to an AVISTREAMINFO structure containing new information.</param>
            <param name="cbInfo">Size, in bytes, of the structure pointed to by lpInfo.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>
            You must supply information for the entire AVISTREAMINFO structure, including the members you will not use. You can use the
            AVIStreamInfo function to initialize the structure and then update selected members with your data.
            </para>
            <para>This function does not change the following members:</para>
            <list type="bullet">
            <item>
            <term><c>dwCaps</c></term>
            </item>
            <item>
            <term><c>dwEditCount</c></term>
            </item>
            <item>
            <term><c>dwFlags</c></term>
            </item>
            <item>
            <term><c>dwInitialFrames</c></term>
            </item>
            <item>
            <term><c>dwLength</c></term>
            </item>
            <item>
            <term><c>dwSampleSize</c></term>
            </item>
            <item>
            <term><c>dwSuggestedBufferSize</c></term>
            </item>
            <item>
            <term><c>fccHandler</c></term>
            </item>
            <item>
            <term><c>fccType</c></term>
            </item>
            </list>
            <para>The function changes the following members:</para>
            <list type="bullet">
            <item>
            <term><c>dwRate</c></term>
            </item>
            <item>
            <term><c>dwQuality</c></term>
            </item>
            <item>
            <term><c>dwScale</c></term>
            </item>
            <item>
            <term><c>dwStart</c></term>
            </item>
            <item>
            <term><c>rcFrame</c></term>
            </item>
            <item>
            <term><c>szName</c></term>
            </item>
            <item>
            <term><c>wLanguage</c></term>
            </item>
            <item>
            <term><c>wPriority</c></term>
            </item>
            </list>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines EditStreamSetInfo as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.EditStreamSetName(Vanara.PInvoke.AviFil32.IAVIStream,System.String)">
            <summary>The <c>EditStreamSetName</c> function assigns a descriptive string to a stream.</summary>
            <param name="pavi">Handle to an open stream.</param>
            <param name="lpszName">Null-terminated string containing the description of the stream.</param>
            <returns>Returns zero if successful or an error otherwise.</returns>
            <remarks>
            <para>This function updates the <c>szName</c> member of the <c>AVISTREAMINFO</c> structure.</para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines EditStreamSetName as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS">
            <summary>
            The <c>AVICOMPRESSOPTIONS</c> structure contains information about a stream and how it is compressed and saved. This structure
            passes data to the AVIMakeCompressedStream function (or the AVISave function, which uses <c>AVIMakeCompressedStream</c>).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS.fccType">
            <summary>
            <para>
            Four-character code indicating the stream type. The following constants have been defined for the data commonly found in AVI streams:
            </para>
            <list type="table">
            <listheader>
            <term>Constant</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>streamtypeAUDIO</term>
            <term>Indicates an audio stream.</term>
            </item>
            <item>
            <term>streamtypeMIDI</term>
            <term>Indicates a MIDI stream.</term>
            </item>
            <item>
            <term>streamtypeTEXT</term>
            <term>Indicates a text stream.</term>
            </item>
            <item>
            <term>streamtypeVIDEO</term>
            <term>Indicates a video stream.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS.fccHandler">
            <summary>
            Four-character code for the compressor handler that will compress this video stream when it is saved (for example,
            mmioFOURCC ('M','S','V','C')). This member is not used for audio streams.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS.dwKeyFrameEvery">
            <summary>
            Maximum period between video key frames. This member is used only if the AVICOMPRESSF_KEYFRAMES flag is set; otherwise every
            video frame is a key frame.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS.dwQuality">
            <summary>Quality value passed to a video compressor. This member is not used for an audio compressor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS.dwBytesPerSecond">
            <summary>Video compressor data rate. This member is used only if the AVICOMPRESSF_DATARATE flag is set.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS.dwFlags">
            <summary>
            <para>Flags used for compression. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AVICOMPRESSF_DATARATE</term>
            <term>Compresses this video stream using the data rate specified in dwBytesPerSecond.</term>
            </item>
            <item>
            <term>AVICOMPRESSF_INTERLEAVE</term>
            <term>Interleaves this stream every dwInterleaveEvery frames with respect to the first stream.</term>
            </item>
            <item>
            <term>AVICOMPRESSF_KEYFRAMES</term>
            <term>
            Saves this video stream with key frames at least every dwKeyFrameEvery frames. By default, every frame will be a key frame.
            </term>
            </item>
            <item>
            <term>AVICOMPRESSF_VALID</term>
            <term>
            Uses the data in this structure to set the default compression values for AVISaveOptions. If an empty structure is passed
            and this flag is not set, some defaults will be chosen.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS.lpFormat">
            <summary>Pointer to a structure defining the data format. For an audio stream, this is an <c>LPWAVEFORMAT</c> structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS.cbFormat">
            <summary>Size, in bytes, of the data referenced by <c>lpFormat</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS.lpParms">
            <summary>Video-compressor-specific data; used internally.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS.cbParms">
            <summary>Size, in bytes, of the data referenced by <c>lpParms</c></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVICOMPRESSOPTIONS.dwInterleaveEvery">
            <summary>
            Interleave factor for interspersing stream data with data from the first stream. Used only if the AVICOMPRESSF_INTERLEAVE
            flag is set.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.AVIFILEINFO">
            <summary>The <c>AVIFILEINFO</c> structure contains global information for an entire AVI file.</summary>
            <remarks>
            <para>Note</para>
            <para>
            The vfw.h header defines AVIFILEINFO as an alias which automatically selects the ANSI or Unicode version of this function based
            on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFO.dwMaxBytesPerSec">
            <summary>Approximate maximum data rate of the AVI file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFO.dwFlags">
            <summary>
            <para>A bitwise <c>OR</c> of zero or more flags. The following flags are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AVIFILEINFO_HASINDEX</term>
            <term>The AVI file has an index at the end of the file. For good performance, all AVI files should contain an index.</term>
            </item>
            <item>
            <term>AVIFILEINFO_MUSTUSEINDEX</term>
            <term>
            The file index contains the playback order for the chunks in the file. Use the index rather than the physical ordering of
            the chunks when playing back the data. This could be used for creating a list of frames for editing.
            </term>
            </item>
            <item>
            <term>AVIFILEINFO_ISINTERLEAVED</term>
            <term>The AVI file is interleaved.</term>
            </item>
            <item>
            <term>AVIFILEINFO_WASCAPTUREFILE</term>
            <term>
            The AVI file is a specially allocated file used for capturing real-time video. Applications should warn the user before
            writing over a file with this flag set because the user probably defragmented this file.
            </term>
            </item>
            <item>
            <term>AVIFILEINFO_COPYRIGHTED</term>
            <term>
            The AVI file contains copyrighted data and software. When this flag is used, software should not permit the data to be duplicated.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFO.dwCaps">
            <summary>
            <para>Capability flags. The following flags are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AVIFILECAPS_CANREAD</term>
            <term>An application can open the AVI file with the read privilege.</term>
            </item>
            <item>
            <term>AVIFILECAPS_CANWRITE</term>
            <term>An application can open the AVI file with the write privilege.</term>
            </item>
            <item>
            <term>AVIFILECAPS_ALLKEYFRAMES</term>
            <term>Every frame in the AVI file is a key frame.</term>
            </item>
            <item>
            <term>AVIFILECAPS_NOCOMPRESSION</term>
            <term>The AVI file does not use a compression method.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFO.dwStreams">
            <summary>Number of streams in the file. For example, a file with audio and video has at least two streams.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFO.dwSuggestedBufferSize">
            <summary>
            <para>
            Suggested buffer size, in bytes, for reading the file. Generally, this size should be large enough to contain the largest
            chunk in the file. For an interleaved file, this size should be large enough to read an entire record, not just a chunk.
            </para>
            <para>
            If the buffer size is too small or is set to zero, the playback software will have to reallocate memory during playback,
            reducing performance.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFO.dwWidth">
            <summary>Width, in pixels, of the AVI file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFO.dwHeight">
            <summary>Height, in pixels, of the AVI file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFO.dwScale">
            <summary>
            <para>
            Time scale applicable for the entire file. Dividing <c>dwRate</c> by <c>dwScale</c> gives the number of samples per second.
            </para>
            <para>Any stream can define its own time scale to supersede the file time scale.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFO.dwRate">
            <summary>Rate in an integer format. To obtain the rate in samples per second, divide this value by the value in <c>dwScale</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFO.dwLength">
            <summary>Length of the AVI file. The units are defined by <c>dwRate</c> and <c>dwScale</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFO.dwEditCount">
            <summary>Number of streams that have been added to or deleted from the AVI file.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVIFILEINFO.szFileType">
            <summary>Null-terminated string containing descriptive information for the file type.</summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.AVISTREAMINFO">
            <summary>The <c>AVISTREAMINFO</c> structure contains information for a single stream.</summary>
            <remarks>
            <para>Note</para>
            <para>
            The vfw.h header defines AVISTREAMINFO as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.fccType">
            <summary>
            <para>
            Four-character code indicating the stream type. The following constants have been defined for the data commonly found in AVI streams:
            </para>
            <list type="table">
            <listheader>
            <term>Constant</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>streamtypeAUDIO</term>
            <term>Indicates an audio stream.</term>
            </item>
            <item>
            <term>streamtypeMIDI</term>
            <term>Indicates a MIDI stream.</term>
            </item>
            <item>
            <term>streamtypeTEXT</term>
            <term>Indicates a text stream.</term>
            </item>
            <item>
            <term>streamtypeVIDEO</term>
            <term>Indicates a video stream.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.fccHandler">
            <summary>
            Four-character code of the compressor handler that will compress this video stream when it is saved (for example, mmioFOURCC
            ('M','S','V','C')). This member is not used for audio streams.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.dwFlags">
            <summary>
            <para>
            Applicable flags for the stream. The bits in the high-order word of these flags are specific to the type of data contained
            in the stream. The following flags are defined:
            </para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AVISTREAMINFO_DISABLED</term>
            <term>Indicates this stream should be rendered when explicitly enabled by the user.</term>
            </item>
            <item>
            <term>AVISTREAMINFO_FORMATCHANGES</term>
            <term>
            Indicates this video stream contains palette changes. This flag warns the playback software that it will need to animate the palette.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.dwCaps">
            <summary>Capability flags; currently unused.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.wPriority">
            <summary>Priority of the stream.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.wLanguage">
            <summary>Language of the stream.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.dwScale">
            <summary>
            <para>
            Time scale applicable for the stream. Dividing <c>dwRate</c> by <c>dwScale</c> gives the playback rate in number of samples
            per second.
            </para>
            <para>
            For video streams, this rate should be the frame rate. For audio streams, this rate should correspond to the audio block
            size (the <c>nBlockAlign</c> member of the WAVEFORMAT or PCMWAVEFORMAT structure), which for PCM (Pulse Code Modulation)
            audio reduces to the sample rate.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.dwRate">
            <summary>Rate in an integer format. To obtain the rate in samples per second, divide this value by the value in <c>dwScale</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.dwStart">
            <summary>
            <para>
            Sample number of the first frame of the AVI file. The units are defined by dwRate and <c>dwScale</c>. Normally, this is
            zero, but it can specify a delay time for a stream that does not start concurrently with the file.
            </para>
            <para>The 1.0 release of the AVI tools does not support a nonzero starting time.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.dwLength">
            <summary>Length of this stream. The units are defined by <c>dwRate</c> and <c>dwScale</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.dwInitialFrames">
            <summary>
            Audio skew. This member specifies how much to skew the audio data ahead of the video frames in interleaved files. Typically,
            this is about 0.75 seconds.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.dwSuggestedBufferSize">
            <summary>
            Recommended buffer size, in bytes, for the stream. Typically, this member contains a value corresponding to the largest
            chunk in the stream. Using the correct buffer size makes playback more efficient. Use zero if you do not know the correct
            buffer size.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.dwQuality">
            <summary>
            Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000. For compressed
            data, this typically represents the value of the quality parameter passed to the compression software. If set to –1, drivers
            use the default quality value.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.dwSampleSize">
            <summary>
            <para>
            Size, in bytes, of a single data sample. If the value of this member is zero, the samples can vary in size and each data
            sample (such as a video frame) must be in a separate chunk. A nonzero value indicates that multiple samples of data can be
            grouped into a single chunk within the file.
            </para>
            <para>
            For video streams, this number is typically zero, although it can be nonzero if all video frames are the same size. For
            audio streams, this number should be the same as the <c>nBlockAlign</c> member of the WAVEFORMAT or WAVEFORMATEX structure
            describing the audio.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.rcFrame">
            <summary>
            Dimensions of the video destination rectangle. The values represent the coordinates of upper left corner, the height, and
            the width of the rectangle.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.dwEditCount">
            <summary>Number of times the stream has been edited. The stream handler maintains this count.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.dwFormatChangeCount">
            <summary>Number of times the stream format has changed. The stream handler maintains this count.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.AVISTREAMINFO.szName">
            <summary>Null-terminated string containing a description of the stream.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.ckidAVIMAINHDR">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.ckidAVINEWINDEX">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.ckidAVIPADDING">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.ckidSTREAMFORMAT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.ckidSTREAMHANDLERDATA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.ckidSTREAMHEADER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.ckidSTREAMNAME">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.cktypeDIBbits">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.cktypeDIBcompressed">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.cktypePALchange">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.cktypeWAVEbytes">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.formtypeAVI">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.listtypeAVIHEADER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.listtypeAVIMOVIE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.listtypeAVIRECORD">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.listtypeSTREAMHEADER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.streamtypeAUDIO">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.streamtypeMIDI">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.streamtypeTEXT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.streamtypeVIDEO">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.VHDR">
            <summary>Flags for <c>VIDEOHDR</c></summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.VHDR.VHDR_DONE">
            <summary>Done bit</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.VHDR.VHDR_PREPARED">
            <summary>Set if this header has been prepared</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.VHDR.VHDR_INQUEUE">
            <summary>Reserved for driver</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.VHDR.VHDR_KEYFRAME">
            <summary>Key Frame</summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.CAPDRIVERCAPS">
            <summary>
            <para>The <c>CAPDRIVERCAPS</c> structure defines the capabilities of the capture driver.</para>
            <para>
            An application should use the WM_CAP_DRIVER_GET_CAPS message or capDriverGetCaps macro to place a copy of the driver
            capabilities in a <c>CAPDRIVERCAPS</c> structure whenever the application connects a capture window to a capture driver.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPDRIVERCAPS.wDeviceIndex">
            <summary>Index of the capture driver. An index value can range from 0 to 9.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPDRIVERCAPS.fHasOverlay">
            <summary>Video-overlay flag. The value of this member is <c>TRUE</c> if the device supports video overlay.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPDRIVERCAPS.fHasDlgVideoSource">
            <summary>
            Video source dialog flag. The value of this member is <c>TRUE</c> if the device supports a dialog box for selecting and
            controlling the video source.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPDRIVERCAPS.fHasDlgVideoFormat">
            <summary>
            Video format dialog flag. The value of this member is <c>TRUE</c> if the device supports a dialog box for selecting the
            video format.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPDRIVERCAPS.fHasDlgVideoDisplay">
            <summary>
            Video display dialog flag. The value of this member is <c>TRUE</c> if the device supports a dialog box for controlling the
            redisplay of video from the capture frame buffer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPDRIVERCAPS.fCaptureInitialized">
            <summary>
            Capture initialization flag. The value of this member is <c>TRUE</c> if a capture device has been successfully connected.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPDRIVERCAPS.fDriverSuppliesPalettes">
            <summary>Driver palette flag. The value of this member is <c>TRUE</c> if the driver can create palettes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPDRIVERCAPS.hVideoIn">
            <summary>Not used in Win32 applications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPDRIVERCAPS.hVideoOut">
            <summary>Not used in Win32 applications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPDRIVERCAPS.hVideoExtIn">
            <summary>Not used in Win32 applications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPDRIVERCAPS.hVideoExtOut">
            <summary>Not used in Win32 applications.</summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.CAPINFOCHUNK">
            <summary>
            The <c>CAPINFOCHUNK</c> structure contains parameters that can be used to define an information chunk within an AVI capture
            file. The WM_CAP_FILE_SET_INFOCHUNK message or <c>capSetInfoChunk</c> macro is used to send a <c>CAPINFOCHUNK</c> structure to a
            capture window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPINFOCHUNK.fccInfoID">
            <summary>
            Four-character code that identifies the representation of the chunk data. If this value is <c>NULL</c> and <c>lpData</c> is
            <c>NULL</c>, all accumulated information chunks are deleted.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPINFOCHUNK.lpData">
            <summary>Pointer to the data. If this value is <c>NULL</c>, all <c>fccInfoID</c> information chunks are deleted.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPINFOCHUNK.cbData">
            <summary>
            Size, in bytes, of the data pointed to by <c>lpData</c>. If <c>lpData</c> specifies a null-terminated string, use the string
            length incremented by one to save the <c>NULL</c> with the string.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.CAPSTATUS">
            <summary>The <c>CAPSTATUS</c> structure defines the current state of the capture window.</summary>
            <remarks>
            Because the state of a capture window changes in response to various messages, an application should update the information in
            this structure whenever it needs to enable menu items, determine the actual state of the capture window, or call the video
            format dialog box. If the application yields during streaming capture, this structure returns the progress of the capture in the
            <c>dwCurrentVideoFrame</c>, <c>dwCurrentVideoFramesDropped</c>, dwCurre <c></c> ntWaveSamples, and <c>dwCurrentTimeElapsedMS</c>
            members. Use the WM_CAP_GET_STATUS message or capGetStatus macro to update the contents of this structure.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.uiImageWidth">
            <summary>Image width, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.uiImageHeight">
            <summary>Image height, in pixels</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.fLiveWindow">
            <summary>
            Live window flag. The value of this member is <c>TRUE</c> if the window is displaying video using the preview method.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.fOverlayWindow">
            <summary>
            Overlay window flag. The value of this member is <c>TRUE</c> if the window is displaying video using hardware overlay.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.fScale">
            <summary>
            Input scaling flag. The value of this member is <c>TRUE</c> if the window is scaling the input video to the client area when
            displaying video using preview. This parameter has no effect when displaying video using overlay.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.ptScroll">
            <summary>The x- and y-offset of the pixel displayed in the upper left corner of the client area of the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.fUsingDefaultPalette">
            <summary>Default palette flag. The value of this member is <c>TRUE</c> if the capture driver is using its default palette.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.fAudioHardware">
            <summary>Audio hardware flag. The value of this member is <c>TRUE</c> if the system has waveform-audio hardware installed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.fCapFileExists">
            <summary>Capture file flag. The value of this member is <c>TRUE</c> if a valid capture file has been generated.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.dwCurrentVideoFrame">
            <summary>
            Number of frames processed during the current (or most recent) streaming capture. This count includes dropped frames.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.dwCurrentVideoFramesDropped">
            <summary>
            Number of frames dropped during the current (or most recent) streaming capture. Dropped frames occur when the capture rate
            exceeds the rate at which frames can be saved to file. In this case, the capture driver has no buffers available for storing
            data. Dropping frames does not affect synchronization because the previous frame is displayed in place of the dropped frame.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.dwCurrentWaveSamples">
            <summary>Number of waveform-audio samples processed during the current (or most recent) streaming capture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.dwCurrentTimeElapsedMS">
            <summary>Time, in milliseconds, since the start of the current (or most recent) streaming capture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.hPalCurrent">
            <summary>Handle to current palette.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.fCapturingNow">
            <summary>Capturing flag. The value of this member is <c>TRUE</c> when capturing is in progress.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.dwReturn">
            <summary>Error return values. Use this member if your application does not support an error callback function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.wNumVideoAllocated">
            <summary>
            Number of video buffers allocated. This value might be less than the number specified in the <c>wNumVideoRequested</c>
            member of the CAPTUREPARMS structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPSTATUS.wNumAudioAllocated">
            <summary>
            Number of audio buffers allocated. This value might be less than the number specified in the <c>wNumAudioRequested</c>
            member of the CAPTUREPARMS structure.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.CAPTUREPARMS">
            <summary>
            The <c>CAPTUREPARMS</c> structure contains parameters that control the streaming video capture process. This structure is used
            to get and set parameters that affect the capture rate, the number of buffers to use while capturing, and how capture is terminated.
            </summary>
            <remarks>
            <para>
            The WM_CAP_GET_SEQUENCE_SETUP message or capCaptureGetSetup macro is used to retrieve the current capture parameters. The
            WM_CAP_SET_SEQUENCE_SETUP message or capCaptureSetSetup macro is used to set the capture parameters.
            </para>
            <para>
            The WM_CAP_GET_SEQUENCE_SETUP message or capCaptureGetSetup macro is used to retrieve the current capture parameters. The
            WM_CAP_SET_SEQUENCE_SETUP message or capCaptureSetSetup macro is used to set the capture parameters.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.dwRequestMicroSecPerFrame">
            <summary>Requested frame rate, in microseconds. The default value is 66667, which corresponds to 15 frames per second.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.fMakeUserHitOKToCapture">
            <summary>
            User-initiated capture flag. If this member is <c>TRUE</c>, AVICap displays a dialog box prompting the user to initiate
            capture. The default value is <c>FALSE</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.wPercentDropForError">
            <summary>
            Maximum allowable percentage of dropped frames during capture. Values range from 0 to 100. The default value is 10.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.fYield">
            <summary>
            <para>
            Yield flag. If this member is <c>TRUE</c>, the capture window spawns a separate background thread to perform step and
            streaming capture. The default value is <c>FALSE</c>.
            </para>
            <para>
            Applications that set this flag must handle potential reentry issues because the controls in the application are not
            disabled while capture is in progress.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.dwIndexSize">
            <summary>
            <para>
            Maximum number of index entries in an AVI file. Values range from 1800 to 324,000. If set to 0, a default value of 34,952
            (32K frames plus a proportional number of audio buffers) is used.
            </para>
            <para>
            Each video frame or buffer of waveform-audio data uses one index entry. The value of this entry establishes a limit for the
            number of frames or audio buffers that can be captured.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.wChunkGranularity">
            <summary>Logical block size, in bytes, of an AVI file. The value 0 indicates the current sector size is used as the granularity.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.fUsingDOSMemory">
            <summary>Not used in Win32 applications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.wNumVideoRequested">
            <summary>
            Maximum number of video buffers to allocate. The memory area to place the buffers is specified with <c>fUsingDOSMemory</c>.
            The actual number of buffers allocated might be lower if memory is unavailable.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.fCaptureAudio">
            <summary>
            Capture audio flag. If this member is <c>TRUE</c>, audio is captured during streaming capture. This is the default value if
            audio hardware is installed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.wNumAudioRequested">
            <summary>Maximum number of audio buffers to allocate. The maximum number of buffers is 10.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.vKeyAbort">
            <summary>
            <para>
            Virtual keycode used to terminate streaming capture. The default value is VK_ESCAPE. You must call the RegisterHotKey
            function before specifying a keystroke that can abort a capture session.
            </para>
            <para>
            You can combine keycodes that include CTRL and SHIFT keystrokes by using the logical OR operator with the keycodes for CTRL
            (0x8000) and SHIFT (0x4000).
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.fAbortLeftMouse">
            <summary>
            Abort flag for left mouse button. If this member is <c>TRUE</c>, streaming capture stops if the left mouse button is
            pressed. The default value is <c>TRUE</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.fAbortRightMouse">
            <summary>
            Abort flag for right mouse button. If this member is <c>TRUE</c>, streaming capture stops if the right mouse button is
            pressed. The default value is <c>TRUE</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.fLimitEnabled">
            <summary>
            Time limit enabled flag. If this member is <c>TRUE</c>, streaming capture stops after the number of seconds in
            <c>wTimeLimit</c> has elapsed. The default value is <c>FALSE</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.wTimeLimit">
            <summary>Time limit for capture, in seconds. This parameter is used only if <c>fLimitEnabled</c> is <c>TRUE</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.fMCIControl">
            <summary>
            MCI device capture flag. If this member is <c>TRUE</c>, AVICap controls an MCI-compatible video source during streaming
            capture. MCI-compatible video sources include VCRs and laserdiscs.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.fStepMCIDevice">
            <summary>
            MCI device step capture flag. If this member is <c>TRUE</c>, step capture using an MCI device as a video source is enabled.
            If it is <c>FALSE</c>, real-time capture using an MCI device is enabled. (If <c>fMCIControl</c> is <c>FALSE</c>, this member
            is ignored.)
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.dwMCIStartTime">
            <summary>
            Starting position, in milliseconds, of the MCI device for the capture sequence. (If <c>fMCIControl</c> is <c>FALSE</c>, this
            member is ignored.)
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.dwMCIStopTime">
            <summary>
            Stopping position, in milliseconds, of the MCI device for the capture sequence. When this position in the content is
            reached, capture ends and the MCI device stops. (If <c>fMCIControl</c> is <c>FALSE</c>, this member is ignored.)
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.fStepCaptureAt2x">
            <summary>
            <para>
            Double-resolution step capture flag. If this member is <c>TRUE</c>, the capture hardware captures at twice the specified
            resolution. (The resolution for the height and width is doubled.)
            </para>
            <para>Enable this option if the hardware does not support hardware-based decimation and you are capturing in the RGB format.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.wStepCaptureAverageFrames">
            <summary>
            Number of times a frame is sampled when creating a frame based on the average sample. A typical value for the number of
            averages is 5.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.dwAudioBufferSize">
            <summary>
            Audio buffer size. If the default value of zero is used, the size of each buffer will be the maximum of 0.5 seconds of audio
            or 10K bytes.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.fDisableWriteCache">
            <summary>Not used in Win32 applications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.CAPTUREPARMS.AVStreamMaster">
            <summary>
            Indicates whether the audio stream controls the clock when writing an AVI file. If this member is set to
            AVSTREAMMASTER_AUDIO, the audio stream is considered the master stream and the video stream duration is forced to match the
            audio duration. If this member is set to AVSTREAMMASTER_NONE, the durations of audio and video streams can differ.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.DRAWDIBTIME">
            <summary>
            The <c>DRAWDIBTIME</c> structure contains elapsed timing information for performing a set of DrawDib operations. The DrawDibTime
            function resets the count and the elapsed time value for each operation each time it is called.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.DRAWDIBTIME.timeCount">
            <summary>
            <para>Number of times the following operations have been performed since DrawDibTime was last called:</para>
            <list type="bullet">
            <item>
            <term>Draw a bitmap on the screen.</term>
            </item>
            <item>
            <term>Decompress a bitmap.</term>
            </item>
            <item>
            <term>Dither a bitmap.</term>
            </item>
            <item>
            <term>Stretch a bitmap.</term>
            </item>
            <item>
            <term>Transfer bitmap data by using the BitBlt function.</term>
            </item>
            <item>
            <term>Transfer bitmap data by using the SetDIBits function.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.DRAWDIBTIME.timeDraw">
            <summary>Time to draw bitmaps.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.DRAWDIBTIME.timeDecompress">
            <summary>Time to decompress bitmaps.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.DRAWDIBTIME.timeDither">
            <summary>Time to dither bitmaps.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.DRAWDIBTIME.timeStretch">
            <summary>Time to stretch bitmaps.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.DRAWDIBTIME.timeBlt">
            <summary>Time to transfer bitmaps by using the BitBlt function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.DRAWDIBTIME.timeSetDIBits">
            <summary>Time to transfer bitmaps by using the SetDIBits function.</summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.VIDEOHDR">
            <summary>The <c>VIDEOHDR</c> structure is used by the capVideoStreamCallback function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.VIDEOHDR.lpData">
            <summary>Pointer to locked data buffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.VIDEOHDR.dwBufferLength">
            <summary>Length of data buffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.VIDEOHDR.dwBytesUsed">
            <summary>Bytes actually used.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.VIDEOHDR.dwTimeCaptured">
            <summary>Milliseconds from start of stream.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.VIDEOHDR.dwUser">
            <summary>User-defined data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.VIDEOHDR.dwFlags">
            <summary>
            <para>The flags are defined as follows.</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>VHDR_DONE</term>
            <term>Done bit</term>
            </item>
            <item>
            <term>VHDR_PREPARED</term>
            <term>Set if this header has been prepared</term>
            </item>
            <item>
            <term>VHDR_INQUEUE</term>
            <term>Reserved for driver</term>
            </item>
            <item>
            <term>VHDR_KEYFRAME</term>
            <term>Key Frame</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.AviFil32.VIDEOHDR.dwReserved1">
            <summary>Reserved for driver.</summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.IAVIEditStream">
            <summary>
            The <c>IAVIEditStream</c> interface supports manipulating and modifying editable streams. Uses IUnknown::QueryInterface,
            IUnknown::AddRef, IUnknown::Release in addition to the following custom methods:
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIEditStream.Cut(System.Int32@,System.Int32@)">
            <summary>
            The <c>Cut</c> method removes a portion of a stream and places it in a temporary stream. Called when an application uses the
            EditStreamCut function.
            </summary>
            <param name="plStart">Pointer to a buffer that receives the starting position of the operation.</param>
            <param name="plLength">Pointer to a buffer that receives the length, in frames, of the operation.</param>
            <returns>Pointer to a buffer that receives a pointer to the interface to the new stream.</returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIEditStream.Copy(System.Int32@,System.Int32@)">
            <summary>
            The <c>Copy</c> method copies a stream or a portion of it to a temporary stream. Called when an application uses the
            EditStreamCopy function.
            </summary>
            <param name="plStart">Pointer to a buffer that receives the starting position of the operation.</param>
            <param name="plLength">Pointer to a buffer that receives the length, in frames, of the operation.</param>
            <returns>Pointer to a buffer that receives a pointer to the interface to the new stream.</returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIEditStream.Paste(System.Int32@,System.Int32@,Vanara.PInvoke.AviFil32.IAVIStream,System.Int32,System.Int32)">
            <summary>
            The <c>Paste</c> method copies a stream or a portion of it in another stream. Called when an application uses the
            EditStreamPaste function.
            </summary>
            <param name="plPos">Pointer to a buffer that receives the starting position of the operation.</param>
            <param name="plLength">Pointer to a buffer that receives the length, in bytes, of the data to paste from the source stream.</param>
            <param name="pstream">Pointer to the interface to the source stream.</param>
            <param name="lStart">Starting position of the copy operation within the source stream.</param>
            <param name="lEnd">Ending position of the copy operation within the source stream.</param>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIEditStream.Clone">
            <summary>The <c>Clone</c> method duplicates a stream. Called when an application uses the EditStreamClone function.</summary>
            <returns>Receives a pointer to the interface to the new stream.</returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIEditStream.SetInfo(Vanara.PInvoke.AviFil32.AVISTREAMINFO@,System.Int32)">
            <summary>
            The <c>SetInfo</c> method changes the characteristics of a stream. Called when an application uses the EditStreamSetInfo function.
            </summary>
            <param name="lpInfo">Pointer to an AVISTREAMINFO structure containing the new stream characteristics.</param>
            <param name="cbInfo">Size, in bytes, of the buffer.</param>
            <returns>Returns the HRESULT defined by OLE.</returns>
            <remarks>
            <para>For handlers written in C++, <c>SetInfo</c> has the following syntax:</para>
            <para>
            <code> HRESULT SetInfo(AVISTREAMINFO *lpInfo, LONG cbInfo);</code>
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.IAVIFile">
            <summary>
            The <c>IAVIFile</c> interface supports opening and manipulating files and file headers, and creating and obtaining stream
            interfaces. Uses IUnknown::QueryInterface, IUnknown::AddRef, and IUnknown::Release in addition to the following custom methods:
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIFile.Info(Vanara.PInvoke.AviFil32.AVIFILEINFO@,System.Int32)">
            <summary>
            The <c>Info</c> method returns with information about an AVI file. Called when an application uses the AVIFileInfo function.
            </summary>
            <param name="pfi">A pointer to an AVIFILEINFO structure. The method fills the structure with information about the file.</param>
            <param name="lSize">The size, in bytes, of the buffer specified by pfi.</param>
            <remarks>
            <para>
            If the buffer allocated is too small for the structure, this method should fail the call by returning AVIERR_BUFFERTOOSMALL.
            Otherwise, it should fill the structure and return its size.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIFile.GetStream(Vanara.PInvoke.AviFil32.IAVIStream@,System.UInt32,System.Int32)">
            <summary>
            The <c>GetStream</c> method opens a stream by accessing it in a file. Called when an application uses the AVIFileGetStream function.
            </summary>
            <param name="ppStream">Pointer to a buffer that receives a pointer to the interface to a stream.</param>
            <param name="fccType">Four-character code indicating the type of stream to locate.</param>
            <param name="lParam">Stream number.</param>
            <remarks>
            <para>
            It is typically easier to implement this method by creating all of the stream objects in advance by using the IAVIFile::Open
            method. Then, this method accesses the interface to the specified stream.
            </para>
            <para>
            Remember to increment the reference count maintained by the <c>AddRef</c> method for the stream when this method is used.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIFile.CreateStream(Vanara.PInvoke.AviFil32.IAVIStream@,Vanara.PInvoke.AviFil32.AVISTREAMINFO@)">
            <summary>
            The <c>CreateStream</c> method creates a stream for writing. Called when an application uses the AVIFileCreateStream function.
            </summary>
            <param name="ppStream">Pointer to a buffer that receives a pointer to the interface to the new stream.</param>
            <param name="psi">Pointer to an AVISTREAMINFO structure defining the stream to create.</param>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIFile.WriteData(System.UInt32,System.IntPtr,System.Int32)">
            <summary>The <c>WriteData</c> method writes file headers. Called when an application uses the AVIFileWriteData function.</summary>
            <param name="ckid">A chunk ID.</param>
            <param name="lpData">A pointer specifying the memory from which the data is written.</param>
            <param name="cbData">A LONG specifying the number of bytes to write.</param>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIFile.ReadData(System.UInt32,System.IntPtr,System.Int32@)">
            <summary>The <c>ReadData</c> method reads file headers. Called when an application uses the AVIFileReadData function.</summary>
            <param name="ckid">A chunk identfier.</param>
            <param name="lpData">A pointer specifying the memory into which the data is read.</param>
            <param name="lpcbData">A pointer to a LONG specifying the number of bytes read.</param>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIFile.EndRecord">
            <summary>
            The <c>EndRecord</c> method writes the "REC" chunk in a tightly interleaved AVI file (having a one-to-one interleave factor
            of audio to video). Called when an application uses the AVIFileEndRecord function.
            </summary>
            <remarks>
            <para>This file handler method is typically not used.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIFile.DeleteStream(System.UInt32,System.Int32)">
            <summary>Deletes the stream.</summary>
            <param name="fccType">Four-character code indicating the type of stream to delete.</param>
            <param name="lParam">Stream number.</param>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.IAVIStream">
            <summary>
            The <c>IAVIStream</c> interface supports creating and manipulating data streams within a file. Uses IUnknown::QueryInterface,
            IUnknown::AddRef, IUnknown::Release in addition to the following custom methods:
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIStream.Create(System.IntPtr,System.IntPtr)">
            <summary>
            The <c>Create</c> method initializes a stream handler that is not associated with any file. Called when an application uses
            the AVIStreamCreate function.
            </summary>
            <param name="lParam1">Stream handler-specific data.</param>
            <param name="lParam2">Stream handler-specific data.</param>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIStream.Info(Vanara.PInvoke.AviFil32.AVISTREAMINFO@,System.Int32)">
            <summary>
            The <c>Info</c> method fills and returns an AVISTREAMINFO structure with information about a stream. Called when an
            application uses the AVIStreamInfo function.
            </summary>
            <param name="psi">Pointer to an AVISTREAMINFO structure to contain stream information.</param>
            <param name="lSize">Size, in bytes, of the structure specified by psi.</param>
            <remarks>
            <para>
            If the buffer allocated is too small for the structure, the <c>Info</c> method should fail the call by returning
            AVIERR_BUFFERTOOSMALL. Otherwise, it should fill the structure and return its size.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIStream.FindSample(System.Int32,Vanara.PInvoke.AviFil32.FINDF)">
            <summary>
            The <c>FindSample</c> method obtains the position in a stream of a key frame or a nonempty frame. Called when an application
            uses the AVIStreamFindSample function.
            </summary>
            <param name="lPos">Position of the sample or frame.</param>
            <param name="lFlags">
            <para>Applicable flags. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>FIND_ANY</term>
            <term>Searches for a nonempty frame.</term>
            </item>
            <item>
            <term>FIND_FORMAT</term>
            <term>Searches for a format change.</term>
            </item>
            <item>
            <term>FIND_KEY</term>
            <term>Searches for a key frame.</term>
            </item>
            <item>
            <term>FIND_NEXT</term>
            <term>Searches forward through a stream, beginning with the current frame.</term>
            </item>
            <item>
            <term>FIND_PREV</term>
            <term>Searches backward through a stream, beginning with the current frame.</term>
            </item>
            </list>
            <para>
            The FIND_ANY, FIND_KEY, and FIND_FORMAT flags are mutually exclusive, as are the FIND_NEXT and FIND_PREV flags. You must
            specify one value from each group.
            </para>
            </param>
            <returns>Returns the location of the key frame corresponding to the frame specified by the application.</returns>
            <remarks>
            <para>If key frames are not significant in your custom format, return the position specified for lPos.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIStream.ReadFormat(System.Int32,System.IntPtr,System.Int32@)">
            <summary>
            The <c>ReadFormat</c> method obtains format information from a stream. Fills and returns a structure with the data in an
            application-defined buffer. If no buffer is supplied, determines the buffer size needed to retrieve the buffer of format
            data. Called when an application uses the AVIStreamReadFormat function.
            </summary>
            <param name="lPos">Position of the sample or frame.</param>
            <param name="lpFormat">
            Pointer to the buffer for the format data. Specify <c>NULL</c> to request the required size of the buffer.
            </param>
            <param name="lpcbFormat">
            Pointer to a buffer that receives the size, in bytes, of the buffer specified by lpFormat. When this method is called, the
            contents of this parameter indicates the size of the buffer specified by lpFormat. When this method returns control to the
            application, the contents of this parameter specifies the amount of data read or the required size of the buffer.
            </param>
            <remarks>
            <para>
            The type of data stored in a stream dictates the format information and the structure that contains the format information.
            A stream handler should return all applicable format information in this structure, including palette information when the
            format uses a palette. A stream handler should not return stream data with the structure.
            </para>
            <para>
            Standard video stream handlers provide format information in a <c>BITMAPINFOHEADER</c> structure. Standard audio stream
            handlers provide format information in a <c>PCMWAVEFORMAT</c> structure. Other data streams can use other structures that
            describe the stream data.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIStream.SetFormat(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            The <c>SetFormat</c> method sets format information in a stream. Called when an application uses the AVIStreamSetFormat function.
            </summary>
            <param name="lPos">Pointer to the interface to a stream.</param>
            <param name="lpFormat">Pointer to the buffer for the format data.</param>
            <param name="cbFormat">Address containing the size, in bytes, of the buffer specified by lpFormat.</param>
            <remarks>
            <para>
            Standard video stream handlers provide format information in a <c>BITMAPINFOHEADER</c> structure. Standard audio stream
            handlers provide format information in a <c>PCMWAVEFORMAT</c> structure. Other data streams can use other structures that
            describe the stream data.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIStream.Read(System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            The <c>Read</c> method reads data from a stream and copies it to an application-defined buffer. If no buffer is supplied, it
            determines the buffer size needed to retrieve the next buffer of data. Called when an application uses the AVIStreamRead function.
            </summary>
            <param name="lStart">Starting sample or frame number to read.</param>
            <param name="lSamples">Number of samples to read.</param>
            <param name="lpBuffer">
            Pointer to the application-defined buffer to contain the stream data. You can also specify <c>NULL</c> to request the
            required size of the buffer. Many applications precede each read operation with a query for the buffer size to see how large
            a buffer is needed.
            </param>
            <param name="cbBuffer">Size, in bytes, of the buffer specified by lpBuffer.</param>
            <param name="plBytes">Pointer to a buffer that receives the number of bytes read.</param>
            <param name="plSamples">Pointer to a buffer that receives the number of samples read.</param>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIStream.Write(System.Int32,System.Int32,System.IntPtr,System.Int32,Vanara.PInvoke.AviFil32.AVIIF,System.Int32@,System.Int32@)">
            <summary>The <c>Write</c> method writes data to a stream. Called when an application uses the AVIStreamWrite function.</summary>
            <param name="lStart">Starting sample or frame number to write.</param>
            <param name="lSamples">Number of samples to write.</param>
            <param name="lpBuffer">Pointer to the buffer for the data.</param>
            <param name="cbBuffer">Size, in bytes, of the buffer specified by lpBuffer.</param>
            <param name="dwFlags">
            Applicable flags. The AVIF_KEYFRAME flag is defined and indicates that this frame contains all the information needed for a
            complete image.
            </param>
            <param name="plSampWritten">Pointer to a buffer used to contain the number of samples written.</param>
            <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIStream.Delete(System.Int32,System.Int32)">
            <summary>The <c>Delete</c> method deletes data from a stream.</summary>
            <param name="lStart">Starting sample or frame number to delete.</param>
            <param name="lSamples">Number of samples to delete.</param>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIStream.ReadData(System.UInt32,System.IntPtr,System.Int32@)">
            <summary>
            The <c>ReadData</c> method reads data headers of a stream. Called when an application uses the AVIStreamReadData function.
            </summary>
            <param name="fcc">Four-character code of the stream header to read.</param>
            <param name="lp">Pointer to the buffer to contain the header data.</param>
            <param name="lpcb">
            Size, in bytes, of the buffer specified by lpBuffer. When this method returns control to the application, the contents of
            this parameter specifies the amount of data read.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIStream.WriteData(System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            The <c>WriteData</c> method writes headers for a stream. Called when an application uses the AVIStreamWriteData function.
            </summary>
            <param name="fcc">Four-character code of the stream header to write.</param>
            <param name="lp">Pointer to the buffer that contains the header data to write.</param>
            <param name="cb">Size, in bytes, of the buffer specified by lpBuffer.</param>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.IAVIStreaming">
            <summary>
            The <c>IAVIStreaming</c> interface supports preparing open data streams for playback in streaming operations. Uses
            IUnknown::QueryInterface, IUnknown::AddRef, IUnknown::Release in addition to the following custom methods:
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIStreaming.Begin(System.Int32,System.Int32,System.Int32)">
            <summary>
            The <c>Begin</c> method prepares for the streaming operation. Called when an application uses the AVIStreamBeginStreaming function.
            </summary>
            <param name="lStart">Starting frame for streaming.</param>
            <param name="lEnd">Ending frame for streaming.</param>
            <param name="lRate">
            Speed at which the file is read relative to its normal playback rate. Normal speed is 1000. Larger values indicate faster
            speeds; smaller values indicate slower speeds.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IAVIStreaming.End">
            <summary>
            The <c>End</c> method ends the streaming operation. Called when an application uses the AVIStreamEndStreaming function.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.AviFil32.IGetFrame">
            <summary>
            The <c>IGetFrame</c> interface supports extracting, decompressing, and displaying individual frames from an open stream. Uses
            IUnknown::QueryInterface, IUnknown::AddRef, IUnknown::Release in addition to the following custom methods:
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IGetFrame.GetFrame(System.Int32)">
            <summary>
            The <c>GetFrame</c> method retrieves a decompressed copy of a frame from a stream. Called when an application uses the
            AVIStreamGetFrame function.
            </summary>
            <param name="lPos">Frame to copy and decompress.</param>
            <returns>Returns the address of the decompressed frame data.</returns>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IGetFrame.Begin(System.Int32,System.Int32,System.Int32)">
            <summary>
            The <c>Begin</c> method prepares to extract and decompress copies of frames from a stream. Called when an application uses
            the AVIStreamGetFrameOpen function.
            </summary>
            <param name="lStart">Starting frame for extracting and decompressing.</param>
            <param name="lEnd">Ending frame for extracting and decompressing.</param>
            <param name="lRate">
            Speed at which the file is read relative to its normal playback rate. Normal speed is 1000. Larger values indicate faster
            speeds; smaller values indicate slower speeds.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IGetFrame.End">
            <summary>
            The <c>End</c> method ends frame extraction and decompression. Called when an application uses the AVIStreamGetFrameClose function.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.AviFil32.IGetFrame.SetFormat(Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            The <c>SetFormat</c> method sets the decompressed image format of the frames being extracted and optionally provides a
            buffer for the decompression operation.
            </summary>
            <param name="lpbi">
            Pointer to a BITMAPINFOHEADER structure defining the decompressed image format. You can also specify <c>NULL</c> or the value
            <code>((LPBITMAPINFOHEADER) 1)</code>
            for this parameter. <c>NULL</c> causes the decompressor to choose a format that is appropriate for editing (normally a
            24-bit image depth format). The value
            <code>((LPBITMAPINFOHEADER) 1)</code>
            causes the decompressor to choose a format appropriate for the current display mode.
            </param>
            <param name="lpBits">
            Pointer to a buffer to contain the decompressed image data. Specify <c>NULL</c> to have this method allocate a buffer.
            </param>
            <param name="x">
            The x-coordinate of the destination rectangle within the DIB specified by lpbi. This parameter is used when lpBits is not <c>NULL</c>.
            </param>
            <param name="y">
            The y-coordinate of the destination rectangle within the DIB specified by lpbi. This parameter is used when lpBits is not <c>NULL</c>.
            </param>
            <param name="dx">Width of the destination rectangle. This parameter is used when lpBits is not <c>NULL</c>.</param>
            <param name="dy">Height of the destination rectangle. This parameter is used when lpBits is not <c>NULL</c>.</param>
            <remarks>
            <para>
            The x, y, dx, and dy parameters identify the portion of the bitmap specified by lpbi and lpBits that receives the
            decompressed image.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32">
            <summary>Items from the Vfw32.dll</summary>
            <summary>Items from the Vfw32.dll</summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.capControlCallback">
            <summary>
            <para>
            The <c>capControlCallback</c> function is the callback function used for precision control to begin and end streaming capture.
            The name <c>capControlCallback</c> is a placeholder for the application-supplied function name.
            </para>
            <para>
            To set the callback, send the WM_CAP_SET_CALLBACK_CAPCONTROL message to the capture window or call the
            capSetCallbackOnCapControl macro.
            </para>
            </summary>
            <param name="hWnd">Handle to the capture window associated with the callback function.</param>
            <param name="nState">
            Current state of the capture operation. The CONTROLCALLBACK_PREROLL value is sent initially to enable prerolling of the video
            sources and to return control to the capture application at the exact moment recording is to begin. The
            CONTROLCALLBACK_CAPTURING value is sent once per captured frame to indicate that streaming capture is in progress and to enable
            the application to end capture.
            </param>
            <returns>
            When nState is set to CONTROLCALLBACK_PREROLL, this callback function must return <c>TRUE</c> to start capture or <c>FALSE</c>
            to abort it. When nState is set to CONTROLCALLBACK_CAPTURING, this callback function must return <c>TRUE</c> to continue capture
            or <c>FALSE</c> to end it.
            </returns>
            <remarks>
            The first message sent to the callback procedure sets the nState parameter to CONTROLCALLBACK_PREROLL after allocating all
            buffers and all other capture preparations are complete.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.capErrorCallback">
            <summary>
            <para>
            The <c>capErrorCallback</c> function is the error callback function used with video capture. The name <c>capErrorCallback</c> is
            a placeholder for the application-supplied function name.
            </para>
            <para>
            To set the callback, send the WM_CAP_SET_CALLBACK_ERROR message to the capture window or call the capSetCallbackOnError macro.
            </para>
            </summary>
            <param name="hWnd">Handle to the capture window associated with the callback function.</param>
            <param name="nID">Error identification number.</param>
            <param name="lpsz">Pointer to a textual description of the returned error.</param>
            <returns>None</returns>
            <remarks>
            <para>
            A message identifier of zero indicates a new operation is starting and the callback function should clear the current error.
            </para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines CAPERRORCALLBACK as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.capStatusCallback">
            <summary>
            <para>
            The <c>capStatusCallback</c> function is the status callback function used with video capture. The name <c>capStatusCallback</c>
            is a placeholder for the application-supplied function name.
            </para>
            <para>
            To set the callback, send the WM_CAP_SET_CALLBACK_STATUS message to the capture window or call the capSetCallbackOnStatus macro.
            </para>
            </summary>
            <param name="hWnd">Handle to the capture window associated with the callback function.</param>
            <param name="nID">Message identification number.</param>
            <param name="lpsz">Pointer to a textual description of the returned status.</param>
            <returns>None</returns>
            <remarks>
            <para>
            During capture operations, the first message sent to the callback function is always IDS_CAP_BEGIN and the last is always
            IDS_CAP_END. A message identifier of zero indicates a new operation is starting and the callback function should clear the
            current status.
            </para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines CAPSTATUSCALLBACK as an alias which automatically selects the ANSI or Unicode version of this function
            based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.capVideoStreamCallback">
            <summary>
            <para>
            The <c>capVideoStreamCallback</c> function is the callback function used with streaming capture to optionally process a frame of
            captured video. The name <c>capVideoStreamCallback</c> is a placeholder for the application-supplied function name.
            </para>
            <para>
            To set this callback for streaming capture, send the WM_CAP_SET_CALLBACK_VIDEOSTREAM message to the capture window or call the
            capSetCallbackOnVideoStream macro.
            </para>
            <para>
            To set this callback for preview frame capture, send the WM_CAP_SET_CALLBACK_FRAME message to the capture window or call the
            capSetCallbackOnFrame macro.
            </para>
            </summary>
            <param name="hWnd">Handle to the capture window associated with the callback function.</param>
            <param name="lpVHdr">Pointer to a VIDEOHDR structure containing information about the captured frame.</param>
            <returns>None</returns>
            <remarks>
            The capture window calls a video stream callback function when a video buffer is marked done by the capture driver. When
            capturing to disk, this will precede the disk write operation.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.capWaveStreamCallback">
            <summary>
            <para>
            The <c>capWaveStreamCallback</c> function is the callback function used with streaming capture to optionally process buffers of
            audio data. The name <c>capWaveStreamCallback</c> is a placeholder for the application-supplied function name.
            </para>
            <para>
            To set the callback, send the WM_CAP_SET_CALLBACK_WAVESTREAM message to the capture window or call the
            capSetCallbackOnWaveStream macro.
            </para>
            </summary>
            <param name="hWnd">Handle to the capture window associated with the callback function.</param>
            <param name="lpWHdr">Pointer to a WAVEHDR structure containing information about the captured audio data.</param>
            <returns>None</returns>
            <remarks>
            The capture window calls a wave stream callback function when an audio buffer is marked done by the waveform-audio driver. When
            capturing to disk, this will precede the disk write operation.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.capYieldCallback">
            <summary>
            <para>
            The <c>capYieldCallback</c> function is the yield callback function used with video capture. The name <c>capYieldCallback</c> is
            a placeholder for the application-supplied function name.
            </para>
            <para>
            To set the callback, send the WM_CAP_SET_CALLBACK_YIELD message to the capture window or call the capSetCallbackOnYield macro.
            </para>
            </summary>
            <param name="hWnd">Handle to the capture window associated with the callback function.</param>
            <returns>None</returns>
            <remarks>
            The capture window calls the yield callback function at least once for every captured video frame, but the exact rate depends on
            the frame rate and the overhead of the capture driver and disk.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.capMessage">
            <summary>Window messages for capture drivers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_START">
            <summary>start of unicode messages</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_UNICODE_START">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_GET_CAPSTREAMPTR">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_CALLBACK_ERRORW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_CALLBACK_STATUSW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_CALLBACK_ERRORA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_CALLBACK_STATUSA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_CALLBACK_ERROR">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_CALLBACK_STATUS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_CALLBACK_YIELD">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_CALLBACK_FRAME">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_CALLBACK_VIDEOSTREAM">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_CALLBACK_WAVESTREAM">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_GET_USER_DATA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_USER_DATA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DRIVER_CONNECT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DRIVER_DISCONNECT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DRIVER_GET_NAMEA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DRIVER_GET_VERSIONA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DRIVER_GET_NAMEW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DRIVER_GET_VERSIONW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DRIVER_GET_NAME">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DRIVER_GET_VERSION">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DRIVER_GET_CAPS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_SET_CAPTURE_FILEA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_GET_CAPTURE_FILEA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_SAVEASA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_SAVEDIBA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_SET_CAPTURE_FILEW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_GET_CAPTURE_FILEW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_SAVEASW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_SAVEDIBW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_SET_CAPTURE_FILE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_GET_CAPTURE_FILE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_SAVEAS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_SAVEDIB">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_ALLOCATE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_FILE_SET_INFOCHUNK">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_EDIT_COPY">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_AUDIOFORMAT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_GET_AUDIOFORMAT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DLG_VIDEOFORMAT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DLG_VIDEOSOURCE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DLG_VIDEODISPLAY">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_GET_VIDEOFORMAT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_VIDEOFORMAT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_DLG_VIDEOCOMPRESSION">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_PREVIEW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_OVERLAY">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_PREVIEWRATE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_SCALE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_GET_STATUS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_SCROLL">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_GRAB_FRAME">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_GRAB_FRAME_NOSTOP">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SEQUENCE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SEQUENCE_NOFILE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_SEQUENCE_SETUP">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_GET_SEQUENCE_SETUP">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_MCI_DEVICEA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_GET_MCI_DEVICEA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_MCI_DEVICEW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_GET_MCI_DEVICEW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_MCI_DEVICE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_GET_MCI_DEVICE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_STOP">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_ABORT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SINGLE_FRAME_OPEN">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SINGLE_FRAME_CLOSE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SINGLE_FRAME">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_PAL_OPENA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_PAL_SAVEA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_PAL_OPENW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_PAL_SAVEW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_PAL_OPEN">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_PAL_SAVE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_PAL_PASTE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_PAL_AUTOCREATE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_PAL_MANUALCREATE">
            <summary>Following added post VFW 1.1</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.capMessage.WM_CAP_SET_CALLBACK_CAPCONTROL">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.CONTROLCALLBACK">
            <summary>Current state of the capture operation.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CONTROLCALLBACK.CONTROLCALLBACK_PREROLL">
            <summary>Waiting to start capture</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CONTROLCALLBACK.CONTROLCALLBACK_CAPTURING">
            <summary>Now capturing</summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.VHDR">
            <summary>Flags for VIDEOHDR.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VHDR.VHDR_DONE">
            <summary>Done bit</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VHDR.VHDR_PREPARED">
            <summary>Set if this header has been prepared</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VHDR.VHDR_INQUEUE">
            <summary>Reserved for driver</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VHDR.VHDR_KEYFRAME">
            <summary>Key Frame</summary>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capCaptureAbort(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capCaptureAbort</c> macro stops the capture operation. You can use this macro or explictly send the WM_CAP_ABORT message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>
            <para>The capture operation must yield to use this macro.</para>
            <para>
            In the case of step capture, the image data collected up to the point of the <c>capCaptureAbort</c> macro will be retained in
            the capture file, but audio will not be captured.
            </para>
            <para>Use the capCaptureStop macro to halt step capture at the current position, and then capture audio.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capCaptureGetSetup(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.CAPTUREPARMS@)">
            <summary>
            The <c>capCaptureGetSetup</c> macro retrieves the current settings of the streaming capture parameters. You can use this macro
            or explictly send the WM_CAP_GET_SEQUENCE_SETUP message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="s">Pointer to a CAPTUREPARMS structure.</param>
            <returns>None</returns>
            <remarks>For information about the parameters used to control streaming capture, see the CAPTUREPARMS structure.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capCaptureSequence(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capCaptureSequence</c> macro initiates streaming video and audio capture to a file. You can use this macro or explicitly
            send the WM_CAP_SEQUENCE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>
            <para>
            If you want to alter the parameters controlling streaming capture, use the capCaptureSetSetup macro prior to starting the capture.
            </para>
            <para>
            By default, the capture window does not allow other applications to continue running during capture. To override this, either
            set the <c>fYield</c> member of the CAPTUREPARMS structure to <c>TRUE</c>, or install a yield callback function.
            </para>
            <para>
            During streaming capture, the capture window can optionally issue notifications to your application of specific types of
            conditions. To install callback procedures for these notifications, use the following macros:
            </para>
            <list type="bullet">
            <item>
            <term>capSetCallbackOnError</term>
            </item>
            <item>
            <term>capSetCallbackOnStatus</term>
            </item>
            <item>
            <term>capSetCallbackOnVideoStream</term>
            </item>
            <item>
            <term>capSetCallbackOnWaveStream</term>
            </item>
            <item>
            <term>capSetCallbackOnYield</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capCaptureSequenceNoFile(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capCaptureSequenceNoFile</c> macro initiates streaming video capture without writing data to a file. You can use this
            macro or explicitly send the WM_CAP_SEQUENCE_NOFILE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>
            <para>
            This message is useful in conjunction with video stream or waveform-audio stream callback functions that let your application
            use the video and audio data directly.
            </para>
            <para>
            If you want to alter the parameters controlling streaming capture, use the capCaptureSetSetup macro prior to starting the capture.
            </para>
            <para>
            By default, the capture window does not allow other applications to continue running during capture. To override this, either
            set the <c>fYield</c> member of the CAPTUREPARMS structure to <c>TRUE</c>, or install a yield callback function.
            </para>
            <para>
            During streaming capture, the capture window can optionally issue notifications to your application of specific types of
            conditions. To install callback procedures for these notifications, use the following macros:
            </para>
            <list type="bullet">
            <item>
            <term>capSetCallbackOnError</term>
            </item>
            <item>
            <term>capSetCallbackOnStatus</term>
            </item>
            <item>
            <term>capSetCallbackOnVideoStream</term>
            </item>
            <item>
            <term>capSetCallbackOnWaveStream</term>
            </item>
            <item>
            <term>capSetCallbackOnYield</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capCaptureSetSetup(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.CAPTUREPARMS@)">
            <summary>
            The <c>capCaptureSetSetup</c> macro sets the configuration parameters used with streaming capture. You can use this macro or
            explicitly send the WM_CAP_SET_SEQUENCE_SETUP message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="s">Pointer to a CAPTUREPARMS structure.</param>
            <returns>None</returns>
            <remarks>For information about the parameters used to control streaming capture, see the CAPTUREPARMS structure.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capCaptureSingleFrame(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capCaptureSingleFrame</c> macro appends a single frame to a capture file that was opened using the
            capCaptureSingleFrameOpen macro. You can use this macro or explicitly send the WM_CAP_SINGLE_FRAME message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capCaptureSingleFrameClose(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capCaptureSingleFrameClose</c> macro closes the capture file opened by the capCaptureSingleFrameOpen macro. You can use
            this macro or explicitly send the WM_CAP_SINGLE_FRAME_CLOSE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>For information about installing callback functions, see the capSetCallbackOnError and capSetCallbackOnFrame macros.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capCaptureSingleFrameOpen(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capCaptureSingleFrameOpen</c> macro opens the capture file for single-frame capturing. Any previous information in the
            capture file is overwritten. You can use this macro or explicitly send the WM_CAP_SINGLE_FRAME_OPEN message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>For information about installing callback functions, see the capSetCallbackOnError and capSetCallbackOnFrame macros.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capCaptureStop(Vanara.PInvoke.HWND)">
            <summary>
            <para>
            The <c>capCaptureStop</c> macro stops the capture operation. You can use this macro or explicitly send the WM_CAP_STOP message.
            </para>
            <para>
            In step frame capture, the image data that was collected before this message was sent is retained in the capture file. An
            equivalent duration of audio data is also retained in the capture file if audio capture was enabled.
            </para>
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>
            The capture operation must yield to use this message. Use the capCaptureAbort macro to abandon the current capture operation.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capCreateCaptureWindow(System.String,Vanara.PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.HWND,System.Int32)">
            <summary>The <c>capCreateCaptureWindow</c> function creates a capture window.</summary>
            <param name="lpszWindowName">Null-terminated string containing the name used for the capture window.</param>
            <param name="dwStyle">Window styles used for the capture window. Window styles are described with the CreateWindowEx function.</param>
            <param name="x">The x-coordinate of the upper left corner of the capture window.</param>
            <param name="y">The y-coordinate of the upper left corner of the capture window.</param>
            <param name="nWidth">Width of the capture window.</param>
            <param name="nHeight">Height of the capture window.</param>
            <param name="hwndParent">Handle to the parent window.</param>
            <param name="nID">Window identifier.</param>
            <returns>Returns a handle of the capture window if successful or <c>NULL</c> otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capDlgVideoCompression(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capDlgVideoCompression</c> macro displays a dialog box in which the user can select a compressor to use during the
            capture process. The list of available compressors can vary with the video format selected in the capture driver's Video Format
            dialog box. You can use this macro or explicitly send the WM_CAP_DLG_VIDEOCOMPRESSION message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>
            <para>
            Use this message with capture drivers that provide frames only in the BI_RGB format. This message is most useful in the step
            capture operation to combine capture and compression in a single operation. Compressing frames with a software compressor as
            part of a real-time capture operation is most likely too time-consuming to perform.
            </para>
            <para>Compression does not affect the frames copied to the clipboard.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capDlgVideoDisplay(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capDlgVideoDisplay</c> macro displays a dialog box in which the user can set or adjust the video output. This dialog box
            might contain controls that affect the hue, contrast, and brightness of the displayed image, as well as key color alignment. You
            can use this macro or explicitly send the WM_CAP_DLG_VIDEODISPLAY message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>
            <para>
            The controls in this dialog box do not affect digitized video data; they affect only the output or redisplay of the video signal.
            </para>
            <para>
            The Video Display dialog box is unique for each capture driver. Some capture drivers might not support a Video Display dialog
            box. Applications can determine if the capture driver supports this message by checking the <c>fHasDlgVideoDisplay</c> member of
            the CAPDRIVERCAPS structure.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capDlgVideoFormat(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capDlgVideoFormat</c> macro displays a dialog box in which the user can select the video format. The Video Format dialog
            box might be used to select image dimensions, bit depth, and hardware compression options. You can use this macro or explicitly
            send the WM_CAP_DLG_VIDEOFORMAT message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>
            <para>
            After this message returns, applications might need to update the CAPSTATUS structure because the user might have changed the
            image dimensions.
            </para>
            <para>
            The Video Format dialog box is unique for each capture driver. Some capture drivers might not support a Video Format dialog box.
            Applications can determine if the capture driver supports this message by checking the <c>fHasDlgVideoFormat</c> member of CAPDRIVERCAPS.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capDlgVideoSource(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capDlgVideoSource</c> macro displays a dialog box in which the user can control the video source. The Video Source dialog
            box might contain controls that select input sources; alter the hue, contrast, brightness of the image; and modify the video
            quality before digitizing the images into the frame buffer. You can use this macro or explicitly send the WM_CAP_DLG_VIDEOSOURCE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>
            The Video Source dialog box is unique for each capture driver. Some capture drivers might not support a Video Source dialog box.
            Applications can determine if the capture driver supports this message by checking the <c>fHasDlgVideoSource</c> member of the
            CAPDRIVERCAPS structure.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capDriverConnect(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            The <c>capDriverConnect</c> macro connects a capture window to a capture driver. You can use this macro or explicitly send the
            WM_CAP_DRIVER_CONNECT message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="i">Index of the capture driver. The index can range from 0 through 9.</param>
            <returns>None</returns>
            <remarks>Connecting a capture driver to a capture window automatically disconnects any previously connected capture driver.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capDriverDisconnect(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capDriverDisconnect</c> macro disconnects a capture driver from a capture window. You can use this macro or explicitly
            send the WM_CAP_DRIVER_DISCONNECT message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capDriverGetCaps(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.CAPDRIVERCAPS@)">
            <summary>
            The <c>capDriverGetCaps</c> macro returns the hardware capabilities of the capture driver currently connected to a capture
            window. You can use this macro or explicitly send the WM_CAP_DRIVER_GET_CAPS message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="s">Pointer to the CAPDRIVERCAPS structure to contain the hardware capabilities.</param>
            <returns>None</returns>
            <remarks>
            The capabilities returned in CAPDRIVERCAPS are constant for a given capture driver. Applications need to retrieve this
            information once when the capture driver is first connected to a capture window.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capDriverGetName(Vanara.PInvoke.HWND,System.Text.StringBuilder)">
            <summary>
            The <c>capDriverGetName</c> macro returns the name of the capture driver connected to the capture window. You can use this macro
            or explicitly call the WM_CAP_DRIVER_GET_NAME message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="szName">Pointer to an application-defined buffer used to return the device name as a null-terminated string.</param>
            <returns>None</returns>
            <remarks>
            The name is a text string retrieved from the driver's resource area. Applications should allocate approximately 80 bytes for
            this string. If the driver does not contain a name resource, the full path name of the driver listed in the registry or in the
            SYSTEM.INI file is returned.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capDriverGetVersion(Vanara.PInvoke.HWND,System.Text.StringBuilder)">
            <summary>
            The <c>capDriverGetVersion</c> macro returns the version information of the capture driver connected to a capture window. You
            can use this macro or explicitly send the WM_CAP_DRIVER_GET_VERSION message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="szVer">Pointer to an application-defined buffer used to return the version information as a null-terminated string.</param>
            <returns>None</returns>
            <remarks>
            The version information is a text string retrieved from the driver's resource area. Applications should allocate approximately
            40 bytes for this string. If version information is not available, a <c>NULL</c> string is returned.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capEditCopy(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capEditCopy</c> macro copies the contents of the video frame buffer and associated palette to the clipboard. You can use
            this macro or explicitly send the WM_CAP_EDIT_COPY message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capFileAlloc(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            The <c>capFileAlloc</c> macro creates (preallocates) a capture file of a specified size. You can use this macro or explicitly
            send the WM_CAP_FILE_ALLOCATE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="dwSize">Size, in bytes, to create the capture file.</param>
            <returns>None</returns>
            <remarks>
            You can improve streaming capture performance significantly by preallocating a capture file large enough to store an entire
            video clip and by defragmenting the capture file before capturing the clip.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capFileGetCaptureFile(Vanara.PInvoke.HWND,System.Text.StringBuilder)">
            <summary>
            The <c>capFileGetCaptureFile</c> macro returns the name of the current capture file. You can use this macro or explicitly call
            the WM_CAP_FILE_GET_CAPTURE_FILE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="szName">
            Pointer to an application-defined buffer used to return the name of the capture file as a null-terminated string.
            </param>
            <returns>None</returns>
            <remarks>The default capture filename is C:\CAPTURE.AVI.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capFileSaveAs(Vanara.PInvoke.HWND,System.String)">
            <summary>
            The <c>capFileSaveAs</c> macro copies the contents of the capture file to another file. You can use this macro or explicitly
            call the WM_CAP_FILE_SAVEAS message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="szName">
            Pointer to the null-terminated string that contains the name of the destination file used to copy the file.
            </param>
            <returns>None</returns>
            <remarks>
            <para>This message does not change the name or contents of the current capture file.</para>
            <para>If the copy operation is unsuccessful due to a disk full error, the destination file is automatically deleted.</para>
            <para>
            Typically, a capture file is preallocated for the largest capture segment anticipated and only a portion of it might be used to
            capture data. This message copies only the portion of the file containing the capture data.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capFileSaveDIB(Vanara.PInvoke.HWND,System.String)">
            <summary>
            The <c>capFileSaveDIB</c> macro copies the current frame to a DIB file. You can use this macro or explicitly call the
            WM_CAP_FILE_SAVEDIB message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="szName">Pointer to the null-terminated string that contains the name of the destination DIB file.</param>
            <returns>None</returns>
            <remarks>
            If the capture driver supplies frames in a compressed format, this call attempts to decompress the frame before writing the file.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capFileSetCaptureFile(Vanara.PInvoke.HWND,System.String)">
            <summary>
            The <c>capFileSetCaptureFile</c> macro names the file used for video capture. You can use this macro or explicitly call the
            WM_CAP_FILE_SET_CAPTURE_FILE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="szName">Pointer to the null-terminated string that contains the name of the capture file to use.</param>
            <returns>None</returns>
            <remarks>
            This message stores the filename in an internal structure. It does not create, allocate, or open the specified file. The default
            capture filename is C:\CAPTURE.AVI.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capFileSetInfoChunk(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.CAPINFOCHUNK@)">
            <summary>
            The <c>capFileSetInfoChunk</c> macro sets and clears information chunks. Information chunks can be inserted in an AVI file
            during capture to embed text strings or custom data. You can use this macro or explicitly call the WM_CAP_FILE_SET_INFOCHUNK message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="lpInfoChunk">Pointer to a CAPINFOCHUNK structure defining the information chunk to be created or deleted.</param>
            <returns>None</returns>
            <remarks>
            Multiple registered information chunks can be added to an AVI file. After an information chunk is set, it continues to be added
            to subsequent capture files until either the entry is cleared or all information chunk entries are cleared. To clear a single
            entry, specify the information chunk in the <c>fccInfoID</c> member and <c>NULL</c> in the <c>lpData</c> member of the
            CAPINFOCHUNK structure. To clear all entries, specify <c>NULL</c> in <c>fccInfoID</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capGetAudioFormat(Vanara.PInvoke.HWND,System.IntPtr,System.Int32)">
            <summary>
            The <c>capGetAudioFormat</c> macro obtains the audio format. You can use this macro or explicitly call the
            WM_CAP_GET_AUDIOFORMAT message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="s">
            Pointer to a WAVEFORMATEX structure, or <c>NULL</c>. If the value is <c>NULL</c>, the size, in bytes, required to hold the
            <c>WAVEFORMATEX</c> structure is returned.
            </param>
            <param name="wSize">Size, in bytes, of the structure referenced by s.</param>
            <returns>None</returns>
            <remarks>
            Because compressed audio formats vary in size requirements applications must first retrieve the size, then allocate memory, and
            finally request the audio format data.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capGetAudioFormatSize(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capGetAudioFormatSize</c> macro obtains the size of the audio format. You can use this macro or explicitly call the
            WM_CAP_GET_AUDIOFORMAT message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>
            Because compressed audio formats vary in size requirements applications must first retrieve the size, then allocate memory, and
            finally request the audio format data.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capGetDriverDescription(System.UInt32,System.Text.StringBuilder,System.Int32,System.Text.StringBuilder,System.Int32)">
            <summary>The <c>capGetDriverDescription</c> function retrieves the version description of the capture driver.</summary>
            <param name="wDriverIndex">
            <para>Index of the capture driver. The index can range from 0 through 9.</para>
            <para>
            Plug-and-Play capture drivers are enumerated first, followed by capture drivers listed in the registry, which are then followed
            by capture drivers listed in SYSTEM.INI.
            </para>
            </param>
            <param name="lpszName">Pointer to a buffer containing a null-terminated string corresponding to the capture driver name.</param>
            <param name="cbName">Length, in bytes, of the buffer pointed to by lpszName.</param>
            <param name="lpszVer">
            Pointer to a buffer containing a null-terminated string corresponding to the description of the capture driver.
            </param>
            <param name="cbVer">Length, in bytes, of the buffer pointed to by lpszVer.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
            <remarks>
            <para>
            If the information description is longer than its buffer, the description is truncated. The returned string is always
            null-terminated. If a buffer size is zero, its corresponding description is not copied.
            </para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines capGetDriverDescription as an alias which automatically selects the ANSI or Unicode version of this
            function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that
            not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions
            for Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capGetMCIDeviceName(Vanara.PInvoke.HWND,System.Text.StringBuilder)">
            <summary>
            The <c>capGetMCIDeviceName</c> macro retrieves the name of an MCI device previously set with the capSetMCIDeviceName macro. You
            can use this macro or explicitly call the WM_CAP_GET_MCI_DEVICE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="szName">Pointer to a null-terminated string that contains the MCI device name.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capGetStatus(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.CAPSTATUS@)">
            <summary>
            The <c>capGetStatus</c> macro retrieves the status of the capture window. You can use this macro or explicitly call the
            WM_CAP_GET_STATUS message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="s">Pointer to a CAPSTATUS structure.</param>
            <returns>None</returns>
            <remarks>
            The CAPSTATUS structure contains the current state of the capture window. Since this state is dynamic and changes in response to
            various messages, the application should initialize this structure after sending the capDlgVideoFormat macro and whenever it
            needs to enable menu items or determine the actual state of the window.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capGetUserData(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capGetUserData</c> macro retrieves a <c>LONG_PTR</c> data value associated with a capture window. You can use this macro
            or explicitly call the WM_CAP_GET_USER_DATA message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>Returns a value previously saved by using the WM_CAP_SET_USER_DATA message.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capGetVideoFormat(Vanara.PInvoke.HWND,Vanara.PInvoke.Gdi32.SafeBITMAPINFO)">
            <summary>
            The <c>capGetVideoFormat</c> macro retrieves a copy of the video format in use. You can use this macro or explicitly call the
            WM_CAP_GET_VIDEOFORMAT message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="s">
            Pointer to a BITMAPINFO structure. You can also specify <c>NULL</c> to retrieve the number of bytes needed by <c>BITMAPINFO</c>.
            </param>
            <returns>None</returns>
            <remarks>
            Because compressed video formats vary in size requirements applications must first retrieve the size, then allocate memory, and
            finally request the video format data.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capGetVideoFormatSize(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capGetVideoFormatSize</c> macro retrieves the size required for the video format. You can use this macro or explicitly
            call the WM_CAP_GET_VIDEOFORMAT message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>
            Because compressed video formats vary in size requirements applications must first retrieve the size, then allocate memory, and
            finally request the video format data.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capGrabFrame(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capGrabFrame</c> macro retrieves and displays a single frame from the capture driver. After capture, overlay and preview
            are disabled. You can use this macro or explicitly call the WM_CAP_GRAB_FRAME message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>For information about installing callback functions, see the capSetCallbackOnError and capSetCallbackOnFrame macros.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capGrabFrameNoStop(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capGrabFrameNoStop</c> macro fills the frame buffer with a single uncompressed frame from the capture device and displays
            it. Unlike with the capGrabFrame macro, the state of overlay or preview is not altered by this message. You can use this macro
            or explicitly call the WM_CAP_GRAB_FRAME_NOSTOP message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>
            For information about installing callback functions, see the <c>capSetCallbackOnError</c> and <c>capSetCallbackOnFrame</c> macros.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capOverlay(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            The <c>capOverlay</c> macro enables or disables overlay mode. In overlay mode, video is displayed using hardware overlay. You
            can use this macro or explicitly call the WM_CAP_SET_OVERLAY message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="f">Overlay flag. Specify <c>TRUE</c> for this parameter to enable overlay mode or <c>FALSE</c> to disable it.</param>
            <returns>None</returns>
            <remarks>
            <para>Using an overlay does not require CPU resources.</para>
            <para>
            The <c>fHasOverlay</c> member of the <c>CAPDRIVERCAPS</c> structure indicates whether the device is capable of overlay. The
            <c>fOverlayWindow</c> member of the <c>CAPSTATUS</c> structure indicates whether overlay mode is currently enabled.
            </para>
            <para>Enabling overlay mode automatically disables preview mode.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capPaletteAuto(Vanara.PInvoke.HWND,System.Int32,System.Int32)">
            <summary>
            The <c>capPaletteAuto</c> macro requests that the capture driver sample video frames and automatically create a new palette. You
            can use this macro or explicitly call the WM_CAP_PAL_AUTOCREATE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="iFrames">Number of frames to sample.</param>
            <param name="iColors">Number of colors in the palette. The maximum value for this parameter is 256.</param>
            <returns>None</returns>
            <remarks>
            The sampled video sequence should include all the colors you want in the palette. To obtain the best palette, you might have to
            sample the whole sequence rather than a portion of it.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capPaletteManual(Vanara.PInvoke.HWND,System.Boolean,System.Int32)">
            <summary>
            The <c>capPaletteManual</c> macro requests that the capture driver manually sample video frames and create a new palette. You
            can use this macro or explicitly call the WM_CAP_PAL_MANUALCREATE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="fGrab">
            Palette histogram flag. Set this parameter to <c>TRUE</c> for each frame included in creating the optimal palette. After the
            last frame has been collected, set this parameter to <c>FALSE</c> to calculate the optimal palette and send it to the capture driver.
            </param>
            <param name="iColors">
            Number of colors in the palette. The maximum value for this parameter is 256. This value is used only during collection of the
            first frame in a sequence.
            </param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capPaletteOpen(Vanara.PInvoke.HWND,System.String)">
            <summary>
            The <c>capPaletteOpen</c> macro loads a new palette from a palette file and passes it to a capture driver. Palette files
            typically use the filename extension .PAL. A capture driver uses a palette when required by the specified digitized image
            format. You can use this macro or explicitly call the WM_CAP_PAL_OPEN message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="szName">Pointer to a null-terminated string containing the palette filename.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capPalettePaste(Vanara.PInvoke.HWND)">
            <summary>
            The <c>capPalettePaste</c> macro copies the palette from the clipboard and passes it to a capture driver. You can use this macro
            or explicitly call the WM_CAP_PAL_PASTE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <returns>None</returns>
            <remarks>A capture driver uses a palette when required by the specified digitized video format.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capPaletteSave(Vanara.PInvoke.HWND,System.String)">
            <summary>
            The <c>capPaletteSave</c> macro saves the current palette to a palette file. Palette files typically use the filename extension
            .PAL. You can use this macro or explicitly send the WM_CAP_PAL_SAVE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="szName">Pointer to a null-terminated string containing the palette filename.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capPreview(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            The <c>capPreview</c> macro enables or disables preview mode. In preview mode, frames are transferred from the capture hardware
            to system memory and then displayed in the capture window using GDI functions. You can use this macro or explicitly call the
            WM_CAP_SET_PREVIEW message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="f">Preview flag. Specify <c>TRUE</c> for this parameter to enable preview mode or <c>FALSE</c> to disable it.</param>
            <returns>None</returns>
            <remarks>
            <para>
            The preview mode uses substantial CPU resources. Applications can disable preview or lower the preview rate when another
            application has the focus. The <c>fLiveWindow</c> member of the CAPSTATUS structure indicates if preview mode is currently enabled.
            </para>
            <para>Enabling preview mode automatically disables overlay mode.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capPreviewRate(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            The <c>capPreviewRate</c> macro sets the frame display rate in preview mode. You can use this macro or explicitly call the
            WM_CAP_SET_PREVIEWRATE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="wMS">Rate, in milliseconds, at which new frames are captured and displayed.</param>
            <returns>None</returns>
            <remarks>
            The preview mode uses substantial CPU resources. Applications can disable preview or lower the preview rate when another
            application has the focus. During streaming video capture, the previewing task is lower priority than writing frames to disk,
            and preview frames are displayed only if no other buffers are available for writing.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capPreviewScale(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            The <c>capPreviewScale</c> macro enables or disables scaling of the preview video images. If scaling is enabled, the captured
            video frame is stretched to the dimensions of the capture window. You can use this macro or explicitly call the WM_CAP_SET_SCALE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="f">
            Preview scaling flag. Specify <c>TRUE</c> for this parameter to stretch preview frames to the size of the capture window or
            <c>FALSE</c> to display them at their natural size.
            </param>
            <returns>None</returns>
            <remarks>
            <para>
            Scaling preview images controls the immediate presentation of captured frames within the capture window. It has no effect on the
            size of the frames saved to file.
            </para>
            <para>Scaling has no effect when using overlay to display video in the frame buffer.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetAudioFormat(Vanara.PInvoke.HWND,Vanara.PInvoke.WinMm.WAVEFORMATEX@)">
            <summary>
            The <c>capSetAudioFormat</c> macro sets the audio format to use when performing streaming or step capture. You can use this
            macro or explicitly call the WM_CAP_SET_AUDIOFORMAT message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="s">Pointer to a WAVEFORMATEX or PCMWAVEFORMAT structure that defines the audio format.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetAudioFormat(Vanara.PInvoke.HWND,Vanara.PInvoke.WinMm.PCMWAVEFORMAT@)">
            <summary>
            The <c>capSetAudioFormat</c> macro sets the audio format to use when performing streaming or step capture. You can use this
            macro or explicitly call the WM_CAP_SET_AUDIOFORMAT message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="s">Pointer to a WAVEFORMATEX or PCMWAVEFORMAT structure that defines the audio format.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetCallbackOnCapControl(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.capControlCallback)">
            <summary>
            The <c>capSetCallbackOnCapControl</c> macro sets a callback function in the application giving it precise recording control. You
            can use this macro or explicitly call the WM_CAP_SET_CALLBACK_CAPCONTROL message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="fpProc">
            Pointer to the callback function, of type capControlCallback . Specify <c>NULL</c> for this parameter to disable a previously
            installed callback function.
            </param>
            <returns>None</returns>
            <remarks>
            A single callback function is used to give the application precise control over the moments that streaming capture begins and
            completes. The capture window first calls the procedure with nState set to CONTROLCALLBACK_PREROLL after all buffers have been
            allocated and all other capture preparations have finished. This gives the application the ability to preroll video sources,
            returning from the callback function at the exact moment recording is to begin. A return value of <c>TRUE</c> from the callback
            function continues capture, and a return value of <c>FALSE</c> aborts capture. After capture begins, this callback function will
            be called frequently with nState set to CONTROLCALLBACK_CAPTURING to allow the application to end capture by returning <c>FALSE</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetCallbackOnError(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.capErrorCallback)">
            <summary>
            The <c>capSetCallbackOnError</c> macro sets an error callback function in the client application. AVICap calls this procedure
            when errors occur. You can use this macro or explicitly call the WM_CAP_SET_CALLBACK_ERROR message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="fpProc">
            Pointer to the error callback function, of type capErrorCallback. Specify <c>NULL</c> for this parameter to disable a previously
            installed error callback function.
            </param>
            <returns>None</returns>
            <remarks>
            <para>
            Applications can optionally set an error callback function. If set, AVICap calls the error procedure in the following situations:
            </para>
            <list type="bullet">
            <item>
            <term>The disk is full.</term>
            </item>
            <item>
            <term>A capture window cannot be connected with a capture driver.</term>
            </item>
            <item>
            <term>A waveform-audio device cannot be opened.</term>
            </item>
            <item>
            <term>The number of frames dropped during capture exceeds the specified percentage.</term>
            </item>
            <item>
            <term>The frames cannot be captured due to vertical synchronization interrupt problems.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetCallbackOnFrame(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.capVideoStreamCallback)">
            <summary>
            The <c>capSetCallbackOnFrame</c> macro sets a preview callback function in the application. AVICap calls this procedure when the
            capture window captures preview frames. You can use this macro or explicitly call the WM_CAP_SET_CALLBACK_FRAME message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="fpProc">
            Pointer to the preview callback function, of type capVideoStreamCallback. Specify <c>NULL</c> for this parameter to disable a
            previously installed callback function.
            </param>
            <returns>None</returns>
            <remarks>
            The capture window calls the callback function before displaying preview frames. This allows an application to modify the frame
            if desired. This callback function is not used during streaming video capture.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetCallbackOnStatus(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.capStatusCallback)">
            <summary>
            The <c>capSetCallbackOnStatus</c> macro sets a status callback function in the application. AVICap calls this procedure whenever
            the capture window status changes. You can use this macro or explicitly call the WM_CAP_SET_CALLBACK_STATUS message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="fpProc">
            Pointer to the status callback function, of type capStatusCallback. Specify <c>NULL</c> for this parameter to disable a
            previously installed status callback function.
            </param>
            <returns>None</returns>
            <remarks>
            <para>Applications can optionally set a status callback function. If set, AVICap calls this procedure in the following situations:</para>
            <list type="bullet">
            <item>
            <term>A capture session is completed.</term>
            </item>
            <item>
            <term>A capture driver successfully connected to a capture window.</term>
            </item>
            <item>
            <term>An optimal palette is created.</term>
            </item>
            <item>
            <term>The number of captured frames is reported.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetCallbackOnVideoStream(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.capVideoStreamCallback)">
            <summary>
            The <c>capSetCallbackOnVideoStream</c> macro sets a callback function in the application. AVICap calls this procedure during
            streaming capture when a video buffer is filled. You can use this macro or explicitly call the WM_CAP_SET_CALLBACK_VIDEOSTREAM message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="fpProc">
            Pointer to the video-stream callback function, of type capVideoStreamCallback. Specify <c>NULL</c> for this parameter to disable
            a previously installed video-stream callback function.
            </param>
            <returns>None</returns>
            <remarks>
            <para>
            The capture window calls the callback function before writing the captured frame to disk. This allows applications to modify the
            frame if desired.
            </para>
            <para>
            If a video stream callback function is used for streaming capture, the procedure must be installed before starting the capture
            session and it must remain enabled for the duration of the session. It can be disabled after streaming capture ends.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetCallbackOnWaveStream(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.capWaveStreamCallback)">
            <summary>
            The <c>capSetCallbackOnWaveStream</c> macro sets a callback function in the application. AVICap calls this procedure during
            streaming capture when a new audio buffer becomes available. You can use this macro or explicitly call the
            WM_CAP_SET_CALLBACK_WAVESTREAM message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="fpProc">
            Pointer to the wave stream callback function, of type capWaveStreamCallback. Specify <c>NULL</c> for this parameter to disable a
            previously installed wave stream callback function.
            </param>
            <returns>None</returns>
            <remarks>
            <para>
            The capture window calls the procedure before writing the audio buffer to disk. This allows applications to modify the audio
            buffer if desired.
            </para>
            <para>
            If a wave stream callback function is used, it must be installed before starting the capture session and it must remain enabled
            for the duration of the session. It can be disabled after streaming capture ends.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetCallbackOnYield(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.capYieldCallback)">
            <summary>
            The <c>capSetCallbackOnYield</c> macro sets a callback function in the application. AVICap calls this procedure when the capture
            window yields during streaming capture. You can use this macro or explicitly call the WM_CAP_SET_CALLBACK_YIELD message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="fpProc">
            Pointer to the yield callback function, of type capYieldCallback. Specify <c>NULL</c> for this parameter to disable a previously
            installed yield callback function.
            </param>
            <returns>None</returns>
            <remarks>
            <para>
            Applications can optionally set a yield callback function. The yield callback function is called at least once for each video
            frame captured during streaming capture. If a yield callback function is installed, it will be called regardless of the state of
            the <c>fYield</c> member of the CAPTUREPARMS structure.
            </para>
            <para>
            If the yield callback function is used, it must be installed before starting the capture session and it must remain enabled for
            the duration of the session. It can be disabled after streaming capture ends.
            </para>
            <para>
            Applications typically perform some type of message processing in the callback function consisting of a PeekMessage,
            TranslateMessage, DispatchMessage loop, as in the message loop of a WinMain function. The yield callback function must also
            filter and remove messages that can cause reentrancy problems.
            </para>
            <para>
            An application typically returns <c>TRUE</c> in the yield procedure to continue streaming capture. If a yield callback function
            returns <c>FALSE</c>, the capture window stops the capture process.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetMCIDeviceName(Vanara.PInvoke.HWND,System.String)">
            <summary>
            The <c>capSetMCIDeviceName</c> macro specifies the name of the MCI video device to be used to capture data. You can use this
            macro or explicitly call the WM_CAP_SET_MCI_DEVICE message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="szName">Pointer to a null-terminated string containing the name of the device.</param>
            <returns>None</returns>
            <remarks>
            This message stores the MCI device name in an internal structure. It does not open or access the device. The default device name
            is <c>NULL</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetScrollPos(Vanara.PInvoke.HWND,Vanara.PInvoke.POINT)">
            <summary>
            The <c>capSetScrollPos</c> macro defines the portion of the video frame to display in the capture window. This message sets the
            upper left corner of the client area of the capture window to the coordinates of a specified pixel within the video frame. You
            can use this macro or explicitly call the WM_CAP_SET_SCROLL message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="lpP">Address to contain the desired scroll position.</param>
            <returns>None</returns>
            <remarks>The scroll position affects the image in both preview and overlay modes.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetUserData(Vanara.PInvoke.HWND,System.IntPtr)">
            <summary>
            The <c>capSetUserData</c> macro associates a <c>LONG_PTR</c> data value with a capture window. You can use this macro or
            explicitly call the WM_CAP_SET_USER_DATA message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="lUser">Data value to associate with a capture window.</param>
            <returns>None</returns>
            <remarks>Typically this message is used to point to a block of data associated with a capture window.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.capSetVideoFormat(Vanara.PInvoke.HWND,Vanara.PInvoke.Gdi32.SafeBITMAPINFO)">
            <summary>
            The <c>capSetVideoFormat</c> macro sets the format of captured video data. You can use this macro or explicitly call the
            WM_CAP_SET_VIDEOFORMAT message.
            </summary>
            <param name="hwnd">Handle to a capture window.</param>
            <param name="s">Pointer to a BITMAPINFO structure.</param>
            <returns>None</returns>
            <remarks>
            Because video formats are device-specific, applications should check the return value from this function to determine if the
            format is accepted by the driver.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.CAPDRIVERCAPS">
            <summary>
            <para>The <c>CAPDRIVERCAPS</c> structure defines the capabilities of the capture driver.</para>
            <para>
            An application should use the WM_CAP_DRIVER_GET_CAPS message or capDriverGetCaps macro to place a copy of the driver
            capabilities in a <c>CAPDRIVERCAPS</c> structure whenever the application connects a capture window to a capture driver.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPDRIVERCAPS.wDeviceIndex">
            <summary>Index of the capture driver. An index value can range from 0 to 9.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPDRIVERCAPS.fHasOverlay">
            <summary>Video-overlay flag. The value of this member is <c>TRUE</c> if the device supports video overlay.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPDRIVERCAPS.fHasDlgVideoSource">
            <summary>
            Video source dialog flag. The value of this member is <c>TRUE</c> if the device supports a dialog box for selecting and
            controlling the video source.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPDRIVERCAPS.fHasDlgVideoFormat">
            <summary>
            Video format dialog flag. The value of this member is <c>TRUE</c> if the device supports a dialog box for selecting the
            video format.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPDRIVERCAPS.fHasDlgVideoDisplay">
            <summary>
            Video display dialog flag. The value of this member is <c>TRUE</c> if the device supports a dialog box for controlling the
            redisplay of video from the capture frame buffer.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPDRIVERCAPS.fCaptureInitialized">
            <summary>
            Capture initialization flag. The value of this member is <c>TRUE</c> if a capture device has been successfully connected.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPDRIVERCAPS.fDriverSuppliesPalettes">
            <summary>Driver palette flag. The value of this member is <c>TRUE</c> if the driver can create palettes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPDRIVERCAPS.hVideoIn">
            <summary>Not used in Win32 applications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPDRIVERCAPS.hVideoOut">
            <summary>Not used in Win32 applications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPDRIVERCAPS.hVideoExtIn">
            <summary>Not used in Win32 applications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPDRIVERCAPS.hVideoExtOut">
            <summary>Not used in Win32 applications.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.CAPINFOCHUNK">
            <summary>
            The <c>CAPINFOCHUNK</c> structure contains parameters that can be used to define an information chunk within an AVI capture
            file. The WM_CAP_FILE_SET_INFOCHUNK message or <c>capSetInfoChunk</c> macro is used to send a <c>CAPINFOCHUNK</c> structure to a
            capture window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPINFOCHUNK.fccInfoID">
            <summary>
            Four-character code that identifies the representation of the chunk data. If this value is <c>NULL</c> and <c>lpData</c> is
            <c>NULL</c>, all accumulated information chunks are deleted.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPINFOCHUNK.lpData">
            <summary>Pointer to the data. If this value is <c>NULL</c>, all <c>fccInfoID</c> information chunks are deleted.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPINFOCHUNK.cbData">
            <summary>
            Size, in bytes, of the data pointed to by <c>lpData</c>. If <c>lpData</c> specifies a null-terminated string, use the string
            length incremented by one to save the <c>NULL</c> with the string.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.CAPSTATUS">
            <summary>The <c>CAPSTATUS</c> structure defines the current state of the capture window.</summary>
            <remarks>
            Because the state of a capture window changes in response to various messages, an application should update the information in
            this structure whenever it needs to enable menu items, determine the actual state of the capture window, or call the video
            format dialog box. If the application yields during streaming capture, this structure returns the progress of the capture in the
            <c>dwCurrentVideoFrame</c>, <c>dwCurrentVideoFramesDropped</c>, dwCurre <c></c> ntWaveSamples, and <c>dwCurrentTimeElapsedMS</c>
            members. Use the WM_CAP_GET_STATUS message or capGetStatus macro to update the contents of this structure.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.uiImageWidth">
            <summary>Image width, in pixels.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.uiImageHeight">
            <summary>Image height, in pixels</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.fLiveWindow">
            <summary>
            Live window flag. The value of this member is <c>TRUE</c> if the window is displaying video using the preview method.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.fOverlayWindow">
            <summary>
            Overlay window flag. The value of this member is <c>TRUE</c> if the window is displaying video using hardware overlay.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.fScale">
            <summary>
            Input scaling flag. The value of this member is <c>TRUE</c> if the window is scaling the input video to the client area when
            displaying video using preview. This parameter has no effect when displaying video using overlay.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.ptScroll">
            <summary>The x- and y-offset of the pixel displayed in the upper left corner of the client area of the window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.fUsingDefaultPalette">
            <summary>Default palette flag. The value of this member is <c>TRUE</c> if the capture driver is using its default palette.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.fAudioHardware">
            <summary>Audio hardware flag. The value of this member is <c>TRUE</c> if the system has waveform-audio hardware installed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.fCapFileExists">
            <summary>Capture file flag. The value of this member is <c>TRUE</c> if a valid capture file has been generated.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.dwCurrentVideoFrame">
            <summary>
            Number of frames processed during the current (or most recent) streaming capture. This count includes dropped frames.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.dwCurrentVideoFramesDropped">
            <summary>
            Number of frames dropped during the current (or most recent) streaming capture. Dropped frames occur when the capture rate
            exceeds the rate at which frames can be saved to file. In this case, the capture driver has no buffers available for storing
            data. Dropping frames does not affect synchronization because the previous frame is displayed in place of the dropped frame.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.dwCurrentWaveSamples">
            <summary>Number of waveform-audio samples processed during the current (or most recent) streaming capture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.dwCurrentTimeElapsedMS">
            <summary>Time, in milliseconds, since the start of the current (or most recent) streaming capture.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.hPalCurrent">
            <summary>Handle to current palette.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.fCapturingNow">
            <summary>Capturing flag. The value of this member is <c>TRUE</c> when capturing is in progress.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.dwReturn">
            <summary>Error return values. Use this member if your application does not support an error callback function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.wNumVideoAllocated">
            <summary>
            Number of video buffers allocated. This value might be less than the number specified in the <c>wNumVideoRequested</c>
            member of the CAPTUREPARMS structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPSTATUS.wNumAudioAllocated">
            <summary>
            Number of audio buffers allocated. This value might be less than the number specified in the <c>wNumAudioRequested</c>
            member of the CAPTUREPARMS structure.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.CAPTUREPARMS">
            <summary>
            The <c>CAPTUREPARMS</c> structure contains parameters that control the streaming video capture process. This structure is used
            to get and set parameters that affect the capture rate, the number of buffers to use while capturing, and how capture is terminated.
            </summary>
            <remarks>
            <para>
            The WM_CAP_GET_SEQUENCE_SETUP message or capCaptureGetSetup macro is used to retrieve the current capture parameters. The
            WM_CAP_SET_SEQUENCE_SETUP message or capCaptureSetSetup macro is used to set the capture parameters.
            </para>
            <para>
            The WM_CAP_GET_SEQUENCE_SETUP message or capCaptureGetSetup macro is used to retrieve the current capture parameters. The
            WM_CAP_SET_SEQUENCE_SETUP message or capCaptureSetSetup macro is used to set the capture parameters.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.dwRequestMicroSecPerFrame">
            <summary>Requested frame rate, in microseconds. The default value is 66667, which corresponds to 15 frames per second.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.fMakeUserHitOKToCapture">
            <summary>
            User-initiated capture flag. If this member is <c>TRUE</c>, AVICap displays a dialog box prompting the user to initiate
            capture. The default value is <c>FALSE</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.wPercentDropForError">
            <summary>
            Maximum allowable percentage of dropped frames during capture. Values range from 0 to 100. The default value is 10.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.fYield">
            <summary>
            <para>
            Yield flag. If this member is <c>TRUE</c>, the capture window spawns a separate background thread to perform step and
            streaming capture. The default value is <c>FALSE</c>.
            </para>
            <para>
            Applications that set this flag must handle potential reentry issues because the controls in the application are not
            disabled while capture is in progress.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.dwIndexSize">
            <summary>
            <para>
            Maximum number of index entries in an AVI file. Values range from 1800 to 324,000. If set to 0, a default value of 34,952
            (32K frames plus a proportional number of audio buffers) is used.
            </para>
            <para>
            Each video frame or buffer of waveform-audio data uses one index entry. The value of this entry establishes a limit for the
            number of frames or audio buffers that can be captured.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.wChunkGranularity">
            <summary>Logical block size, in bytes, of an AVI file. The value 0 indicates the current sector size is used as the granularity.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.fUsingDOSMemory">
            <summary>Not used in Win32 applications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.wNumVideoRequested">
            <summary>
            Maximum number of video buffers to allocate. The memory area to place the buffers is specified with <c>fUsingDOSMemory</c>.
            The actual number of buffers allocated might be lower if memory is unavailable.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.fCaptureAudio">
            <summary>
            Capture audio flag. If this member is <c>TRUE</c>, audio is captured during streaming capture. This is the default value if
            audio hardware is installed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.wNumAudioRequested">
            <summary>Maximum number of audio buffers to allocate. The maximum number of buffers is 10.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.vKeyAbort">
            <summary>
            <para>
            Virtual keycode used to terminate streaming capture. The default value is VK_ESCAPE. You must call the RegisterHotKey
            function before specifying a keystroke that can abort a capture session.
            </para>
            <para>
            You can combine keycodes that include CTRL and SHIFT keystrokes by using the logical OR operator with the keycodes for CTRL
            (0x8000) and SHIFT (0x4000).
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.fAbortLeftMouse">
            <summary>
            Abort flag for left mouse button. If this member is <c>TRUE</c>, streaming capture stops if the left mouse button is
            pressed. The default value is <c>TRUE</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.fAbortRightMouse">
            <summary>
            Abort flag for right mouse button. If this member is <c>TRUE</c>, streaming capture stops if the right mouse button is
            pressed. The default value is <c>TRUE</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.fLimitEnabled">
            <summary>
            Time limit enabled flag. If this member is <c>TRUE</c>, streaming capture stops after the number of seconds in
            <c>wTimeLimit</c> has elapsed. The default value is <c>FALSE</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.wTimeLimit">
            <summary>Time limit for capture, in seconds. This parameter is used only if <c>fLimitEnabled</c> is <c>TRUE</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.fMCIControl">
            <summary>
            MCI device capture flag. If this member is <c>TRUE</c>, AVICap controls an MCI-compatible video source during streaming
            capture. MCI-compatible video sources include VCRs and laserdiscs.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.fStepMCIDevice">
            <summary>
            MCI device step capture flag. If this member is <c>TRUE</c>, step capture using an MCI device as a video source is enabled.
            If it is <c>FALSE</c>, real-time capture using an MCI device is enabled. (If <c>fMCIControl</c> is <c>FALSE</c>, this member
            is ignored.)
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.dwMCIStartTime">
            <summary>
            Starting position, in milliseconds, of the MCI device for the capture sequence. (If <c>fMCIControl</c> is <c>FALSE</c>, this
            member is ignored.)
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.dwMCIStopTime">
            <summary>
            Stopping position, in milliseconds, of the MCI device for the capture sequence. When this position in the content is
            reached, capture ends and the MCI device stops. (If <c>fMCIControl</c> is <c>FALSE</c>, this member is ignored.)
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.fStepCaptureAt2x">
            <summary>
            <para>
            Double-resolution step capture flag. If this member is <c>TRUE</c>, the capture hardware captures at twice the specified
            resolution. (The resolution for the height and width is doubled.)
            </para>
            <para>Enable this option if the hardware does not support hardware-based decimation and you are capturing in the RGB format.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.wStepCaptureAverageFrames">
            <summary>
            Number of times a frame is sampled when creating a frame based on the average sample. A typical value for the number of
            averages is 5.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.dwAudioBufferSize">
            <summary>
            Audio buffer size. If the default value of zero is used, the size of each buffer will be the maximum of 0.5 seconds of audio
            or 10K bytes.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.fDisableWriteCache">
            <summary>Not used in Win32 applications.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.CAPTUREPARMS.AVStreamMaster">
            <summary>
            Indicates whether the audio stream controls the clock when writing an AVI file. If this member is set to
            AVSTREAMMASTER_AUDIO, the audio stream is considered the master stream and the video stream duration is forced to match the
            audio duration. If this member is set to AVSTREAMMASTER_NONE, the durations of audio and video streams can differ.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.VIDEOHDR">
            <summary>The <c>VIDEOHDR</c> structure is used by the capVideoStreamCallback function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VIDEOHDR.lpData">
            <summary>Pointer to locked data buffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VIDEOHDR.dwBufferLength">
            <summary>Length of data buffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VIDEOHDR.dwBytesUsed">
            <summary>Bytes actually used.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VIDEOHDR.dwTimeCaptured">
            <summary>Milliseconds from start of stream.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VIDEOHDR.dwUser">
            <summary>User-defined data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VIDEOHDR.dwFlags">
            <summary>
            <para>The flags are defined as follows.</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>VHDR_DONE</term>
            <term>Done bit</term>
            </item>
            <item>
            <term>VHDR_PREPARED</term>
            <term>Set if this header has been prepared</term>
            </item>
            <item>
            <term>VHDR_INQUEUE</term>
            <term>Reserved for driver</term>
            </item>
            <item>
            <term>VHDR_KEYFRAME</term>
            <term>Key Frame</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VIDEOHDR.dwReserved1">
            <summary>Reserved for driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VIDEOHDR.dwReserved2">
            <summary>Reserved for driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VIDEOHDR.dwReserved3">
            <summary>Reserved for driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.VIDEOHDR.dwReserved4">
            <summary>Reserved for driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWND_END">
            <summary>Seek from the end.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWND_START">
            <summary>Seek from the start.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.MCI">
            <summary>Window messages for MCI functions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_OPEN">
            <summary>
            <para>The MCI_OPEN command initializes a device or file. All devices recognize this command.</para>
            <para>To send this command, call the <c>mciSendCommand</c> function with the following parameters.</para>
            <para>
              <code lang="CPP">MCIERROR mciSendCommand( MCIDEVICEID wDeviceID, MCI_OPEN, DWORD dwFlags, (DWORD) (LPMCI_OPEN_PARMS) lpOpen );</code>
            </para>
            <list>
              <item>
                <term>wDeviceID</term>
                <definition>Device identifier of the MCI device that is to receive the command message.</definition>
              </item>
              <item>
                <term>dwFlags</term>
                <definition>MCI_NOTIFY or MCI_WAIT. For information about these flags, see The Wait, Notify, and Test Flags.</definition>
              </item>
              <item>
                <term>lpOpen</term>
                <definition>Pointer to an <c>MCI_OPEN_PARMS</c> structure. (Devices with extended command sets might replace this structure
            with a device-specific structure.)</definition>
              </item>
              <item>
                <term>Return Value</term>
                <definition>Returns zero if successful or an error otherwise.</definition>
              </item>
            </list>
            </summary>
            <remarks>
            <para>The following additional flags apply to all devices supporting MCI_OPEN:</para>
            <para>MCI_OPEN_ALIAS</para>
            <para>An alias is included in the lpstrAlias member of the structure identified by lpOpen.</para>
            <para>MCI_OPEN_SHAREABLE</para>
            <para>The device or file should be opened as sharable.</para>
            <para>MCI_OPEN_TYPE</para>
            <para>A device type name or constant is included in the lpstrDeviceType member of the structure identified by lpOpen.</para>
            <para>MCI_OPEN_TYPE_ID</para>
            <para>
            The low-order word of the lpstrDeviceType member of the structure identified by lpOpen contains a standard MCI device type
            identifier and the high-order word optionally contains the ordinal index for the device. Use this flag with the
            MCI_OPEN_TYPE flag.
            </para>
            <para>The following additional flags apply to compound devices:</para>
            <para>MCI_OPEN_ELEMENT</para>
            <para>A filename is included in the lpstrElementName member of the structure identified by lpOpen.</para>
            <para>MCI_OPEN_ELEMENT_ID</para>
            <para>
            The lpstrElementName member of the structure identified by lpOpen is interpreted as a DWORD value and has meaning internal
            to the device. Use this flag with the MCI_OPEN_ELEMENT flag.
            </para>
            <para>The following additional flags are used with the digitalvideo device type:</para>
            <para>MCI_DGV_OPEN_NOSTATIC</para>
            <para>
            The device should reduce the number of static (system) colors in the palette. This increases the number of colors available
            for rendering the video stream. This flag applies only to devices that share a palette with Windows.
            </para>
            <para>MCI_DGV_OPEN_PARENT</para>
            <para>The parent window handle is specified in the hWndParent member of the structure identified by lpOpen.</para>
            <para>MCI_DGV_OPEN_WS</para>
            <para>A window style is specified in the dwStyle member of the structure identified by lpOpen.</para>
            <para>MCI_DGV_OPEN_16BIT</para>
            <para>Indicates a preference for 16-bit MCI device support.</para>
            <para>MCI_DGV_OPEN_32BIT</para>
            <para>Indicates a preference for 32-bit MCI device support.</para>
            <para>For digital-video devices, the lpOpen parameter points to an MCI_DGV_OPEN_PARMS structure.</para>
            <para>The following additional flags are used with the overlay device type:</para>
            <para>MCI_OVLY_OPEN_PARENT</para>
            <para>The parent window handle is specified in the hWndParent member of the structure identified by lpOpen.</para>
            <para>MCI_OVLY_OPEN_WS</para>
            <para>
            A window style is specified in the dwStyle member of the structure identified by lpOpen. The dwStyle value specifies the
            style of the window that the driver will create and display if the application does not provide one. The style parameter
            takes an integer that defines the window style. These constants are the same as the standard window styles (such as
            WS_CHILD, WS_OVERLAPPEDWINDOW, or WS_POPUP).
            </para>
            <para>For video-overlay devices, the lpOpen parameter points to an MCI_OVLY_OPEN_PARMS structure.</para>
            <para>The following additional flag is used with the waveaudio device type:</para>
            <para>MCI_WAVE_OPEN_BUFFER</para>
            <para>A buffer length is specified in the dwBufferSeconds member of the structure identified by lpOpen.</para>
            <para>
            For waveform-audio devices, the lpOpen parameter points to an MCI_WAVE_OPEN_PARMS structure. The MCIWAVE driver requires an
            asynchronous waveform-audio device.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_CLOSE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_PLAY">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_SEEK">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_STOP">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_PAUSE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_STEP">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_RECORD">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_SAVE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_CUT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_COPY">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_PASTE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_RESUME">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI.MCI_DELETE">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.MCI_FORMAT">
            <summary>The MCI constant defining the time format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_FORMAT.MCI_FORMAT_MILLISECONDS">
            <summary>Milliseconds</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_FORMAT.MCI_FORMAT_HMS">
            <summary>Hours, minutes, seconds</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_FORMAT.MCI_FORMAT_MSF">
            <summary>Minutes, seconds, frames</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_FORMAT.MCI_FORMAT_FRAMES">
            <summary>Frames</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_FORMAT.MCI_FORMAT_SMPTE_24">
            <summary>SMPTE 24</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_FORMAT.MCI_FORMAT_SMPTE_25">
            <summary>SMPTE 25</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_FORMAT.MCI_FORMAT_SMPTE_30">
            <summary>SMPTE 30 drop</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_FORMAT.MCI_FORMAT_SMPTE_30DROP">
            <summary>SMPTE 30 non-drop</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_FORMAT.MCI_FORMAT_BYTES">
            <summary>Bytes</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_FORMAT.MCI_FORMAT_SAMPLES">
            <summary>Samples</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_FORMAT.MCI_FORMAT_TMSF">
            <summary>Tracks, minutes, seconds, frames</summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.MCI_MODE">
            <summary>An integer corresponding to the MCI constant defining the mode.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_MODE.MCI_MODE_NOT_READY">
            <summary>Not ready</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_MODE.MCI_MODE_STOP">
            <summary>Stopped</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_MODE.MCI_MODE_PLAY">
            <summary>Playing</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_MODE.MCI_MODE_RECORD">
            <summary>Recording</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_MODE.MCI_MODE_SEEK">
            <summary>Seeking</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_MODE.MCI_MODE_PAUSE">
            <summary>Paused</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCI_MODE.MCI_MODE_OPEN">
            <summary>Open</summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.MCIMessage">
            <summary>Window messages for MCI functions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETDEVICEID">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETSTART">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETLENGTH">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETEND">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_EJECT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SETZOOM">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETZOOM">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SETVOLUME">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETVOLUME">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SETSPEED">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETSPEED">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SETREPEAT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETREPEAT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_REALIZE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_VALIDATEMEDIA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_PLAYFROM">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_PLAYTO">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETPALETTE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SETPALETTE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SETTIMERS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SETACTIVETIMER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SETINACTIVETIMER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETACTIVETIMER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETINACTIVETIMER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_CHANGESTYLES">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETSTYLES">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETALIAS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_PLAYREVERSE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GET_SOURCE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_PUT_SOURCE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GET_DEST">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_PUT_DEST">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_CAN_PLAY">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_CAN_WINDOW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_CAN_RECORD">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_CAN_SAVE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_CAN_EJECT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_CAN_CONFIG">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_PALETTEKICK">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_OPENINTERFACE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SETOWNER">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SENDSTRINGA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETPOSITIONA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETMODEA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SETTIMEFORMATA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETTIMEFORMATA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETFILENAMEA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETDEVICEA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETERRORA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_NEWA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_RETURNSTRINGA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_OPENA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SENDSTRINGW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETPOSITIONW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETMODEW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SETTIMEFORMATW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETTIMEFORMATW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETFILENAMEW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETDEVICEW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETERRORW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_NEWW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_RETURNSTRINGW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_OPENW">
            <summary>map defaults to A or W depending on app's UNICODE setting</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SENDSTRING">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETPOSITION">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETMODE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_SETTIMEFORMAT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETTIMEFORMAT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETFILENAME">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETDEVICE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_GETERROR">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_NEW">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_RETURNSTRING">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIMessage.MCIWNDM_OPEN">
            <summary></summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.MCIWNDF">
            <summary>
            Flags defining the window style. In addition to specifying the window styles used with the <see
            cref="M:Vanara.PInvoke.User32.CreateWindowEx(Vanara.PInvoke.User32.WindowStylesEx,System.IntPtr,System.String,Vanara.PInvoke.User32.WindowStyles,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.HWND,Vanara.PInvoke.HMENU,Vanara.PInvoke.HINSTANCE,System.IntPtr)"/> function, you can specify the following styles to use with MCIWnd windows.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOAUTOSIZEWINDOW">
            <summary>Will not change the dimensions of an MCIWnd window when the image size changes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOPLAYBAR">
            <summary>Hides the toolbar from view and prohibits users from accessing it.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOAUTOSIZEMOVIE">
            <summary>Will not change the dimensions of the destination rectangle when an MCIWnd window size changes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOMENU">
            <summary>Hides the Menu button from view on the toolbar and prohibits users from accessing its pop-up menu.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_SHOWNAME">
            <summary>Displays the name of the open MCI device or data file in the MCIWnd window title bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_SHOWPOS">
            <summary>Displays the current position within the content of the MCI device in the window title bar.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_SHOWMODE">
            <summary>
            Displays the current mode of the MCI device in the window title bar. For a list of device modes, see the MCIWndGetMode macro.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_SHOWALL">
            <summary>Causes all MCIWNDF_SHOW styles to be used.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOTIFYMODE">
            <summary>
            Causes MCIWnd to notify the parent window with an MCIMessage.MCIWNDM_NOTIFYMODE message whenever the device changes
            operating modes. The lParam parameter of this message identifies the new mode, such as MCI_MODE_STOP.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOTIFYPOS">
            <summary>
            Causes MCIWnd to notify the parent window with an MCIMessage.MCIWNDM_NOTIFYPOS message whenever a change in the playback or
            record position within the content occurs. The lParam parameter of this message contains the new position in the content.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOTIFYSIZE">
            <summary>Causes MCIWnd to notify the parent window when the MCIWnd window size changes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOTIFYERROR">
            <summary>Causes MCIWnd to notify the parent window when an MCI error occurs.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOTIFYALL">
            <summary>Causes all MCIWNDF window notification styles to be used.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOTIFYANSI">
            <summary>
            Causes MCIWnd to use an ANSI string instead of a Unicode string when notifying the parent window of device mode changes.
            This flag is used in combination with MCIWNDF_NOTIFYMODE.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOTIFYMEDIAA">
            <summary>
            Causes MCIWnd to notify the parent window with an MCIMessage.MCIWNDM_NOTIFYMEDIA message whenever a new device is used or a
            data file is opened or closed. The lParam parameter of this message contains a pointer to the new file name.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOTIFYMEDIAW">
            <summary>
            Causes MCIWnd to notify the parent window with an MCIMessage.MCIWNDM_NOTIFYMEDIA message whenever a new device is used or a
            data file is opened or closed. The lParam parameter of this message contains a pointer to the new file name.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOTIFYMEDIA">
            <summary>
            Causes MCIWnd to notify the parent window with an MCIMessage.MCIWNDM_NOTIFYMEDIA message whenever a new device is used or a
            data file is opened or closed. The lParam parameter of this message contains a pointer to the new file name.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_RECORD">
            <summary>
            Adds a Record button to the toolbar and adds a new file command to the menu if the MCI device has recording capability.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOERRORDLG">
            <summary>Inhibits display of MCI errors to users.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDF.MCIWNDF_NOOPEN">
            <summary>
            Hides the open and close commands from the MCIWnd menu and prohibits users from accessing these choices in the pop-up menu.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Vfw32.MCIWNDOPENF">
            <summary>Flags associated with the device or file to open.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Vfw32.MCIWNDOPENF.MCIWNDOPENF_NEW">
            <summary>Specifies a new file is to be created with the name specified in szFile.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndCanConfig(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndCanConfig</c> macro determines if an MCI device can display a configuration dialog box. You can use this macro or
            explicitly send the MCIWNDM_CAN_CONFIG message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndCanEject(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndCanEject</c> macro determines if an MCI device can eject its media. You can use this macro or explicitly send the
            MCIWNDM_CAN_EJECT message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndCanPlay(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndCanPlay</c> macro determines if an MCI device can play a data file or content of some other kind. You can use this
            macro or explicitly send the MCIWNDM_CAN_PLAY message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndCanRecord(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndCanRecord</c> macro determines if an MCI device supports recording. You can use this macro or explicitly send the
            MCIWNDM_CAN_RECORD message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndCanSave(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndCanSave</c> macro determines if an MCI device can save data. You can use this macro or explicitly send the
            MCIWNDM_CAN_SAVE message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndCanWindow(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndCanWindow</c> macro determines if an MCI device supports window-oriented MCI commands. You can use this macro or
            explicitly send the MCIWNDM_CAN_WINDOW message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndChangeStyles(Vanara.PInvoke.HWND,Vanara.PInvoke.Vfw32.MCIWNDF,System.Int32)">
            <summary>
            The <c>MCIWndChangeStyles</c> macro changes the styles used by the MCIWnd window. You can use this macro or explicitly send the
            MCIWNDM_CHANGESTYLES message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="mask">
            Mask that identifies the styles that can change. This mask is the bitwise OR operator of all styles that will be permitted to change.
            </param>
            <param name="value">
            New style settings for the window. Specify zero for this parameter to turn off all styles identified in the mask. For a list of
            the available styles, see the MCIWndCreate function.
            </param>
            <returns>None</returns>
            <remarks>For an example of using <c>MCIWndChangeStyles</c>, see Pausing and Resuming Playback.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndClose(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndClose</c> macro closes an MCI device or file associated with an MCIWnd window. Although the MCI device closes, the
            MCIWnd window is still open and can be associated with another MCI device. You can use this macro or explicitly send the
            MCI_CLOSE command.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndCreate(Vanara.PInvoke.HWND,Vanara.PInvoke.HINSTANCE,Vanara.PInvoke.Vfw32.MCIWNDF,System.String)">
            <summary>
            The <c>MCIWndCreate</c> function registers the MCIWnd window class and creates an MCIWnd window for using MCI services.
            <c>MCIWndCreate</c> can also open an MCI device or file (such as an AVI file) and associate it with the MCIWnd window.
            </summary>
            <param name="hwndParent">Handle to the parent window.</param>
            <param name="hInstance">Handle to the module instance to associate with the MCIWnd window.</param>
            <param name="dwStyle">
            <para>
            Flags defining the window style. In addition to specifying the window styles used with the CreateWindowEx function, you can
            specify the following styles to use with MCIWnd windows.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MCIWNDF_NOAUTOSIZEWINDOW</term>
            <term>Will not change the dimensions of an MCIWnd window when the image size changes.</term>
            </item>
            <item>
            <term>MCIWNDF_NOAUTOSIZEMOVIE</term>
            <term>Will not change the dimensions of the destination rectangle when an MCIWnd window size changes.</term>
            </item>
            <item>
            <term>MCIWNDF_NOERRORDLG</term>
            <term>Inhibits display of MCI errors to users.</term>
            </item>
            <item>
            <term>MCIWNDF_NOMENU</term>
            <term>Hides the Menu button from view on the toolbar and prohibits users from accessing its pop-up menu.</term>
            </item>
            <item>
            <term>MCIWNDF_NOOPEN</term>
            <term>
            Hides the open and close commands from the MCIWnd menu and prohibits users from accessing these choices in the pop-up menu.
            </term>
            </item>
            <item>
            <term>MCIWNDF_NOPLAYBAR</term>
            <term>Hides the toolbar from view and prohibits users from accessing it.</term>
            </item>
            <item>
            <term>MCIWNDF_NOTIFYANSI</term>
            <term>
            Causes MCIWnd to use an ANSI string instead of a Unicode string when notifying the parent window of device mode changes. This
            flag is used in combination with MCIWNDF_NOTIFYMODE.
            </term>
            </item>
            <item>
            <term>MCIWNDF_NOTIFYMODE</term>
            <term>
            Causes MCIWnd to notify the parent window with an MCIMessage.MCIWNDM_NOTIFYMODE message whenever the device changes operating
            modes. The lParam parameter of this message identifies the new mode, such as MCI_MODE_STOP.
            </term>
            </item>
            <item>
            <term>MCIWNDF_NOTIFYPOS</term>
            <term>
            Causes MCIWnd to notify the parent window with an MCIMessage.MCIWNDM_NOTIFYPOS message whenever a change in the playback or
            record position within the content occurs. The lParam parameter of this message contains the new position in the content.
            </term>
            </item>
            <item>
            <term>MCIWNDF_NOTIFYMEDIA</term>
            <term>
            Causes MCIWnd to notify the parent window with an MCIMessage.MCIWNDM_NOTIFYMEDIA message whenever a new device is used or a data
            file is opened or closed. The lParam parameter of this message contains a pointer to the new file name.
            </term>
            </item>
            <item>
            <term>MCIWNDF_NOTIFYSIZE</term>
            <term>Causes MCIWnd to notify the parent window when the MCIWnd window size changes.</term>
            </item>
            <item>
            <term>MCIWNDF_NOTIFYERROR</term>
            <term>Causes MCIWnd to notify the parent window when an MCI error occurs.</term>
            </item>
            <item>
            <term>MCIWNDF_NOTIFYALL</term>
            <term>Causes all MCIWNDF window notification styles to be used.</term>
            </item>
            <item>
            <term>MCIWNDF_RECORD</term>
            <term>Adds a Record button to the toolbar and adds a new file command to the menu if the MCI device has recording capability.</term>
            </item>
            <item>
            <term>MCIWNDF_SHOWALL</term>
            <term>Causes all MCIWNDF_SHOW styles to be used.</term>
            </item>
            <item>
            <term>MCIWNDF_SHOWMODE</term>
            <term>
            Displays the current mode of the MCI device in the window title bar. For a list of device modes, see the MCIWndGetMode macro.
            </term>
            </item>
            <item>
            <term>MCIWNDF_SHOWNAME</term>
            <term>Displays the name of the open MCI device or data file in the MCIWnd window title bar.</term>
            </item>
            <item>
            <term>MCIWNDF_SHOWPOS</term>
            <term>Displays the current position within the content of the MCI device in the window title bar.</term>
            </item>
            </list>
            </param>
            <param name="szFile">Null-terminated string indicating the name of an MCI device or data file to open.</param>
            <returns>Returns the handle to an MCI window if successful or zero otherwise.</returns>
            <remarks>
            <para>
            Default window styles for a child window are WS_CHILD, WS_BORDER, and WS_VISIBLE. <c>MCIWndCreate</c> assumes a child window
            when a non- <c>NULL</c> handle of a parent window is specified.
            </para>
            <para>
            Default window styles for a parent window are WS_OVERLAPPEDWINDOW and WS_VISIBLE. <c>MCIWndCreate</c> assumes a parent window
            when a <c>NULL</c> handle of a parent window is specified.
            </para>
            <para>
            Use the window handle returned by this function for the window handle in the MCIWnd macros. If your application uses this
            function, it does not need to use the MCIWndRegisterClass function.
            </para>
            <para>
            <para>Note</para>
            <para>
            The vfw.h header defines MCIWndCreate as an alias which automatically selects the ANSI or Unicode version of this function based
            on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
            encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions for
            Function Prototypes.
            </para>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndDestroy(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndDestroy</c> macro closes an MCI device or file associated with an MCIWnd window and destroys the window. You can
            use this macro or explicitly send the WM_CLOSE message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndEject(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndEject</c> macro sends a command to an MCI device to eject its media. You can use this macro or explicitly send the
            MCIWNDM_EJECT message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndEnd(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndEnd</c> macro moves the current position to the end of the content. You can use this macro or explicitly send the
            MCI_SEEK message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetActiveTimer(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetActiveTimer</c> macro retrieves the update period used when the MCIWnd window is the active window. You can use
            this macro or explicitly send the MCIWNDM_GETACTIVETIMER message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetAlias(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetAlias</c> macro retrieves the alias used to open an MCI device or file with the mciSendString function. You can
            use this macro or explicitly send the MCIWNDM_GETALIAS message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetDest(Vanara.PInvoke.HWND,Vanara.PInvoke.RECT@)">
            <summary>
            The <c>MCIWndGetDest</c> macro retrieves the coordinates of the destination rectangle used for zooming or stretching the images
            of an AVI file during playback. You can use this macro or explicitly send the MCIWNDM_GET_DEST message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="prc">Pointer to a RECT structure to return the coordinates of the destination rectangle.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetDevice(Vanara.PInvoke.HWND,System.Text.StringBuilder)">
            <summary>
            The <c>MCIWndGetDevice</c> macro retrieves the name of the current MCI device. You can use this macro or explicitly send the
            MCIWNDM_GETDEVICE message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lp">Pointer to an application-defined buffer to return the device name.</param>
            <returns>None</returns>
            <remarks>If the null-terminated string containing the device name is longer than the buffer, MCIWnd truncates it.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetDeviceID(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetDeviceID</c> macro retrieves the identifier of the current MCI device to use with the mciSendCommand function.
            You can use this macro or explicitly send the MCIWNDM_GETDEVICEID message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetEnd(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetEnd</c> macro retrieves the location of the end of the content of an MCI device or file. You can use this macro
            or explicitly send the MCIWNDM_GETEND message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetError(Vanara.PInvoke.HWND,System.Text.StringBuilder)">
            <summary>
            The <c>MCIWndGetError</c> macro retrieves the last MCI error encountered. You can use this macro or explicitly send the
            MCIWNDM_GETERROR message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lp">Pointer to an application-defined buffer used to return the error string.</param>
            <returns>None</returns>
            <remarks>
            If lp is a valid pointer, a null-terminated string corresponding to the error is returned in its buffer. If the error string is
            longer than the buffer, MCIWnd truncates it.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetFileName(Vanara.PInvoke.HWND,System.Text.StringBuilder)">
            <summary>
            The <c>MCIWndGetFileName</c> macro retrieves the filename used by an MCI device. You can use this macro or explicitly send the
            MCIWNDM_GETFILENAME message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lp">Pointer to an application-defined buffer to return the filename.</param>
            <returns>None</returns>
            <remarks>If the null-terminated string containing the filename is longer than the buffer, MCIWnd truncates the filename.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetInactiveTimer(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetInactiveTimer</c> macro retrieves the update period used when the MCIWnd window is the inactive window. You can
            use this macro or explicitly send the MCIWNDM_GETINACTIVETIMER message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetLength(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetLength</c> macro retrieves the length of the content or file currently used by an MCI device. You can use this
            macro or explicitly send the MCIWNDM_GETLENGTH message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
            <remarks>This value added to the value returned for the MCIWndGetStart macro equals the end of the content.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetMode(Vanara.PInvoke.HWND,System.Text.StringBuilder)">
            <summary>
            The <c>MCIWndGetMode</c> macro retrieves the current operating mode of an MCI device. MCI devices have several operating modes,
            which are designated by constants. You can use this macro or explicitly send the MCIWNDM_GETMODE message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lp">Pointer to the application-defined buffer used to return the mode.</param>
            <returns>None</returns>
            <remarks>
            <para>If the null-terminated string describing the mode is longer than the buffer, it is truncated.</para>
            <para>
            Not all devices can operate in every mode. For example, the MCIAVI device is a playback device; it doesn't support the recording
            mode. The following modes can be retrieved by using MCIWNDM_GETMODE:
            </para>
            <list type="table">
            <listheader>
            <term>Operating mode</term>
            <term>MCI constant</term>
            </listheader>
            <item>
            <term>not ready</term>
            <term>MCI_MODE_NOT_READY</term>
            </item>
            <item>
            <term>open</term>
            <term>MCI_MODE_OPEN</term>
            </item>
            <item>
            <term>paused</term>
            <term>MCI_MODE_PAUSE</term>
            </item>
            <item>
            <term>playing</term>
            <term>MCI_MODE_PLAY</term>
            </item>
            <item>
            <term>recording</term>
            <term>MCI_MODE_RECORD</term>
            </item>
            <item>
            <term>seeking</term>
            <term>MCI_MODE_SEEK</term>
            </item>
            <item>
            <term>stopped</term>
            <term>MCI_MODE_STOP</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetPalette(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetPalette</c> macro retrieves a handle of the palette used by an MCI device. You can use this macro or explicitly
            send the MCIWNDM_GETPALETTE message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetPosition(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetPosition</c> macro retrieves the numerical value of the current position within the content of the MCI device.
            You can use this macro or explicitly send the MCIWNDM_GETPOSITION message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetPositionString(Vanara.PInvoke.HWND,System.Text.StringBuilder)">
            <summary>
            The <c>MCIWndGetPositionString</c> macro retrieves the numerical value of the current position within the content of the MCI
            device. This macro also provides the current position in string form in an application-defined buffer. You can use this macro or
            explicitly send the MCIWNDM_GETPOSITION message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lp">
            Pointer to an application-defined buffer used to return the position. Use zero to inhibit retrieval of the position as a string.
            If the device supports tracks, the string position information is returned in the form TT:MM:SS:FF where TT corresponds to
            tracks, MM and SS correspond to minutes and seconds, and FF corresponds to frames.
            </param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetRepeat(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetRepeat</c> macro determines if continuous playback has been activated. You can use this macro or explicitly send
            the MCIWNDM_GETREPEAT message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetSource(Vanara.PInvoke.HWND,Vanara.PInvoke.RECT@)">
            <summary>
            The <c>MCIWndGetSource</c> macro retrieves the coordinates of the source rectangle used for cropping the images of an AVI file
            during playback. You can use this macro or explicitly send the MCIWNDM_GET_SOURCE message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="prc">Pointer to a RECT structure to contain the coordinates of the source rectangle.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetSpeed(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetSpeed</c> macro retrieves the playback speed of an MCI device. You can use this macro or explicitly send the
            MCIWNDM_GETSPEED message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetStart(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetStart</c> macro retrieves the location of the beginning of the content of an MCI device or file. You can use
            this macro or explicitly send the MCIWNDM_GETSTART message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetStyles(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetStyles</c> macro retrieves the flags specifying the current MCIWnd window styles used by a window. You can use
            this macro or explicitly send the MCIWNDM_GETSTYLES message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetTimeFormat(Vanara.PInvoke.HWND,System.Text.StringBuilder)">
            <summary>
            The <c>MCIWndGetTimeFormat</c> macro retrieves the current time format of an MCI device in two forms: as a numerical value and
            as a string. You can use this macro or explicitly send the MCIWNDM_GETTIMEFORMAT message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lp">Pointer to a buffer to contain the null-terminated string form of the time format.</param>
            <returns>None</returns>
            <remarks>
            <para>If the time format string is longer than the return buffer, MCIWnd truncates the string.</para>
            <para>An MCI device can support one or more of the following time formats:</para>
            <list type="table">
            <listheader>
            <term>Time format</term>
            <term>MCI constant</term>
            </listheader>
            <item>
            <term>Bytes</term>
            <term>MCI_FORMAT_BYTES</term>
            </item>
            <item>
            <term>Frames</term>
            <term>MCI_FORMAT_FRAMES</term>
            </item>
            <item>
            <term>Hours, minutes, seconds</term>
            <term>MCI_FORMAT_HMS</term>
            </item>
            <item>
            <term>Milliseconds</term>
            <term>MCI_FORMAT_MILLISECONDS</term>
            </item>
            <item>
            <term>Minutes, seconds, frames</term>
            <term>MCI_FORMAT_MSF</term>
            </item>
            <item>
            <term>Samples</term>
            <term>MCI_FORMAT_SAMPLES</term>
            </item>
            <item>
            <term>SMPTE 24</term>
            <term>MCI_FORMAT_SMPTE_24</term>
            </item>
            <item>
            <term>SMPTE 25</term>
            <term>MCI_FORMAT_SMPTE_25</term>
            </item>
            <item>
            <term>SMPTE 30 drop</term>
            <term>MCI_FORMAT_SMPTE_30DROP</term>
            </item>
            <item>
            <term>SMPTE 30 (non-drop)</term>
            <term>MCI_FORMAT_SMPTE_30</term>
            </item>
            <item>
            <term>Tracks, minutes, seconds, frames</term>
            <term>MCI_FORMAT_TMSF</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetVolume(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetVolume</c> macro retrieves the current volume setting of an MCI device. You can use this macro or explicitly
            send the MCIWNDM_GETVOLUME message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndGetZoom(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndGetZoom</c> macro retrieves the current zoom value used by an MCI device. You can use this macro or explicitly send
            the MCIWNDM_GETZOOM message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndHome(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndHome</c> macro moves the current position to the beginning of the content. You can use this macro or explicitly
            send the MCI_SEEK command.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndNew(Vanara.PInvoke.HWND,System.String)">
            <summary>
            The <c>MCIWndNew</c> macro creates a new file for the current MCI device. You can use this macro or explicitly send the
            MCIWNDM_NEW message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lp">Pointer to a buffer containing the name of the MCI device that will use the file.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndOpen(Vanara.PInvoke.HWND,System.String,Vanara.PInvoke.Vfw32.MCIWNDOPENF)">
            <summary>
            The <c>MCIWndOpen</c> macro opens an MCI device and associates it with an MCIWnd window. For MCI devices that use data files,
            this macro can also open a specified data file, name a new file to be created, or display a dialog box to let the user select a
            file to open. You can use this macro or explicitly send the MCIWNDM_OPEN message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="sz">
            Pointer to a null-terminated string identifying the filename or MCI Device Names to open. Specify ?1 for this parameter to
            display the Open dialog box.
            </param>
            <param name="f">
            Flags associated with the device or file to open. The MCIWNDOPENF_NEW flag specifies a new file is to be created with the name
            specified in szFile.
            </param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndOpenDialog(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndOpenDialog</c> macro opens a user-specified data file and corresponding type of MCI device, and associates them
            with an MCIWnd window. This macro displays the Open dialog box for the user to select the data file to associate with an MCI
            window. You can use this macro or explicitly send the MCIWNDM_OPEN message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndOpenInterface(Vanara.PInvoke.HWND,System.Object)">
            <summary>
            The <c>MCIWndOpenInterface</c> macro attaches the data stream or file associated with the specified interface to an MCIWnd
            window. You can use this macro or explicitly send the MCIWNDM_OPENINTERFACE message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="pUnk">Pointer to an IAVI interface that points to a file or a data stream in a file.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndPaletteKick(Vanara.PInvoke.HWND)">
            <summary>Undocumented.</summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndPause(Vanara.PInvoke.HWND)">
            <summary>The <c>MCIWndPause</c> macro sends a command to an MCI device to pause playing or recording.</summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndPlay(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndPlay</c> macro sends a command to an MCI device to start playing from the current position in the content. You can
            use this macro or explicitly send the MCI_PLAY command.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndPlayFrom(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            The <c>MCIWndPlayFrom</c> macro plays the content of an MCI device from the specified location to the end of the content or
            until another command stops playback. You can use this macro or explicitly send the MCIWNDM_PLAYFROM message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lPos">Starting location. The units for the starting location depend on the current time format.</param>
            <returns>None</returns>
            <remarks>You can also specify both a starting and ending location for playback by using the MCIWndPlayFromTo macro.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndPlayFromTo(Vanara.PInvoke.HWND,System.Int32,System.Int32)">
            <summary>
            The <c>MCIWndPlayFromTo</c> macro plays a portion of content between specified starting and ending locations. This macro seeks
            to the specified point to begin playback, then plays the content to the specified ending location. This macro is defined using
            the MCIWndSeek and MCIWndPlayTo macros, which in turn use the MCI_SEEK command and the MCIWNDM_PLAYTO message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lStart">Position to seek; it is also the starting location.</param>
            <param name="lEnd">Ending location.</param>
            <returns>None</returns>
            <remarks>The units for the seek position depend on the current time format.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndPlayReverse(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndPlayReverse</c> macro plays the current content in the reverse direction, beginning at the current position and
            ending at the beginning of the content or until another command stops playback. You can use this macro or explicitly send the
            MCIWNDM_PLAYREVERSE message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndPlayTo(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            The <c>MCIWndPlayTo</c> macro plays the content of an MCI device from the current position to the specified ending location or
            until another command stops playback. If the specified ending location is beyond the end of the content, playback stops at the
            end of the content. You can use this macro or explicitly send the MCIWNDM_PLAYTO message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lPos">Ending location. The units for the ending location depend on the current time format.</param>
            <returns>None</returns>
            <remarks>You can also specify both a starting and ending location for playback by using the MCIWndPlayFromTo macro.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndPutDest(Vanara.PInvoke.HWND,Vanara.PInvoke.RECT@)">
            <summary>
            The <c>MCIWndPutDest</c> macro redefines the coordinates of the destination rectangle used for zooming or stretching the images
            of an AVI file during playback. You can use this macro or explicitly send the MCIWNDM_PUT_DEST message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="prc">Pointer to a RECT structure containing the coordinates of the destination rectangle.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndPutSource(Vanara.PInvoke.HWND,Vanara.PInvoke.RECT@)">
            <summary>
            The <c>MCIWndPutSource</c> macro redefines the coordinates of the source rectangle used for cropping the images of an AVI file
            during playback. You can use this macro or explicitly send the MCIWNDM_PUT_SOURCE message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="prc">Pointer to a RECT structure containing the coordinates of the source rectangle.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndRealize(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            The <c>MCIWndRealize</c> macro controls how an MCI window realized in the foreground or background. This macro also causes the
            palette for the MCI window to be realized in the process. You can use this macro or explicitly send the MCIWNDM_REALIZE message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="fBkgnd">
            Background flag. Specify <c>TRUE</c> for this parameter for the window to be realized in the background or <c>FALSE</c> if the
            window can be realized in the foreground.
            </param>
            <returns>None</returns>
            <remarks>
            <para>
            A common use for <c>MCIWndRealize</c> is to coordinate palette ownership between an MCI control and the application that
            contains it. The application can have the MCI window realize in the background and realize its own palette in the foreground.
            </para>
            <para>
            If your application contains an MCI control, but does not need to realize its palette, you can use this macro to handle the
            WM_PALETTECHANGED and WM_QUERYNEWPALETTE messages, instead of using <c>RealizePalette</c>. However, it is usually easier to call
            the <c>SendMessage</c> function to forward the message to the MCIWnd window, which will automatically realize the palette.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndRecord(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndRecord</c> macro begins recording content using the MCI device. The recording process begins at the current
            position in the content and will overwrite existing data for the duration of the recording.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
            <remarks>
            The function that an MCI device performs during recording depends on the characteristics of the device. An MCI device that uses
            files, such as a waveform-audio device, sends data to the file during recording. An MCI device that does not use files, such as
            a video-cassette recorder, receives and externally records data on another medium.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndRegisterClass">
            <summary>The <c>MCIWndRegisterClass</c> function registers the MCI window class MCIWND_WINDOW_CLASS.</summary>
            <returns>Returns zero if successful.</returns>
            <remarks>
            After registering the MCI window class, use the <c>CreateWindow</c> or <c>CreateWindowEx</c> functions to create an MCIWnd
            window. If your application uses this function, it does not need to use the MCIWndCreate function.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndResume(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndResume</c> macro resumes playback or recording content from the paused mode. This macro restarts playback or
            recording from the current position in the content. You can use this macro or explicitly send the MCI_RESUME command.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndReturnString(Vanara.PInvoke.HWND,System.Text.StringBuilder)">
            <summary>
            The <c>MCIWndReturnString</c> macro retrieves the reply to the most recent MCI string command sent to an MCI device. Information
            in the reply is supplied as a null-terminated string. You can use this macro or explicitly send the MCIWNDM_RETURNSTRING message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lp">Pointer to an application-defined buffer to contain the null-terminated string.</param>
            <returns>None</returns>
            <remarks>If the null-terminated string is longer than the buffer, the string is truncated.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSave(Vanara.PInvoke.HWND,System.String)">
            <summary>
            The <c>MCIWndSave</c> macro saves the content currently used by an MCI device. This macro can save the content to a specified
            data file or display the Save dialog box to let the user select a filename to store the content. You can use this macro or
            explicitly send the MCI_SAVE command.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="szFile">
            Null-terminated string containing the name and path of the destination file. Specify ?1 for this parameter to display the Save
            dialog box.
            </param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSaveDialog(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndSaveDialog</c> macro saves the content currently used by an MCI device. This macro displays the Save dialog box to
            let the user select a filename to store the content. You can use this macro or explicitly send the MCI_SAVE command.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSaveWithDialog(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndSave</c> macro saves the content currently used by an MCI device. This macro can save the content to a specified
            data file or display the Save dialog box to let the user select a filename to store the content. You can use this macro or
            explicitly send the MCI_SAVE command.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSeek(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            The <c>MCIWndSeek</c> macro moves the playback position to the specified location in the content. You can use this macro or
            explicitly use the MCI_SEEK command.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lPos">
            Position to seek. You can specify a position using the current time format, the MCIWND_START constant to designate the beginning
            of the content, or the MCIWND_END constant to designate the end of the content.
            </param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSendString(Vanara.PInvoke.HWND,System.String)">
            <summary>
            The <c>MCIWndSendString</c> macro sends an MCI command in string form to the device associated with the MCIWnd window. You can
            use this macro or explicitly send the MCIWNDM_SENDSTRING message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="sz">String command to send to the MCI device.</param>
            <returns>None</returns>
            <remarks>
            <para>
            The message handler for <c>MCIWndSendString</c> (and <c>MCIWNDM_SENDSTRING</c>) appends a device alias to the MCI command you
            send to the device. Therefore, you should not use any alias in an MCI command that you issue with <c>MCIWndSendString</c>.
            </para>
            <para>To get the return string, which contains the result of the command, use the MCIWndReturnString macro.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSetActiveTimer(Vanara.PInvoke.HWND,System.UInt32)">
            <summary>
            The <c>MCIWndSetActiveTimer</c> macro sets the update period used by MCIWnd to update the trackbar in the MCIWnd window, update
            position information displayed in the window title bar, and send notification messages to the parent window when the MCIWnd
            window is active. You can use this macro or explicitly send the MCIWNDM_SETACTIVETIMER message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="active">Update period, in milliseconds. The default is 500 milliseconds.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSetInactiveTimer(Vanara.PInvoke.HWND,System.UInt32)">
            <summary>
            The <c>MCIWndSetInactiveTimer</c> macro sets the update period used by MCIWnd to update the trackbar in the MCIWnd window,
            update position information displayed in the window title bar, and send notification messages to the parent window when the
            MCIWnd window is inactive. You can use this macro or explicitly send the MCIWNDM_SETINACTIVETIMER message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="inactive">Update period, in milliseconds. The default is 2000 milliseconds.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSetOwner(Vanara.PInvoke.HWND,Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndSetOwner</c> macro sets the window to receive notification messages associated with the MCIWnd window. You can use
            this macro or explicitly send the MCIWNDM_SETOWNER message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="hwndP">Handle of the window to receive the notification messages.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSetPalette(Vanara.PInvoke.HWND,Vanara.PInvoke.HPALETTE)">
            <summary>
            The <c>MCIWndSetPalette</c> macro sends a palette handle to the MCI device associated with the MCIWnd window. You can use this
            macro or explicitly send the MCIWNDM_SETPALETTE message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="hpal">Palette handle.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSetRepeat(Vanara.PInvoke.HWND,System.Boolean)">
            <summary>
            The <c>MCIWndSetRepeat</c> macro sets the repeat flag associated with continuous playback. You can use this macro or explicitly
            send the MCIWNDM_SETREPEAT message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="f">New state of the repeat flag. Specify <c>TRUE</c> to turn on continuous playback.</param>
            <returns>None</returns>
            <remarks>
            <para>
            The <c>MCIWndSetRepeat</c> macro only affects playback that the user initiates by hitting the play button on the toolbar. It
            will not affect playback started with the <c>MCIWndPlay</c> macro.
            </para>
            <para>Currently, MCIAVI is the only device that supports continuous playback.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSetSpeed(Vanara.PInvoke.HWND,System.UInt32)">
            <summary>
            The <c>MCIWndSetSpeed</c> macro sets the playback speed of an MCI device. You can use this macro or explicitly send the
            MCIWNDM_SETSPEED message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="iSpeed">
            Playback speed. Specify 1000 for normal speed, larger values for faster speeds, and smaller values for slower speeds.
            </param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSetTimeFormat(Vanara.PInvoke.HWND,System.String)">
            <summary>
            The <c>MCIWndSetTimeFormat</c> macro sets the time format of an MCI device. You can use this macro or explicitly send the
            MCIWNDM_SETTIMEFORMAT message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="lp">
            Pointer to a buffer containing the null-terminated string indicating the time format. Specify "frames" to set the time format to
            frames, or "ms" to set the time format to milliseconds.
            </param>
            <returns>None</returns>
            <remarks>
            <para>
            An application can specify time formats other than frames or milliseconds as long as the formats are supported by the MCI
            device. Noncontinuous formats, such as tracks and SMPTE, can cause the trackbar to behave erratically. For these time formats,
            you might want to turn off the toolbar by using the MCIWndChangeStyles macro and specifying the MCIWNDF_NOPLAYBAR window style.
            </para>
            <para>
            If you want to set the time format to frames or milliseconds, you can also use the <c>MCIWndUseFrames</c> or
            <c>MCIWndUseTime</c> macro. For a list of time formats, see the <c>MCIWndGetTimeFormat</c> macro.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSetTimers(Vanara.PInvoke.HWND,System.UInt32,System.UInt32)">
            <summary>
            The <c>MCIWndSetTimers</c> macro sets the update periods used by MCIWnd to update the trackbar in the MCIWnd window, update the
            position information displayed in the window title bar, and send notification messages to the parent window. You can use this
            macro or explicitly send the MCIWNDM_SETTIMERS message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="active">
            Update period used by MCIWnd when it is the active window. The default value is 500 milliseconds. Storage for this value is
            limited to 16 bits.
            </param>
            <param name="inactive">
            Update period used by MCIWnd when it is the inactive window. The default value is 2000 milliseconds. Storage for this value is
            limited to 16 bits.
            </param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSetVolume(Vanara.PInvoke.HWND,System.UInt32)">
            <summary>
            The <c>MCIWndSetVolume</c> macro sets the volume level of an MCI device. You can use this macro or explicitly send the
            MCIWNDM_SETVOLUME message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="iVol">
            New volume level. Specify 1000 for normal volume level. Specify a higher value for a louder volume or a lower value for a
            quieter volume.
            </param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndSetZoom(Vanara.PInvoke.HWND,System.UInt32)">
            <summary>
            The <c>MCIWndSetZoom</c> macro resizes a video image according to a zoom factor. This marco adjusts the size of an MCIWnd window
            while maintaining a constant aspect ratio. You can use this macro or explicitly send the MCIWNDM_SETZOOM message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="iZoom">
            Zoom factor expressed as a percentage of the original image. Specify 100 to display the image at its authored size, 200 to
            display the image at twice its normal size, or 50 to display the image at half its normal size.
            </param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndStep(Vanara.PInvoke.HWND,System.Int32)">
            <summary>
            The <c>MCIWndStep</c> macro moves the current position in the content forward or backward by a specified increment. You can use
            this macro or explicitly send the MCI_STEP command.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <param name="n">
            Step value. Negative values step the device through the content in reverse. The units for the step value depend on the current
            time format.
            </param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndStop(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndStop</c> macro stops playing or recording the content of the MCI device associated with the MCIWnd window. You can
            use this macro or explicitly send the MCI_STOP command.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndUseFrames(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndUseFrames</c> macro sets the time format of an MCI device to frames. You can use this macro or explicitly send the
            MCIWNDM_SETTIMEFORMAT message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndUseTime(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndUseTime</c> macro sets the time format of an MCI device to milliseconds. You can use this macro or explicitly send
            the MCIWNDM_SETTIMEFORMAT message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Vfw32.MCIWndValidateMedia(Vanara.PInvoke.HWND)">
            <summary>
            The <c>MCIWndValidateMedia</c> macro updates the starting and ending locations of the content, the current position in the
            content, and the trackbar according to the current time format. You can use this macro or explicitly send the
            MCIWNDM_VALIDATEMEDIA message.
            </summary>
            <param name="hwnd">Handle of the MCIWnd window.</param>
            <returns>None</returns>
            <remarks>
            Typically, you should not need to use this macro; however, if your application changes the time format of a device without using
            MCIWnd; the starting and ending locations of the content, as well as the trackbar, continue to use the old format. You can use
            this macro to update these values.
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32">
            <summary>Items from the Msvfw32.dll</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.DDF">
            <summary>Applicable flags for the function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DDF.DDF_UPDATE">
            <summary>
            Last buffered bitmap needs to be redrawn. If drawing fails with this value, a buffered image is not available and a new
            image needs to be specified before the display can be updated.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DDF.DDF_SAME_HDC">
            <summary>Use the current DC handle and the palette currently associated with the DC.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DDF.DDF_SAME_DRAW">
            <summary>
            Use the current drawing parameters for DrawDibDraw. Use this value only if lpbi, dxDest, dyDest, dxSrc, and dySrc have not
            changed since using DrawDibDraw or DrawDibBegin. This flag supersedes the DDF_SAME_DIB and DDF_SAME_SIZE flags.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DDF.DDF_DONTDRAW">
            <summary>
            Current image is not drawn, but is decompressed. DDF_UPDATE can be used later to draw the image. This flag supersedes the
            DDF_PREROLL flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DDF.DDF_ANIMATE">
            <summary>
            Allows palette animation. If this value is present, DrawDib reserves as many entries as possible by setting PC_RESERVED in
            the palPalEntry array entries of the LOGPALETTE structure, and the palette can be animated by using the DrawDibChangePalette
            function. If your application uses the DrawDibBegin function with the DrawDibDraw function, set this value with DrawDibBegin
            rather than DrawDibDraw.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DDF.DDF_BUFFER">
            <summary>
            Causes DrawDib to try to use an off-screen buffer so DDF_UPDATE can be used. This disables decompression and drawing
            directly to the screen. If DrawDib is unable to create an off-screen buffer, it will decompress or draw directly to the
            screen. For more information, see the DDF_UPDATE and DDF_DONTDRAW values described for DrawDibDraw.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DDF.DDF_JUSTDRAWIT">
            <summary>
            Draws the image by using GDI. Prohibits DrawDib functions from decompressing, stretching, or dithering the image. This
            strips DrawDib of capabilities that differentiate it from the StretchDIBits function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DDF.DDF_FULLSCREEN">
            <summary>Not supported.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DDF.DDF_BACKGROUNDPAL">
            <summary>
            Realizes the palette used for drawing as a background task, leaving the current palette used for the display unchanged.
            (This value is mutually exclusive of DDF_SAME_HDC.)
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DDF.DDF_NOTKEYFRAME">
            <summary>this is a partial frame update, hint</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DDF.DDF_HURRYUP">
            <summary>hurry up please!</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DDF.DDF_HALFTONE">
            <summary>
            Always dithers the DIB to a standard palette regardless of the palette of the DIB. If your application uses DrawDibBegin
            with DrawDibDraw, set this value with DrawDibBegin rather than DrawDibDraw.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICCOMPRESSF">
            <summary>Flags used for compression.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSF.ICCOMPRESS_KEYFRAME">
            <summary>Input data should be treated as a key frame.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMESF">
            <summary>Applicable flags.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMESF.ICCOMPRESSFRAMES_PADDING">
            <summary>Padding is used with the frame.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICDECOMPRESSF">
            <summary>Applicable flags.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSF.ICDECOMPRESS_HURRYUP">
            <summary>
            Tries to decompress at a faster rate. When an application uses this flag, the driver should buffer the decompressed data but
            not draw the image.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSF.ICDECOMPRESS_UPDATE">
            <summary>Screen is being updated or refreshed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSF.ICDECOMPRESS_PREROLL">
            <summary>Current frame precedes the point in the movie where playback starts and, therefore, will not be drawn.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSF.ICDECOMPRESS_NULLFRAME">
            <summary>Current frame does not contain data and the decompressed image should be left the same.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSF.ICDECOMPRESS_NOTKEYFRAME">
            <summary>Current frame is not a key frame.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICDRAWF">
            <summary>Flags from the AVI file index.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_QUERY">
            <summary>Determines if the decompressor can handle the decompression. The driver does not actually decompress the data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_FULLSCREEN">
            <summary>Draws the decompressed data on the full screen.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_HDC">
            <summary>Draws the decompressed data to a window or a DC.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_ANIMATE">
            <summary>Application can animate the palette.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_CONTINUE">
            <summary>Drawing is a continuation of the previous frame.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_MEMORYDC">
            <summary>DC is off-screen.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_UPDATING">
            <summary>Current frame is being updated rather than played.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_RENDER">
            <summary>Renders but does not draw the data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_BUFFER">
            <summary>Buffers this data off-screen; it will need to be updated.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_HURRYUP">
            <summary>Data is buffered and not drawn to the screen. Use this flag for fastest decompression.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_UPDATE">
            <summary>Updates the screen based on data previously received. In this case, lpData should be ignored.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_PREROLL">
            <summary>
            Current frame of video occurs before playback should start. For example, if playback will begin on frame 10, and frame 0 is
            the nearest previous key frame, frames 0 through 9 are sent to the driver with this flag set. The driver needs this data to
            display frame 10 properly.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_NULLFRAME">
            <summary>Current frame does not contain any data, and the previous frame should be redrawn.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWF.ICDRAW_NOTKEYFRAME">
            <summary>Current frame is not a key frame.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICERR">
            <summary>Error values returns by some IC* functions.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICINSTALL">
            <summary>Flags defining the contents of lParam in <see cref="M:Vanara.PInvoke.Msvfw32.ICInstall(System.UInt32,System.UInt32,System.IntPtr,System.String,Vanara.PInvoke.Msvfw32.ICINSTALL)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINSTALL.ICINSTALL_UNICODE">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINSTALL.ICINSTALL_FUNCTION">
            <summary>
            The lParam parameter contains the address of a compressor function. This function should be structured like the DriverProc
            entry point function used by compressors.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINSTALL.ICINSTALL_DRIVER">
            <summary>The lParam parameter contains the address of a null-terminated string that names the compressor to install.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINSTALL.ICINSTALL_HDRV">
            <summary>lParam is a HDRVR (driver handle)</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINSTALL.ICINSTALL_DRIVERW">
            <summary>lParam is a unicode driver name</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICM_Message">
            <summary>Message codes for <see cref="M:Vanara.PInvoke.Msvfw32.ICSendMessage(Vanara.PInvoke.Msvfw32.HIC,System.UInt32,System.IntPtr,System.IntPtr)"/>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_GETSTATE">
            <summary>Get compressor state</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_SETSTATE">
            <summary>Set compressor state</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_GETINFO">
            <summary>Query info about the compressor</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_CONFIGURE">
            <summary>show the configure dialog</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_ABOUT">
            <summary>show the about box</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_GETERRORTEXT">
            <summary>get error text TBD ;Internal</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_GETFORMATNAME">
            <summary>get a name for a format ;Internal</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_ENUMFORMATS">
            <summary>cycle through formats ;Internal</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_GETDEFAULTQUALITY">
            <summary>get the default value for quality</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_GETQUALITY">
            <summary>get the current value for quality</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_SETQUALITY">
            <summary>set the default value for quality</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_SET">
            <summary>Tell the driver something</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_GET">
            <summary>Ask the driver something</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_COMPRESS_GET_FORMAT">
            <summary>get compress format or size</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_COMPRESS_GET_SIZE">
            <summary>get output size</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_COMPRESS_QUERY">
            <summary>query support for compress</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_COMPRESS_BEGIN">
            <summary>begin a series of compress calls.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_COMPRESS">
            <summary>compress a frame</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_COMPRESS_END">
            <summary>end of a series of compress calls.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DECOMPRESS_GET_FORMAT">
            <summary>
            <para>
            The <c>ICM_DECOMPRESS_GET_FORMAT</c> message requests the output format of the decompressed data from a video decompression
            driver. You can send this message explicitly or by using the <c>ICDecompressGetFormat</c> macro.
            </para>
            <para><c>lpbiInput</c> - Pointer to a <c>BITMAPINFO</c> structure containing the input format.</para>
            <para>
            <c>lpbiOutput</c> - Pointer to a <c>BITMAPINFO</c> structure to contain the output format. You can specify zero to request
            only the size of the output format, as in the <c>ICDecompressGetFormatSize</c> macro.
            </para>
            </summary>
            <returns>
            <para>If lpbiOutput is zero, returns the size of the structure.</para>
            <para>If lpbiOutput is nonzero, returns ICERR_OK if successful or an error otherwise.</para>
            </returns>
            <remarks>
            If lpbiOutput is nonzero, the driver should fill the <c>BITMAPINFO</c> structure with the default output format
            corresponding to the input format specified for lpbiInput. If the compressor can produce several formats, the default format
            should be the one that preserves the greatest amount of information.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DECOMPRESS_QUERY">
            <summary>query support for dempress</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DECOMPRESS_BEGIN">
            <summary>start a series of decompress calls</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DECOMPRESS">
            <summary>decompress a frame</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DECOMPRESS_END">
            <summary>end a series of decompress calls</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DECOMPRESS_SET_PALETTE">
            <summary>fill in the DIB color table</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DECOMPRESS_GET_PALETTE">
            <summary>fill in the DIB color table</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_QUERY">
            <summary>query support for dempress</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_BEGIN">
            <summary>start a series of draw calls</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_GET_PALETTE">
            <summary>get the palette needed for drawing</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_UPDATE">
            <summary>update screen with current frame ;Internal</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_START">
            <summary>start decompress clock</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_STOP">
            <summary>stop decompress clock</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_BITS">
            <summary>decompress a frame to screen ;Internal</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_END">
            <summary>end a series of draw calls</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_GETTIME">
            <summary>get value of decompress clock</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW">
            <summary>generalized "render" message</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_WINDOW">
            <summary>drawing window has moved or hidden</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_SETTIME">
            <summary>set correct value for decompress clock</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_REALIZE">
            <summary>realize palette for drawing</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_FLUSH">
            <summary>clear out buffered frames</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_RENDERBUFFER">
            <summary>draw undrawn things in queue</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_START_PLAY">
            <summary>start of a play</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_STOP_PLAY">
            <summary>end of a play</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_SUGGESTFORMAT">
            <summary>Like ICGetDisplayFormat</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_CHANGEPALETTE">
            <summary>for animating palette</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DRAW_IDLE">
            <summary>send each frame time ;Internal</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_GETBUFFERSWANTED">
            <summary>ask about prebuffering</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_GETDEFAULTKEYFRAMERATE">
            <summary>get the default value for key frames</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DECOMPRESSEX_BEGIN">
            <summary>start a series of decompress calls</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DECOMPRESSEX_QUERY">
            <summary>start a series of decompress calls</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DECOMPRESSEX">
            <summary>decompress a frame</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_DECOMPRESSEX_END">
            <summary>end a series of decompress calls</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_COMPRESS_FRAMES_INFO">
            <summary>tell about compress to come</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_COMPRESS_FRAMES">
            <summary>compress a bunch of frames ;Internal</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICM_Message.ICM_SET_STATUS_PROC">
            <summary>set status callback</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICMF_CHOOSE">
            <summary>Applicable flags.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICMF_CHOOSE.ICMF_CHOOSE_KEYFRAME">
            <summary>Displays a check box and edit box to enter the frequency of key frames.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICMF_CHOOSE.ICMF_CHOOSE_DATARATE">
            <summary>Displays a check box and edit box to enter the data rate for the movie.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICMF_CHOOSE.ICMF_CHOOSE_PREVIEW">
            <summary>
            Displays a button to expand the dialog box to include a preview window. The preview window shows how frames of your movie
            will appear when compressed with the current settings.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICMF_CHOOSE.ICMF_CHOOSE_ALLCOMPRESSORS">
            <summary>
            All compressors should appear in the selection list. If this flag is not specified, only the compressors that can handle the
            input format appear in the selection list.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICMF_COMPVARS">
            <summary>Applicable flags.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICMF_COMPVARS.ICMF_COMPVARS_VALID">
            <summary>
            Data in this structure is valid and has been manually entered. Set this flag before you call any function if you fill this
            structure manually. Do not set this flag if you let ICCompressorChoose initialize this structure.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICMODE">
            <summary>Applicable flags indicating why the driver is opened.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICMODE.ICMODE_COMPRESS">
            <summary>Driver is opened to compress data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICMODE.ICMODE_DECOMPRESS">
            <summary>Driver is opened to decompress data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICMODE.ICMODE_FASTDECOMPRESS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICMODE.ICMODE_QUERY">
            <summary>Driver is opened for informational purposes, rather than for compression.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICMODE.ICMODE_FASTCOMPRESS">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICMODE.ICMODE_DRAW">
            <summary>Device driver is opened to decompress data directly to hardware.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.VIDCF">
            <summary>Applicable flags.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.VIDCF.VIDCF_QUALITY">
            <summary>Driver supports quality values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.VIDCF.VIDCF_CRUNCH">
            <summary>Driver supports compressing to a frame size.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.VIDCF.VIDCF_TEMPORAL">
            <summary>Driver supports inter-frame compression.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.VIDCF.VIDCF_COMPRESSFRAMES">
            <summary>
            Driver is requesting to compress all frames. For information about compressing all frames, see the ICM_COMPRESS_FRAMES_INFO message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.VIDCF.VIDCF_DRAW">
            <summary>Driver supports drawing.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.VIDCF.VIDCF_FASTTEMPORALC">
            <summary>
            Driver can perform temporal compression and maintains its own copy of the current frame. When compressing a stream of frame
            data, the driver doesn't need image data from the previous frame.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.VIDCF.VIDCF_FASTTEMPORALD">
            <summary>
            Driver can perform temporal decompression and maintains its own copy of the current frame. When decompressing a stream of
            frame data, the driver doesn't need image data from the previous frame.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibBegin(Vanara.PInvoke.Msvfw32.HDRAWDIB,Vanara.PInvoke.HDC,System.Int32,System.Int32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.Int32,System.Int32,Vanara.PInvoke.Msvfw32.DDF)">
            <summary>The <c>DrawDib</c> function changes parameters of a DrawDib DC or initializes a new DrawDib DC.</summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <param name="hdc">Handle to a DC for drawing. This parameter is optional.</param>
            <param name="dxDst">Width, in <c>MM_TEXT</c> client units, of the destination rectangle.</param>
            <param name="dyDst">Height, in <c>MM_TEXT</c> client units, of the destination rectangle.</param>
            <param name="lpbi">
            Pointer to a BITMAPINFOHEADER structure containing the image format. The color table for the DIB follows the image format and
            the <c>biHeight</c> member must be a positive value.
            </param>
            <param name="dxSrc">Width, in pixels, of the source rectangle.</param>
            <param name="dySrc">Height, in pixels, of the source rectangle.</param>
            <param name="wFlags">
            <para>Applicable flags for the function. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DDF_ANIMATE</term>
            <term>
            Allows palette animation. If this value is present, DrawDib reserves as many entries as possible by setting PC_RESERVED in the
            palPalEntry array entries of the LOGPALETTE structure, and the palette can be animated by using the DrawDibChangePalette
            function. If your application uses the DrawDibBegin function with the DrawDibDraw function, set this value with DrawDibBegin
            rather than DrawDibDraw.
            </term>
            </item>
            <item>
            <term>DDF_BACKGROUNDPAL</term>
            <term>
            Realizes the palette used for drawing as a background task, leaving the current palette used for the display unchanged. (This
            value is mutually exclusive of DDF_SAME_HDC.)
            </term>
            </item>
            <item>
            <term>DDF_BUFFER</term>
            <term>
            Causes DrawDib to try to use an off-screen buffer so DDF_UPDATE can be used. This disables decompression and drawing directly to
            the screen. If DrawDib is unable to create an off-screen buffer, it will decompress or draw directly to the screen. For more
            information, see the DDF_UPDATE and DDF_DONTDRAW values described for DrawDibDraw.
            </term>
            </item>
            <item>
            <term>DDF_DONTDRAW</term>
            <term>
            Current image is not drawn, but is decompressed. DDF_UPDATE can be used later to draw the image. This flag supersedes the
            DDF_PREROLL flag.
            </term>
            </item>
            <item>
            <term>DDF_FULLSCREEN</term>
            <term>Not supported.</term>
            </item>
            <item>
            <term>DDF_HALFTONE</term>
            <term>
            Always dithers the DIB to a standard palette regardless of the palette of the DIB. If your application uses DrawDibBegin with
            DrawDibDraw, set this value with DrawDibBegin rather than DrawDibDraw.
            </term>
            </item>
            <item>
            <term>DDF_JUSTDRAWIT</term>
            <term>
            Draws the image by using GDI. Prohibits DrawDib functions from decompressing, stretching, or dithering the image. This strips
            DrawDib of capabilities that differentiate it from the StretchDIBits function.
            </term>
            </item>
            <item>
            <term>DDF_SAME_DRAW</term>
            <term>
            Use the current drawing parameters for DrawDibDraw. Use this value only if lpbi, dxDest, dyDest, dxSrc, and dySrc have not
            changed since using DrawDibDraw or DrawDibBegin. This flag supersedes the DDF_SAME_DIB and DDF_SAME_SIZE flags.
            </term>
            </item>
            <item>
            <term>DDF_SAME_HDC</term>
            <term>Use the current DC handle and the palette currently associated with the DC.</term>
            </item>
            <item>
            <term>DDF_UPDATE</term>
            <term>
            Last buffered bitmap needs to be redrawn. If drawing fails with this value, a buffered image is not available and a new image
            needs to be specified before the display can be updated.
            </term>
            </item>
            </list>
            </param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
            <remarks>
            <para>
            This function prepares to draw a DIB specified by lpbi to the DC. The image is stretched to the size specified by dxDest and
            dyDest. If dxDest and dyDest are set to −1, the DIB is drawn to a 1:1 scale without stretching.
            </para>
            <para>
            You can update the flags of a DrawDib DC by reissuing <c>DrawDibBegin</c>, specifying the new flags, and changing at least one
            of the following settings: dxDest, dyDest, lpbi, dxSrc, or dySrc.
            </para>
            <para>If the parameters of <c>DrawDibBegin</c> have not changed, subsequent calls to the function have no effect.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibChangePalette(Vanara.PInvoke.Msvfw32.HDRAWDIB,System.Int32,System.Int32,Vanara.PInvoke.PALETTEENTRY[])">
            <summary>The <c>DrawDibChangePalette</c> function sets the palette entries used for drawing DIBs.</summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <param name="iStart">Starting palette entry number.</param>
            <param name="iLen">Number of palette entries.</param>
            <param name="lppe">Pointer to an array of palette entries.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
            <remarks>
            <para>
            This function changes the physical palette only if the current DrawDib palette is realized by calling the DrawDibRealize function.
            </para>
            <para>
            If the color table is not changed, the next call to the DrawDibDraw function that does not specify DDF_SAME_DRAW calls the
            DrawDibBegin function implicitly.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibClose(Vanara.PInvoke.Msvfw32.HDRAWDIB)">
            <summary>The <c>DrawDibClose</c> function closes a DrawDib DC and frees the resources DrawDib allocated for it.</summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibDraw(Vanara.PInvoke.Msvfw32.HDRAWDIB,Vanara.PInvoke.HDC,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.Msvfw32.DDF)">
            <summary>The <c>DrawDibDraw</c> function draws a DIB to the screen.</summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <param name="hdc">Handle to the DC.</param>
            <param name="xDst">The x-coordinate, in <c>MM_TEXT</c> client coordinates, of the upper left corner of the destination rectangle.</param>
            <param name="yDst">The y-coordinate, in <c>MM_TEXT</c> client coordinates, of the upper left corner of the destination rectangle.</param>
            <param name="dxDst">
            Width, in <c>MM_TEXT</c> client coordinates, of the destination rectangle. If dxDst is −1, the width of the bitmap is used.
            </param>
            <param name="dyDst">
            Height, in <c>MM_TEXT</c> client coordinates, of the destination rectangle. If dyDst is −1, the height of the bitmap is used.
            </param>
            <param name="lpbi">
            Pointer to the BITMAPINFOHEADER structure containing the image format. The color table for the DIB within
            <c>BITMAPINFOHEADER</c> follows the format and the <c>biHeight</c> member must be a positive value; <c>DrawDibDraw</c> will not
            draw inverted DIBs.
            </param>
            <param name="lpBits">Pointer to the buffer that contains the bitmap bits.</param>
            <param name="xSrc">
            The x-coordinate, in pixels, of the upper left corner of the source rectangle. The coordinates (0,0) represent the upper left
            corner of the bitmap.
            </param>
            <param name="ySrc">
            The y-coordinate, in pixels, of the upper left corner of the source rectangle. The coordinates (0,0) represent the upper left
            corner of the bitmap.
            </param>
            <param name="dxSrc">Width, in pixels, of the source rectangle.</param>
            <param name="dySrc">Height, in pixels, of the source rectangle.</param>
            <param name="wFlags">
            <para>Applicable flags for drawing. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DDF_BACKGROUNDPAL</term>
            <term>
            Realizes the palette used for drawing in the background, leaving the actual palette used for display unchanged. This value is
            valid only if DDF_SAME_HDC is not set.
            </term>
            </item>
            <item>
            <term>DDF_DONTDRAW</term>
            <term>Current image is decompressed but not drawn. This flag supersedes the DDF_PREROLL flag.</term>
            </item>
            <item>
            <term>DDF_FULLSCREEN</term>
            <term>Not supported.</term>
            </item>
            <item>
            <term>DDF_HALFTONE</term>
            <term>
            Always dithers the DIB to a standard palette regardless of the palette of the DIB. If your application uses the DrawDibBegin
            function, set this value in DrawDibBegin rather than in DrawDibDraw.
            </term>
            </item>
            <item>
            <term>DDF_HURRYUP</term>
            <term>
            Data does not have to be drawn (that is, it can be dropped) and DDF_UPDATE will not be used to recall this information. DrawDib
            checks this value only if it is required to build the next frame; otherwise, the value is ignored.This value is usually used to
            synchronize video and audio. When synchronizing data, applications should send the image with this value in case the driver
            needs to buffer the frame to decompress subsequent frames.
            </term>
            </item>
            <item>
            <term>DDF_NOTKEYFRAME</term>
            <term>DIB data is not a key frame.</term>
            </item>
            <item>
            <term>DDF_SAME_HDC</term>
            <term>Use the current DC handle and the palette currently associated with the DC.</term>
            </item>
            <item>
            <term>DDF_SAME_DRAW</term>
            <term>
            Use the current drawing parameters for DrawDibDraw. Use this value only if lpbi, dxDst, dyDst, dxSrc, and dySrc have not changed
            since using DrawDibDraw or DrawDibBegin. DrawDibDraw typically checks the parameters, and if they have changed, DrawDibBegin
            prepares the DrawDib DC for drawing. This flag supersedes the DDF_SAME_DIB and DDF_SAME_SIZE flags.
            </term>
            </item>
            <item>
            <term>DDF_UPDATE</term>
            <term>
            Last buffered bitmap is to be redrawn. If drawing fails with this value, a buffered image is not available and a new image needs
            to be specified before the display can be updated.
            </term>
            </item>
            </list>
            </param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
            <remarks>
            <para>
            <c>DDF_DONTDRAW</c> causes <c>DrawDibDraw</c> to decompress but not display an image. A subsequent call to <c>DrawDibDraw</c>
            specifying <c>DDF_UPDATE</c> displays the image.
            </para>
            <para>
            If the DrawDib DC does not have an off-screen buffer specified, specifying <c>DDF_DONTDRAW</c> causes the frame to be drawn to
            the screen immediately. Subsequent calls to <c>DrawDibDraw</c> specifying <c>DDF_UPDATE</c> fail.
            </para>
            <para>
            Although they are set at different times, <c>DDF_UPDATE</c> and <c>DDF_DONTDRAW</c> can be used together to create composite
            images off-screen. When the off-screen image is complete, you can display the image by calling <c>DrawDibDraw</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibDraw(Vanara.PInvoke.Msvfw32.HDRAWDIB,Vanara.PInvoke.HDC,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.Msvfw32.DDF)">
            <summary>The <c>DrawDibDraw</c> function draws a DIB to the screen.</summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <param name="hdc">Handle to the DC.</param>
            <param name="xDst">The x-coordinate, in <c>MM_TEXT</c> client coordinates, of the upper left corner of the destination rectangle.</param>
            <param name="yDst">The y-coordinate, in <c>MM_TEXT</c> client coordinates, of the upper left corner of the destination rectangle.</param>
            <param name="dxDst">
            Width, in <c>MM_TEXT</c> client coordinates, of the destination rectangle. If dxDst is −1, the width of the bitmap is used.
            </param>
            <param name="dyDst">
            Height, in <c>MM_TEXT</c> client coordinates, of the destination rectangle. If dyDst is −1, the height of the bitmap is used.
            </param>
            <param name="lpbi">
            Pointer to the BITMAPINFOHEADER structure containing the image format. The color table for the DIB within
            <c>BITMAPINFOHEADER</c> follows the format and the <c>biHeight</c> member must be a positive value; <c>DrawDibDraw</c> will not
            draw inverted DIBs.
            </param>
            <param name="lpBits">Pointer to the buffer that contains the bitmap bits.</param>
            <param name="xSrc">
            The x-coordinate, in pixels, of the upper left corner of the source rectangle. The coordinates (0,0) represent the upper left
            corner of the bitmap.
            </param>
            <param name="ySrc">
            The y-coordinate, in pixels, of the upper left corner of the source rectangle. The coordinates (0,0) represent the upper left
            corner of the bitmap.
            </param>
            <param name="dxSrc">Width, in pixels, of the source rectangle.</param>
            <param name="dySrc">Height, in pixels, of the source rectangle.</param>
            <param name="wFlags">
            <para>Applicable flags for drawing. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>DDF_BACKGROUNDPAL</term>
            <term>
            Realizes the palette used for drawing in the background, leaving the actual palette used for display unchanged. This value is
            valid only if DDF_SAME_HDC is not set.
            </term>
            </item>
            <item>
            <term>DDF_DONTDRAW</term>
            <term>Current image is decompressed but not drawn. This flag supersedes the DDF_PREROLL flag.</term>
            </item>
            <item>
            <term>DDF_FULLSCREEN</term>
            <term>Not supported.</term>
            </item>
            <item>
            <term>DDF_HALFTONE</term>
            <term>
            Always dithers the DIB to a standard palette regardless of the palette of the DIB. If your application uses the DrawDibBegin
            function, set this value in DrawDibBegin rather than in DrawDibDraw.
            </term>
            </item>
            <item>
            <term>DDF_HURRYUP</term>
            <term>
            Data does not have to be drawn (that is, it can be dropped) and DDF_UPDATE will not be used to recall this information. DrawDib
            checks this value only if it is required to build the next frame; otherwise, the value is ignored.This value is usually used to
            synchronize video and audio. When synchronizing data, applications should send the image with this value in case the driver
            needs to buffer the frame to decompress subsequent frames.
            </term>
            </item>
            <item>
            <term>DDF_NOTKEYFRAME</term>
            <term>DIB data is not a key frame.</term>
            </item>
            <item>
            <term>DDF_SAME_HDC</term>
            <term>Use the current DC handle and the palette currently associated with the DC.</term>
            </item>
            <item>
            <term>DDF_SAME_DRAW</term>
            <term>
            Use the current drawing parameters for DrawDibDraw. Use this value only if lpbi, dxDst, dyDst, dxSrc, and dySrc have not changed
            since using DrawDibDraw or DrawDibBegin. DrawDibDraw typically checks the parameters, and if they have changed, DrawDibBegin
            prepares the DrawDib DC for drawing. This flag supersedes the DDF_SAME_DIB and DDF_SAME_SIZE flags.
            </term>
            </item>
            <item>
            <term>DDF_UPDATE</term>
            <term>
            Last buffered bitmap is to be redrawn. If drawing fails with this value, a buffered image is not available and a new image needs
            to be specified before the display can be updated.
            </term>
            </item>
            </list>
            </param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
            <remarks>
            <para>
            <c>DDF_DONTDRAW</c> causes <c>DrawDibDraw</c> to decompress but not display an image. A subsequent call to <c>DrawDibDraw</c>
            specifying <c>DDF_UPDATE</c> displays the image.
            </para>
            <para>
            If the DrawDib DC does not have an off-screen buffer specified, specifying <c>DDF_DONTDRAW</c> causes the frame to be drawn to
            the screen immediately. Subsequent calls to <c>DrawDibDraw</c> specifying <c>DDF_UPDATE</c> fail.
            </para>
            <para>
            Although they are set at different times, <c>DDF_UPDATE</c> and <c>DDF_DONTDRAW</c> can be used together to create composite
            images off-screen. When the off-screen image is complete, you can display the image by calling <c>DrawDibDraw</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibEnd(Vanara.PInvoke.Msvfw32.HDRAWDIB)">
            <summary>
            The <c>DrawDibEnd</c> function clears the flags and other settings of a DrawDib DC that are set by the DrawDibBegin or
            DrawDibDraw functions.
            </summary>
            <param name="hdd">Handle to the DrawDib DC to free.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibGetBuffer(Vanara.PInvoke.Msvfw32.HDRAWDIB,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.UInt32,System.UInt32)">
            <summary>The <c>DrawDibGetBuffer</c> function retrieves the location of the buffer used by DrawDib for decompression.</summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <param name="lpbi">
            Pointer to a BITMAPINFO structure. This structure is made up of a BITMAPINFOHEADER structure and a 256-entry table defining the
            colors used by the bitmap.
            </param>
            <param name="dwSize">Size, in bytes, of the BITMAPINFO structure pointed to by lpbi</param>
            <param name="dwFlags">Reserved; must be zero.</param>
            <returns>
            Returns the address of the buffer or <c>NULL</c> if no buffer is used. if lpbr is not <c>NULL</c>, it is filled with a copy of
            the BITMAPINFO structure describing the buffer.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibGetPalette(Vanara.PInvoke.Msvfw32.HDRAWDIB)">
            <summary>The <c>DrawDibGetPalette</c> function retrieves the palette used by a DrawDib DC.</summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <returns>Returns a handle to the palette if successful or <c>NULL</c> otherwise.</returns>
            <remarks>
            <para>
            This function assumes the DrawDib DC contains a valid palette entry, implying that a call to this function must follow calls to
            the DrawDibDraw or DrawDibBegin functions.
            </para>
            <para>
            You should rarely need to call this function because you can realize the correct palette in response to a window message by
            using the DrawDibRealize function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibOpen">
            <summary>The <c>DrawDibOpen</c> function opens the DrawDib library for use and creates a DrawDib DC for drawing.</summary>
            <returns>Returns a handle to a DrawDib DC if successful or <c>NULL</c> otherwise.</returns>
            <remarks>
            When drawing multiple DIBs simultaneously, create a DrawDib DC for each of the images that will be simultaneously on-screen.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibProfileDisplay(Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@)">
            <summary>The <c>DrawDibProfileDisplay</c> function determines settings for the display system when using DrawDib functions.</summary>
            <param name="lpbi">
            Pointer to a BITMAPINFOHEADER structure that contains bitmap information. You can also specify <c>NULL</c> to verify that the
            profile information is current. If the profile information is not current, DrawDib will rerun the profile tests to obtain a
            current set of information. When you call <c>DrawDibProfileDisplay</c> with this parameter set to <c>NULL</c>, the return value
            is meaningless.
            </param>
            <returns>
            <para>
            Returns a value that indicates the fastest drawing and stretching capabilities of the display system. This value can be zero if
            the bitmap format is not supported or one or more of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>PD_CAN_DRAW_DIB</term>
            <term>DrawDib can draw images using this format. Stretching might or might not also be supported.</term>
            </item>
            <item>
            <term>PD_CAN_STRETCHDIB</term>
            <term>DrawDib can stretch and draw images using this format.</term>
            </item>
            <item>
            <term>PD_STRETCHDIB_1_1_OK</term>
            <term>StretchDIBits draws unstretched images using this format faster than an alternative method.</term>
            </item>
            <item>
            <term>PD_STRETCHDIB_1_2_OK</term>
            <term>StretchDIBits draws stretched images (in a 1:2 ratio) using this format faster than an alternative method.</term>
            </item>
            <item>
            <term>PD_STRETCHDIB_1_N_OK</term>
            <term>StretchDIBits draws stretched images (in a 1:N ratio) using this format faster than an alternative method.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibRealize(Vanara.PInvoke.Msvfw32.HDRAWDIB,Vanara.PInvoke.HDC,System.Boolean)">
            <summary>The <c>DrawDibRealize</c> function realizes the palette of the DrawDib DC for use with the specified DC.</summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <param name="hdc">Handle to the DC containing the palette.</param>
            <param name="fBackground">
            Background palette flag. If this value is nonzero, the palette is a background palette. If this value is zero and the DC is
            attached to a window, the logical palette becomes the foreground palette when the window has the input focus. (A DC is attached
            to a window when the window class style is CS_OWNDC or when the DC is obtained by using the GetDC function.)
            </param>
            <returns>
            Returns the number of entries in the logical palette mapped to different values in the system palette. If an error occurs or no
            colors were updated, it returns zero.
            </returns>
            <remarks>
            To select the palette of the DrawDib DC as a background palette, use the DrawDibDraw function and specify the DDF_BACKGROUNDPAL flag.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibSetPalette(Vanara.PInvoke.Msvfw32.HDRAWDIB,Vanara.PInvoke.HPALETTE)">
            <summary>The <c>DrawDibSetPalette</c> function sets the palette used for drawing DIBs.</summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <param name="hpal">Handle to the palette. Specify <c>NULL</c> to use the default palette.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibStart(Vanara.PInvoke.Msvfw32.HDRAWDIB,System.UInt32)">
            <summary>The <c>DrawDibStart</c> function prepares a DrawDib DC for streaming playback.</summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <param name="rate">Playback rate, in microseconds per frame.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibStop(Vanara.PInvoke.Msvfw32.HDRAWDIB)">
            <summary>The <c>DrawDibStop</c> function frees the resources used by a DrawDib DC for streaming playback.</summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibTime(Vanara.PInvoke.Msvfw32.HDRAWDIB,Vanara.PInvoke.Msvfw32.DRAWDIBTIME@)">
            <summary>
            The <c>DrawDibTime</c> function retrieves timing information about the drawing operation and is used during debug operations.
            </summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <param name="lpddtime">Pointer to a DRAWDIBTIME structure.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
            <remarks>This function is present only in the debug version of the Microsoft Windows Software Development Kit (SDK) libraries.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.DrawDibUpdate(Vanara.PInvoke.Msvfw32.HDRAWDIB,Vanara.PInvoke.HDC,System.Int32,System.Int32)">
            <summary>The <c>DrawDibUpdate</c> macro draws the last frame in the DrawDib off-screen buffer.</summary>
            <param name="hdd">Handle to a DrawDib DC.</param>
            <param name="hdc">Handle of the DC.</param>
            <param name="x">The x-coordinate, in MM_TEXT client coordinates, of the upper left corner of the destination rectangle.</param>
            <param name="y">The y-coordinate, in MM_TEXT client coordinates, of the upper left corner of the destination rectangle.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
            <remarks>
            <para>The <c>DrawDibUpdate</c> macro is defined as follows:</para>
            <para>
            <code> #define DrawDibUpdate( hdd, hdc, x, y) \ DrawDibDraw( hdd, hdc, x, y, 0, 0, NULL, NULL, 0, 0, \ 0, 0, DDF_UPDATE)</code>
            </para>
            <para>This macro can be used to refresh an image or a portion of an image displayed by your application.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.GetOpenFileNamePreview(Vanara.PInvoke.ComDlg32.OPENFILENAME@)">
            <summary>
            The <c>GetOpenFileNamePreview</c> function selects a file by using the Open dialog box. The dialog box also allows the user to
            preview the currently specified AVI file. This function augments the capability found in the GetOpenFileName function.
            </summary>
            <param name="lpofn">
            Pointer to an <c>OPENFILENAME</c> structure used to initialize the dialog box. On return, the structure contains information
            about the user's file selection.
            </param>
            <returns>Returns a handle to the selected file.</returns>
            <remarks>
            <para>Note</para>
            <para>
            The vfw.h header defines GetOpenFileNamePreview as an alias which automatically selects the ANSI or Unicode version of this
            function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that
            not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions
            for Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.GetSaveFileNamePreview(Vanara.PInvoke.ComDlg32.OPENFILENAME@)">
            <summary>
            The <c>GetSaveFileNamePreview</c> function selects a file by using the Save As dialog box. The dialog box also allows the user
            to preview the currently specified file. This function augments the capability found in the GetSaveFileName function.
            </summary>
            <param name="lpofn">
            Pointer to an <c>OPENFILENAME</c> structure used to initialize the dialog box. On return, the structure contains information
            about the user's file selection.
            </param>
            <returns>Returns a handle to the selected file.</returns>
            <remarks>
            <para>Note</para>
            <para>
            The vfw.h header defines GetSaveFileNamePreview as an alias which automatically selects the ANSI or Unicode version of this
            function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that
            not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see Conventions
            for Function Prototypes.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICAbout(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.HWND)">
            <summary>
            The <c>ICAbout</c> macro notifies a video compression driver to display its About dialog box. You can use this macro or
            explicitly call the ICM_ABOUT message.
            </summary>
            <param name="hic">Handle of the compressor.</param>
            <param name="hwnd">
            <para>Handle of the parent window of the displayed dialog box.</para>
            <para>
            You can also determine if a driver has an About dialog box by specifying -1 in this parameter, as in the ICQueryAbout macro. The
            driver returns ICERR_OK if it has an About dialog box or ICERR_UNSUPPORTED otherwise.
            </para>
            </param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICClose(Vanara.PInvoke.Msvfw32.HIC)">
            <summary>The <c>ICClose</c> function closes a compressor or decompressor.</summary>
            <param name="hic">Handle to a compressor or decompressor.</param>
            <returns>Returns ICERR_OK if successful or an error otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICCompress(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.ICCOMPRESSF,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.IntPtr,Vanara.PInvoke.AviFil32.AVIIF@,System.Int32,System.UInt32,System.UInt32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr)">
            <summary>The <c>ICCompress</c> function compresses a single video image.</summary>
            <param name="hic">Handle to the compressor to use.</param>
            <param name="dwFlags">
            <para>Compression flag. The following value is defined:</para>
            <para>ICCOMPRESS_KEYFRAME</para>
            <para>Compressor should make this frame a key frame.</para>
            </param>
            <param name="lpbiOutput">Pointer to a BITMAPINFOHEADER structure containing the output format.</param>
            <param name="lpData">Pointer to an output buffer large enough to contain a compressed frame.</param>
            <param name="lpbiInput">Pointer to a BITMAPINFOHEADER structure containing the input format.</param>
            <param name="lpBits">Pointer to the input buffer.</param>
            <param name="lpckid">Reserved; do not use.</param>
            <param name="lpdwFlags">
            <para>Pointer to the return flags used in the AVI index. The following value is defined:</para>
            <para>AVIIF_KEYFRAME</para>
            <para>Current frame is a key frame.</para>
            </param>
            <param name="lFrameNum">Frame number.</param>
            <param name="dwFrameSize">
            <para>
            Requested frame size, in bytes. Specify a nonzero value if the compressor supports a suggested frame size, as indicated by the
            presence of the <c>VIDCF_CRUNCH</c> flag returned by the ICGetInfo function. If this flag is not set or a data rate for the
            frame is not specified, specify zero for this parameter.
            </para>
            <para>
            A compressor might have to sacrifice image quality or make some other trade-off to obtain the size goal specified in this parameter.
            </para>
            </param>
            <param name="dwQuality">
            Requested quality value for the frame. Specify a nonzero value if the compressor supports a suggested quality value, as
            indicated by the presence of the <c>VIDCF_QUALITY</c> flag returned by ICGetInfo. Otherwise, specify zero for this parameter.
            </param>
            <param name="lpbiPrev">Pointer to a BITMAPINFOHEADER structure containing the format of the previous frame.</param>
            <param name="lpPrev">
            Pointer to the uncompressed image of the previous frame. This parameter is not used for fast temporal compression. Specify
            <c>NULL</c> for this parameter when compressing a key frame, if the compressor does not support temporal compression, or if the
            compressor does not require an external buffer to store the format and data of the previous image.
            </param>
            <returns>Returns <c>ICERR_OK</c> if successful or an error otherwise.</returns>
            <remarks>
            <para>
            You can obtain the required by size of the output buffer by sending the ICM_COMPRESS_GET_SIZE message (or by using the
            ICCompressGetSize macro).
            </para>
            <para>
            The compressor sets the contents of lpdwFlags to <c>AVIIF_KEYFRAME</c> when it creates a key frame. If your application creates
            AVI files, it should save the information returned for lpckid and lpdwFlags in the file.
            </para>
            <para>
            Compressors use lpbiPrev and lpPrev to perform temporal compression and require an external buffer to store the format and data
            of the previous frame. Specify <c>NULL</c> for lpbiPrev and lpPrev when compressing a key frame, when performing fast
            compression, or if the compressor has its own buffer to store the format and data of the previous image. Specify non-
            <c>NULL</c> values for these parameters if ICGetInfo returns the <c>VIDCF_TEMPORAL</c> flag, the compressor is performing normal
            compression, and the frame to compress is not a key frame.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICCompress(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.ICCOMPRESSF,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.IntPtr,Vanara.PInvoke.AviFil32.AVIIF@,System.Int32,System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>The <c>ICCompress</c> function compresses a single video image.</summary>
            <param name="hic">Handle to the compressor to use.</param>
            <param name="dwFlags">
            <para>Compression flag. The following value is defined:</para>
            <para>ICCOMPRESS_KEYFRAME</para>
            <para>Compressor should make this frame a key frame.</para>
            </param>
            <param name="lpbiOutput">Pointer to a BITMAPINFOHEADER structure containing the output format.</param>
            <param name="lpData">Pointer to an output buffer large enough to contain a compressed frame.</param>
            <param name="lpbiInput">Pointer to a BITMAPINFOHEADER structure containing the input format.</param>
            <param name="lpBits">Pointer to the input buffer.</param>
            <param name="lpckid">Reserved; do not use.</param>
            <param name="lpdwFlags">
            <para>Pointer to the return flags used in the AVI index. The following value is defined:</para>
            <para>AVIIF_KEYFRAME</para>
            <para>Current frame is a key frame.</para>
            </param>
            <param name="lFrameNum">Frame number.</param>
            <param name="dwFrameSize">
            <para>
            Requested frame size, in bytes. Specify a nonzero value if the compressor supports a suggested frame size, as indicated by the
            presence of the <c>VIDCF_CRUNCH</c> flag returned by the ICGetInfo function. If this flag is not set or a data rate for the
            frame is not specified, specify zero for this parameter.
            </para>
            <para>
            A compressor might have to sacrifice image quality or make some other trade-off to obtain the size goal specified in this parameter.
            </para>
            </param>
            <param name="dwQuality">
            Requested quality value for the frame. Specify a nonzero value if the compressor supports a suggested quality value, as
            indicated by the presence of the <c>VIDCF_QUALITY</c> flag returned by ICGetInfo. Otherwise, specify zero for this parameter.
            </param>
            <param name="lpbiPrev">Pointer to a BITMAPINFOHEADER structure containing the format of the previous frame.</param>
            <param name="lpPrev">
            Pointer to the uncompressed image of the previous frame. This parameter is not used for fast temporal compression. Specify
            <c>NULL</c> for this parameter when compressing a key frame, if the compressor does not support temporal compression, or if the
            compressor does not require an external buffer to store the format and data of the previous image.
            </param>
            <returns>Returns <c>ICERR_OK</c> if successful or an error otherwise.</returns>
            <remarks>
            <para>
            You can obtain the required by size of the output buffer by sending the ICM_COMPRESS_GET_SIZE message (or by using the
            ICCompressGetSize macro).
            </para>
            <para>
            The compressor sets the contents of lpdwFlags to <c>AVIIF_KEYFRAME</c> when it creates a key frame. If your application creates
            AVI files, it should save the information returned for lpckid and lpdwFlags in the file.
            </para>
            <para>
            Compressors use lpbiPrev and lpPrev to perform temporal compression and require an external buffer to store the format and data
            of the previous frame. Specify <c>NULL</c> for lpbiPrev and lpPrev when compressing a key frame, when performing fast
            compression, or if the compressor has its own buffer to store the format and data of the previous image. Specify non-
            <c>NULL</c> values for these parameters if ICGetInfo returns the <c>VIDCF_TEMPORAL</c> flag, the compressor is performing normal
            compression, and the frame to compress is not a key frame.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICCompressBegin(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFO@,Vanara.PInvoke.Gdi32.BITMAPINFO@)">
            <summary>
            The ICCompressBegin macro notifies a video compression driver to prepare to compress data. You can use this macro or explicitly
            call the ICM_COMPRESS_BEGIN message.
            </summary>
            <param name="hic">Handle to a compressor.</param>
            <param name="lpbiInput">Pointer to a BITMAPINFO structure containing the input format.</param>
            <param name="lpbiOutput">Pointer to a BITMAPINFO structure containing the output format.</param>
            <returns>None</returns>
            <remarks>
            <para>
            The driver should allocate and initialize any tables or memory that it needs for compressing the data formats when it receives
            the ICM_COMPRESS message.
            </para>
            <para>
            VCM saves the settings of the most recent <c>ICCompressBegin</c> macro. The <c>ICCompressBegin</c> and <c>ICCompressEnd</c>
            messages do not nest. If your driver receives <c>ICM_COMPRESS_BEGIN</c> before compression is stopped with
            <c>ICM_COMPRESS_END</c>, it should restart compression with new parameters.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICCompressEnd(Vanara.PInvoke.Msvfw32.HIC)">
            <summary>
            The <c>ICCompressEnd</c> macro notifies a video compression driver to end compression and free resources allocated for
            compression. You can use this macro or explicitly call the ICM_COMPRESS_END message.
            </summary>
            <param name="hic">Handle of the compressor.</param>
            <returns>None</returns>
            <remarks>
            VCM saves the settings of the most recent <c>ICCompressBegin</c> macro. <c>ICCompressBegin</c> and <c>ICCompressEnd</c> do not
            nest. If your driver receives the <c>ICM_COMPRESS_BEGIN</c> message before compression is stopped with the
            <c>ICM_COMPRESS_END</c> message, it should restart compression with new parameters.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICCompressGetFormat(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFO@,Vanara.PInvoke.Gdi32.BITMAPINFO@)">
            <summary>
            The <c>ICCompressGetFormat</c> macro requests the output format of the compressed data from a video compression driver. You can
            use this macro or explicitly call the ICM_COMPRESS_GET_FORMAT message.
            </summary>
            <param name="hic">Handle of the compressor.</param>
            <param name="lpbiInput">Pointer to a BITMAPINFO structure containing the input format.</param>
            <param name="lpbiOutput">Pointer to a BITMAPINFO structure containing the output format.</param>
            <returns>None</returns>
            <remarks>
            If lpbiOutput is nonzero, the driver should fill the <c>BITMAPINFO</c> structure with the default output format corresponding to
            the input format specified for lpbiInput. If the compressor can produce several formats, the default format should be the one
            that preserves the greatest amount of information.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICCompressGetFormatSize(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFO@)">
            <summary>
            The <c>ICCompressGetFormatSize</c> macro requests the size of the output format of the compressed data from a video compression
            driver. You can use this macro or explicitly call the ICM_COMPRESS_GET_FORMAT message.
            </summary>
            <param name="hic">Handle of the compressor.</param>
            <param name="lpbi">Pointer to a <c>BITMAPINFO</c> structure containing the input format.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICCompressGetSize(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFO@,Vanara.PInvoke.Gdi32.BITMAPINFO@)">
            <summary>
            The <c>ICCompressGetSize</c> macro requests that the video compression driver supply the maximum size of one frame of data when
            compressed into the specified output format. You can use this macro or explicitly call the ICM_COMPRESS_GET_SIZE message.
            </summary>
            <param name="hic">Handle to a compressor.</param>
            <param name="lpbiInput">Pointer to a BITMAPINFO structure containing the input format.</param>
            <param name="lpbiOutput">Pointer to a BITMAPINFO structure containing the output format.</param>
            <returns>None</returns>
            <remarks>
            <para>Typically, applications send this message to determine how large a buffer to allocate for the compressed frame.</para>
            <para>The driver should calculate the size of the largest possible frame based on the input and output formats.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICCompressorChoose(Vanara.PInvoke.HWND,Vanara.PInvoke.Msvfw32.ICMF_CHOOSE,System.IntPtr,System.IntPtr,Vanara.PInvoke.Msvfw32.COMPVARS@,System.String)">
            <summary>
            The <c>ICCompressorChoose</c> function displays a dialog box in which a user can select a compressor. This function can display
            all registered compressors or list only the compressors that support a specific format.
            </summary>
            <param name="hwnd">Handle to a parent window for the dialog box.</param>
            <param name="uiFlags">
            <para>Applicable flags. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICMF_CHOOSE_ALLCOMPRESSORS</term>
            <term>
            All compressors should appear in the selection list. If this flag is not specified, only the compressors that can handle the
            input format appear in the selection list.
            </term>
            </item>
            <item>
            <term>ICMF_CHOOSE_DATARATE</term>
            <term>Displays a check box and edit box to enter the data rate for the movie.</term>
            </item>
            <item>
            <term>ICMF_CHOOSE_KEYFRAME</term>
            <term>Displays a check box and edit box to enter the frequency of key frames.</term>
            </item>
            <item>
            <term>ICMF_CHOOSE_PREVIEW</term>
            <term>
            Displays a button to expand the dialog box to include a preview window. The preview window shows how frames of your movie will
            appear when compressed with the current settings.
            </term>
            </item>
            </list>
            </param>
            <param name="pvIn">
            Uncompressed data input format. Only compressors that support the specified data input format are included in the compressor
            list. This parameter is optional.
            </param>
            <param name="lpData">
            Pointer to an AVI stream interface to use in the preview window. You must specify a video stream. This parameter is optional.
            </param>
            <param name="pc">Pointer to a COMPVARS structure. The information returned initializes the structure for use with other functions.</param>
            <param name="lpszTitle">Pointer to a null-terminated string containing a title for the dialog box. This parameter is optional.</param>
            <returns>
            Returns <c>TRUE</c> if the user chooses a compressor and presses OK. Returns <c>FALSE</c> on error or if the user presses CANCEL.
            </returns>
            <remarks>
            Before using this function, set the <c>cbSize</c> member of the COMPVARS structure to the size of the structure. Initialize the
            rest of the structure to zeros unless you want to specify some valid defaults for the dialog box. If specifying defaults, set
            the dwFlags member to ICMF_COMPVARS_VALID and initialize the other members of the structure. For more information about
            initializing the structure, see the ICSeqCompressFrameStart function and <c>COMPVARS</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICCompressorFree(Vanara.PInvoke.Msvfw32.COMPVARS@)">
            <summary>The <c>ICCompressorFree</c> function frees the resources in the COMPVARS structure used by other VCM functions.</summary>
            <param name="pc">Pointer to the COMPVARS structure containing the resources to be freed.</param>
            <returns>This function does not return a value.</returns>
            <remarks>
            Use this function to release the resources in the COMPVARS structure after using the ICCompressorChoose,
            ICSeqCompressFrameStart, ICSeqCompressFrame, and ICSeqCompressFrameEnd functions.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICCompressQuery(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFO@,Vanara.PInvoke.Gdi32.BITMAPINFO@)">
            <summary>
            The <c>ICCompressQuery</c> macro queries a video compression driver to determine if it supports a specific input format or if it
            can compress a specific input format to a specific output format. You can use this macro or explicitly call the
            ICM_COMPRESS_QUERY message.
            </summary>
            <param name="hic">Handle to a compressor.</param>
            <param name="lpbiInput">Pointer to a BITMAPINFO structure containing the input format.</param>
            <param name="lpbiOutput">
            Pointer to a BITMAPINFO structure containing the output format. You can specify zero for this parameter to indicate any output
            format is acceptable.
            </param>
            <returns>None</returns>
            <remarks>
            When a driver receives this message, it should examine the BITMAPINFO structure associated with lpbiInput to determine if it can
            compress the input format.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICConfigure(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.HWND)">
            <summary>
            The <c>ICConfigure</c> macro notifies a video compression driver to display its configuration dialog box. You can use this macro
            or explicitly send the ICM_CONFIGURE message.
            </summary>
            <param name="hic">Handle of the compressor.</param>
            <param name="hwnd">Handle of the parent window of the displayed dialog box.</param>
            <returns>None</returns>
            <remarks>
            The ICM_CONFIGURE message is different from the DRV_CONFIGURE message used for hardware configuration. The dialog box for this
            message should let the user set and edit the internal state referenced by the ICGetState and ICSetState macros. For example,
            this dialog box can let the user change parameters affecting the quality level and other similar compression options.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompress(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.ICDECOMPRESSF,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr)">
            <summary>The <c>ICDecompress</c> function decompresses a single video frame.</summary>
            <param name="hic">Handle to the decompressor to use.</param>
            <param name="dwFlags">
            <para>Applicable decompression flags. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICDECOMPRESS_HURRYUP</term>
            <term>
            Tries to decompress at a faster rate. When an application uses this flag, the driver should buffer the decompressed data but not
            draw the image.
            </term>
            </item>
            <item>
            <term>ICDECOMPRESS_NOTKEYFRAME</term>
            <term>Current frame is not a key frame.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_NULLFRAME</term>
            <term>Current frame does not contain data and the decompressed image should be left the same.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_PREROLL</term>
            <term>Current frame precedes the point in the movie where playback starts and, therefore, will not be drawn.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_UPDATE</term>
            <term>Screen is being updated or refreshed.</term>
            </item>
            </list>
            </param>
            <param name="lpbiFormat">Pointer to a BITMAPINFOHEADER structure containing the format of the compressed data.</param>
            <param name="lpData">Pointer to the input data.</param>
            <param name="lpbi">Pointer to a BITMAPINFOHEADER structure containing the output format.</param>
            <param name="lpBits">Pointer to a buffer that is large enough to contain the decompressed data.</param>
            <returns>Returns ICERR_OK if successful or an error otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressBegin(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@)">
            <summary>
            The <c>ICDecompressBegin</c> macro notifies a video decompression driver to prepare to decompress data. You can use this macro
            or explicitly call the ICM_DECOMPRESS_BEGIN message.
            </summary>
            <param name="hic">Handle to a decompressor.</param>
            <param name="lpbiInput">Pointer to a BITMAPINFO structure containing the input format.</param>
            <param name="lpbiOutput">Pointer to a BITMAPINFO structure containing the output format.</param>
            <returns>None</returns>
            <remarks>
            <para>
            When the driver receives this message, it should allocate buffers and do any time-consuming operations so that it can process
            ICM_DECOMPRESS messages efficiently.
            </para>
            <para>
            The <c>ICDecompressBegin</c> and ICDecompressEnd macros do not nest. If your driver receives ICM_DECOMPRESS_BEGIN before
            decompression is stopped with ICM_DECOMPRESS_END, it should restart decompression with new parameters.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressEnd(Vanara.PInvoke.Msvfw32.HIC)">
            <summary>
            The <c>ICDecompressEnd</c> macro notifies a video decompression driver to end decompression and free resources allocated for
            decompression. You can use this macro or explicitly call the ICM_DECOMPRESS_END message.
            </summary>
            <param name="hic">Handle to a decompressor.</param>
            <returns>None</returns>
            <remarks>
            <para>The driver should free any resources allocated for the ICM_DECOMPRESS_BEGIN message.</para>
            <para>
            The ICDecompressBegin and <c>ICDecompressEnd</c> macros do not nest. If your driver receives ICM_DECOMPRESS_BEGIN before
            decompression is stopped with ICM_DECOMPRESS_END, it should restart decompression with new parameters.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressEx(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.ICDECOMPRESSF,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>The <c>ICDecompressEx</c> function decompresses a single video frame.</summary>
            <param name="hic">Handle to the decompressor.</param>
            <param name="dwFlags">
            <para>Decompression flags. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICDECOMPRESS_HURRYUP</term>
            <term>
            Tries to decompress at a faster rate. When an application uses this flag, the driver should buffer the decompressed data but not
            draw the image.
            </term>
            </item>
            <item>
            <term>ICDECOMPRESS_NOTKEYFRAME</term>
            <term>Current frame is not a key frame.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_NULLFRAME</term>
            <term>Current frame does not contain data and the decompressed image should be left the same.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_PREROLL</term>
            <term>Current frame precedes the point in the movie where playback starts and, therefore, will not be drawn.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_UPDATE</term>
            <term>Screen is being updated or refreshed.</term>
            </item>
            </list>
            </param>
            <param name="lpbiSrc">Pointer to a BITMAPINFOHEADER structure containing the format of the compressed data.</param>
            <param name="lpSrc">Pointer to the input data.</param>
            <param name="xSrc">The x-coordinate of the source rectangle for the DIB specified by lpbiSrc.</param>
            <param name="ySrc">The y-coordinate of the source rectangle for the DIB specified by lpbiSrc.</param>
            <param name="dxSrc">Width of the source rectangle.</param>
            <param name="dySrc">Height of the source rectangle.</param>
            <param name="lpbiDst">Pointer to a BITMAPINFOHEADER structure containing the output format.</param>
            <param name="lpDst">Pointer to a buffer that is large enough to contain the decompressed data.</param>
            <param name="xDst">The x-coordinate of the destination rectangle for the DIB specified by lpbiDst.</param>
            <param name="yDst">The y-coordinate of the destination rectangle for the DIB specified by lpbiDst.</param>
            <param name="dxDst">Width of the destination rectangle.</param>
            <param name="dyDst">Height of the destination rectangle.</param>
            <returns>Returns <c>ICERR_OK</c> if successful or an error otherwise.</returns>
            <remarks>
            Typically, applications use the <c>ICDECOMPRESS_PREROLL</c> flag to seek to a key frame in a compressed stream. The flag is sent
            with the key frame and with subsequent frames required to decompress the desired frame.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressExBegin(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.ICDECOMPRESSF,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>The <c>ICDecompressExBegin</c> function prepares a decompressor for decompressing data.</summary>
            <param name="hic">Handle to the decompressor to use.</param>
            <param name="dwFlags">
            <para>Decompression flags. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICDECOMPRESS_HURRYUP</term>
            <term>
            Tries to decompress at a faster rate. When an application uses this flag, the driver should buffer the decompressed data but not
            draw the image.
            </term>
            </item>
            <item>
            <term>ICDECOMPRESS_NOTKEYFRAME</term>
            <term>Current frame is not a key frame.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_NULLFRAME</term>
            <term>Current frame does not contain data and the decompressed image should be left the same.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_PREROLL</term>
            <term>Current frame precedes the point in the movie where playback starts and, therefore, will not be drawn.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_UPDATE</term>
            <term>Screen is being updated or refreshed.</term>
            </item>
            </list>
            </param>
            <param name="lpbiSrc">Pointer to a BITMAPINFOHEADER structure containing the format of the compressed data.</param>
            <param name="lpSrc">Pointer to the input data.</param>
            <param name="xSrc">The x-coordinate of the source rectangle for the DIB specified by lpbiSrc.</param>
            <param name="ySrc">The y-coordinate of the source rectangle for the DIB specified by lpbiSrc.</param>
            <param name="dxSrc">Width of the source rectangle.</param>
            <param name="dySrc">Height of the source rectangle.</param>
            <param name="lpbiDst">Pointer to a BITMAPINFOHEADER structure containing the output format.</param>
            <param name="lpDst">Pointer to a buffer that is large enough to contain the decompressed data.</param>
            <param name="xDst">The x-coordinate of the destination rectangle for the DIB specified by lpbiDst.</param>
            <param name="yDst">The y-coordinate of the destination rectangle for the DIB specified by lpbiDst.</param>
            <param name="dxDst">Width of the destination rectangle.</param>
            <param name="dyDst">Height of the destination rectangle.</param>
            <returns>Returns <c>ICERR_OK</c> if successful or an error otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressExEnd(Vanara.PInvoke.Msvfw32.HIC)">
            <summary>
            The <c>ICDecompressExEnd</c> macro notifies a video decompression driver to end decompression and free resources allocated for
            decompression. You can use this macro or explicitly call the ICM_DECOMPRESSEX_END message.
            </summary>
            <param name="hic">Handle to a decompressor.</param>
            <returns>None</returns>
            <remarks>
            <para>The driver frees any resources allocated for the ICM_DECOMPRESSEX_BEGIN message.</para>
            <para>
            ICM_DECOMPRESSEX_BEGIN and ICM_DECOMPRESSEX_END do not nest. If your driver receives ICM_DECOMPRESSEX_BEGIN before decompression
            is stopped with <c>ICM_DECOMPRESSEX_END</c>, it should restart decompression with new parameters.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressExQuery(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>The <c>ICDecompressExQuery</c> function determines if a decompressor can decompress data with a specific format.</summary>
            <param name="hic">Handle to the decompressor to use.</param>
            <param name="lpbiSrc">Pointer to a BITMAPINFOHEADER structure containing the format of the compressed data to decompress.</param>
            <param name="xSrc">The x-coordinate of the source rectangle for the DIB specified by lpbiSrc.</param>
            <param name="ySrc">The y-coordinate of the source rectangle for the DIB specified by lpbiSrc.</param>
            <param name="dxSrc">Width of the source rectangle.</param>
            <param name="dySrc">Height of the source rectangle.</param>
            <param name="lpbiDst">
            Pointer to a BITMAPINFOHEADER structure containing the output format. If the value of this parameter is <c>NULL</c>, the
            function determines whether the input format is supported and this parameter is ignored.
            </param>
            <param name="lpDst">Pointer to a buffer that is large enough to contain the decompressed data.</param>
            <param name="xDst">The x-coordinate of the destination rectangle for the DIB specified by lpbiDst.</param>
            <param name="yDst">The y-coordinate of the destination rectangle for the DIB specified by lpbiDst.</param>
            <param name="dxDst">Width of the destination rectangle.</param>
            <param name="dyDst">Height of the destination rectangle.</param>
            <returns>Returns <c>ICERR_OK</c> if successful or an error otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressGetFormat(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFO@,Vanara.PInvoke.Gdi32.BITMAPINFO@)">
            <summary>
            The <c>ICDecompressGetFormat</c> macro requests the output format of the decompressed data from a video decompression driver.
            You can use this macro or explicitly call the ICM_DECOMPRESS_GET_FORMAT message.
            </summary>
            <param name="hic">Handle to a decompressor.</param>
            <param name="lpbiInput">Pointer to a BITMAPINFO structure containing the input format.</param>
            <param name="lpbiOutput">
            Pointer to a BITMAPINFO structure to contain the output format. You can specify zero to request only the size of the output
            format, as in the ICDecompressGetFormatSize macro.
            </param>
            <returns>None</returns>
            <remarks>
            If lpbiOutput is nonzero, the driver should fill the BITMAPINFO structure with the default output format corresponding to the
            input format specified for lpbiInput. If the compressor can produce several formats, the default format should be the one that
            preserves the greatest amount of information.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressGetFormatSize(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFO@)">
            <summary>
            The <c>ICDecompressGetFormatSize</c> macro requests the size of the output format of the decompressed data from a video
            decompression driver. You can use this macro or explicitly call the ICM_DECOMPRESS_GET_FORMAT message.
            </summary>
            <param name="hic">Handle to a decompressor.</param>
            <param name="lpbi">Pointer to a BITMAPINFO structure containing the input format.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressGetPalette(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@)">
            <summary>
            The <c>ICDecompressGetPalette</c> macro requests that the video decompression driver supply the color table of the output
            BITMAPINFOHEADER structure. You can use this macro or explicitly call the ICM_DECOMPRESS_GET_PALETTE message.
            </summary>
            <param name="hic">Handle to a decompressor.</param>
            <param name="lpbiInput">Pointer to a BITMAPINFOHEADER structure containing the input format.</param>
            <param name="lpbiOutput">
            Pointer to a BITMAPINFOHEADER structure to contain the color table. The space reserved for the color table is always at least
            256 colors. You can specify zero for this parameter to return only the size of the color table.
            </param>
            <returns>None</returns>
            <remarks>
            <para>
            If lpbiOutput is nonzero, the driver sets the <c>biClrUsed</c> member of BITMAPINFOHEADER to the number of colors in the color
            table. The driver fills the <c>bmiColors</c> members of BITMAPINFO with the actual colors.
            </para>
            <para>The driver should support this message only if it uses a palette other than the one specified in the input format.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressOpen(System.UInt32,System.UInt32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@)">
            <summary>The <c>ICDecompressOpen</c> macro opens a decompressor that is compatible with the specified formats.</summary>
            <param name="fccType">
            Four-character code indicating the type of compressor to open. For video streams, the value of this parameter is "VIDC" or ICTYPE_VIDEO.
            </param>
            <param name="fccHandler">
            Four-character code indicating the preferred stream handler to use. Typically, this information is stored in the stream header
            in an AVI file.
            </param>
            <param name="lpbiIn">
            Pointer to a structure defining the input format. A decompressor handle is not returned unless it can decompress this format.
            For bitmaps, this parameter refers to a BITMAPINFOHEADER structure.
            </param>
            <param name="lpbiOut">
            <para>
            Pointer to a structure defining an optional decompression format. You can also specify zero to use the default output format
            associated with the input format.
            </para>
            <para>
            If this parameter is nonzero, a compressor handle is not returned unless it can create this output format. For bitmaps, this
            parameter refers to a BITMAPINFOHEADER structure.
            </para>
            </param>
            <returns>None</returns>
            <remarks>
            <para>The <c>ICDecompressOpen</c> macro is defined as follows:</para>
            <para>
            <code> #define ICDecompressOpen(fccType, fccHandler, lpbiIn, lpbiOut) \ ICLocate(fccType, fccHandler, lpbiIn, lpbiOut, ICMODE_DECOMPRESS);</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressOpen(System.UInt32,System.UInt32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@)">
            <summary>The <c>ICDecompressOpen</c> macro opens a decompressor that is compatible with the specified formats.</summary>
            <param name="fccType">
            Four-character code indicating the type of compressor to open. For video streams, the value of this parameter is "VIDC" or ICTYPE_VIDEO.
            </param>
            <param name="fccHandler">
            Four-character code indicating the preferred stream handler to use. Typically, this information is stored in the stream header
            in an AVI file.
            </param>
            <param name="lpbiIn">
            Pointer to a structure defining the input format. A decompressor handle is not returned unless it can decompress this format.
            For bitmaps, this parameter refers to a BITMAPINFOHEADER structure.
            </param>
            <returns>None</returns>
            <remarks>
            <para>The <c>ICDecompressOpen</c> macro is defined as follows:</para>
            <para>
            <code> #define ICDecompressOpen(fccType, fccHandler, lpbiIn, lpbiOut) \ ICLocate(fccType, fccHandler, lpbiIn, lpbiOut, ICMODE_DECOMPRESS);</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressQuery(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFO@,Vanara.PInvoke.Gdi32.BITMAPINFO@)">
            <summary>
            The <c>ICDecompressQuery</c> macro queries a video decompression driver to determine if it supports a specific input format or
            if it can decompress a specific input format to a specific output format. You can use this macro or explicitly call the
            ICM_DECOMPRESS_QUERY message.
            </summary>
            <param name="hic">Handle to a decompressor.</param>
            <param name="lpbiInput">Pointer to a BITMAPINFO structure containing the input format.</param>
            <param name="lpbiOutput">
            Pointer to a BITMAPINFO structure containing the output format. You can specify zero for this parameter to indicate any output
            format is acceptable.
            </param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDecompressSetPalette(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.SafeBITMAPINFO)">
            <summary>
            The <c>ICDecompressSetPalette</c> macro specifies a palette for a video decompression driver to use if it is decompressing to a
            format that uses a palette. You can use this macro or explicitly call the ICM_DECOMPRESS_SET_PALETTE message.
            </summary>
            <param name="hic">Handle to a decompressor.</param>
            <param name="lpbiPalette">
            Pointer to a BITMAPINFOHEADER structure whose color table contains the colors that should be used if possible. You can specify
            zero to use the default set of output colors.
            </param>
            <returns>None</returns>
            <remarks>
            <para>
            This macro should not affect decompression already in progress; rather, colors passed using this message should be returned in
            response to future ICDecompressGetFormat and ICDecompressGetPalette macros. Colors are sent back to the decompression driver in
            a future ICDecompressBegin macro.
            </para>
            <para>
            This macro is used primarily when a driver decompresses images to the screen and another application that uses a palette is in
            the foreground, forcing the decompression driver to adapt to a foreign set of colors.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDraw(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.ICDRAWF,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.UInt32,System.Int32)">
            <summary>The <c>ICDraw</c> function decompresses an image for drawing.</summary>
            <param name="hic">Handle to an decompressor.</param>
            <param name="dwFlags">
            <para>Decompression flags. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICDRAW_HURRYUP</term>
            <term>Data is buffered and not drawn to the screen. Use this flag for fastest decompression.</term>
            </item>
            <item>
            <term>ICDRAW_NOTKEYFRAME</term>
            <term>Current frame is not a key frame.</term>
            </item>
            <item>
            <term>ICDRAW_NULLFRAME</term>
            <term>Current frame does not contain any data and the previous frame should be redrawn.</term>
            </item>
            <item>
            <term>ICDRAW_PREROLL</term>
            <term>
            Current frame of video occurs before playback should start. For example, if playback will begin on frame 10, and frame 0 is the
            nearest previous key frame, frames 0 through 9 are sent to the driver with the ICDRAW_PREROLL flag set. The driver needs this
            data to display frame 10 properly.
            </term>
            </item>
            <item>
            <term>ICDRAW_UPDATE</term>
            <term>Updates the screen based on previously received data. Set lpData to NULL when this flag is used.</term>
            </item>
            </list>
            </param>
            <param name="lpFormat">Pointer to a BITMAPINFOHEADER structure containing the input format of the data.</param>
            <param name="lpData">Pointer to the input data.</param>
            <param name="cbData">Size of the input data, in bytes.</param>
            <param name="lTime">
            Time, in samples, to draw this frame. The units for video data are frames. For a definition of the playback rate, see the
            <c>dwRate</c> and <c>dwScale</c> members of the ICDRAWBEGIN structure.
            </param>
            <returns>Returns <c>ICERR_OK</c> if successful or an error otherwise.</returns>
            <remarks>
            You can initiate drawing the frames by sending the ICM_DRAW_START message (or by using the ICDrawStart macro). The application
            should be sure to buffer the required number of frames before drawing is started. Send the <c>KM_GETBUFFERSWANTED</c> message
            (or use the ICGetBuffersWanted macro) to obtain this value.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawBegin(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.ICDRAWF,Vanara.PInvoke.HPALETTE,Vanara.PInvoke.HWND,Vanara.PInvoke.HDC,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32,System.UInt32)">
            <summary>The <c>ICDrawBegin</c> function initializes the renderer and prepares the drawing destination for drawing.</summary>
            <param name="hic">Handle to the decompressor to use.</param>
            <param name="dwFlags">
            <para>Decompression flags. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICDRAW_ANIMATE</term>
            <term>Application can animate the palette.</term>
            </item>
            <item>
            <term>ICDRAW_CONTINUE</term>
            <term>Drawing is a continuation of the previous frame.</term>
            </item>
            <item>
            <term>ICDRAW_FULLSCREEN</term>
            <term>Draws the decompressed data on the full screen.</term>
            </item>
            <item>
            <term>ICDRAW_HDC</term>
            <term>Draws the decompressed data to a window or a DC.</term>
            </item>
            <item>
            <term>ICDRAW_MEMORYDC</term>
            <term>DC is off-screen.</term>
            </item>
            <item>
            <term>ICDRAW_QUERY</term>
            <term>Determines if the decompressor can decompress the data. The driver does not decompress the data.</term>
            </item>
            <item>
            <term>ICDRAW_UPDATING</term>
            <term>Current frame is being updated rather than played.</term>
            </item>
            </list>
            </param>
            <param name="hpal">Handle to the palette used for drawing.</param>
            <param name="hwnd">Handle to the window used for drawing.</param>
            <param name="hdc">DC used for drawing.</param>
            <param name="xDst">The x-coordinate of the upper right corner of the destination rectangle.</param>
            <param name="yDst">The y-coordinate of the upper right corner of the destination rectangle.</param>
            <param name="dxDst">Width of the destination rectangle.</param>
            <param name="dyDst">Height of the destination rectangle.</param>
            <param name="lpbi">Pointer to a BITMAPINFOHEADER structure containing the format of the input data to be decompressed.</param>
            <param name="xSrc">The x-coordinate of the upper right corner of the source rectangle.</param>
            <param name="ySrc">The y-coordinate of the upper right corner of the source rectangle.</param>
            <param name="dxSrc">Width of the source rectangle.</param>
            <param name="dySrc">Height of the source rectangle.</param>
            <param name="dwRate">Frame rate numerator. The frame rate, in frames per second, is obtained by dividing dwRate by dwScale.</param>
            <param name="dwScale">Frame rate denominator. The frame rate, in frames per second, is obtained by dividing dwRate by dwScale.</param>
            <returns>Returns ICERR_OK if the renderer can decompress the data or <c>ICERR_UNSUPPORTED</c> otherwise.</returns>
            <remarks>
            <para>
            The <c>ICDRAW_HDC</c> and <c>ICDRAW_FULLSCREEN</c> flags are mutually exclusive. If an application sets the ICDRAW_HDC flag in
            dwFlags, the decompressor uses hwnd, hdc, and the parameters defining the destination rectangle (xDst, yDst, dxDst, and dyDst).
            Your application should set these parameters to the size of the destination rectangle. Specify destination rectangle values
            relative to the current window or DC.
            </para>
            <para>
            If an application sets the <c>ICDRAW_FULLSCREEN</c> flag in dwFlags, the hwnd and hdc parameters are not used and should be set
            to <c>NULL</c>. Also, the destination rectangle is not used and its parameters can be set to zero.
            </para>
            <para>
            The source rectangle is relative to the full video frame. The portion of the video frame specified by the source rectangle is
            stretched or shrunk to fit the destination rectangle.
            </para>
            <para>
            The dwRate and dwScale parameters specify the decompression rate. The integer value specified for dwRate divided by the integer
            value specified for dwScale defines the frame rate in frames per second. This value is used by the renderer when it is
            responsible for timing frames during playback.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawChangePalette(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFO@)">
            <summary>
            The <c>ICDrawChangePalette</c> macro notifies a rendering driver that the movie palette is changing. You can use this macro or
            explicitly call the ICM_DRAW_CHANGEPALETTE message.
            </summary>
            <param name="hic">Handle to a rendering driver.</param>
            <param name="lpbiInput">Pointer to a BITMAPINFO structure containing the new format and optional color table.</param>
            <returns>None</returns>
            <remarks>
            This message should be supported by installable rendering handlers that draw DIBs with an internal structure that includes a palette.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawEnd(Vanara.PInvoke.Msvfw32.HIC)">
            <summary>
            The <c>ICDrawEnd</c> macro notifies a rendering driver to decompress the current image to the screen and to release resources
            allocated for decompression and drawing. You can use this macro or explicitly call the ICM_DRAW_END message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <returns>None</returns>
            <remarks>
            The ICM_DRAW_BEGIN and ICM_DRAW_END messages do not nest. If your driver receives <c>ICM_DRAW_BEGIN</c> before decompression is
            stopped with <c>ICM_DRAW_END</c>, it should restart decompression with new parameters.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawFlush(Vanara.PInvoke.Msvfw32.HIC)">
            <summary>
            The <c>ICDrawFlush</c> macro notifies a rendering driver to render the contents of any image buffers that are waiting to be
            drawn. You can use this macro or explicitly call the ICM_DRAW_FLUSH message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <returns>None</returns>
            <remarks>This message is used only by hardware that performs its own asynchronous decompression, timing, and drawing.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawGetTime(Vanara.PInvoke.Msvfw32.HIC,System.Int32@)">
            <summary>
            The <c>ICDrawGetTime</c> macro requests a rendering driver that controls the timing of drawing frames to return the current
            value of its internal clock. You can use this macro or explicitly call the ICM_DRAW_GETTIME message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <param name="lplTime">Address to contain the current time. The return value should be specified in samples.</param>
            <returns>None</returns>
            <remarks>
            This message is generally supported by hardware that performs its own asynchronous decompression, timing, and drawing. The
            message can also be sent if the hardware is being used as the synchronization master.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawOpen(System.UInt32,System.UInt32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@)">
            <summary>The <c>ICDrawOpen</c> macro opens a driver that can draw images with the specified format.</summary>
            <param name="fccType">
            Four-character code indicating the type of driver to open. For video streams, the value of this parameter is "VIDC" or ICTYPE_VIDEO.
            </param>
            <param name="fccHandler">
            Four-character code indicating the preferred stream handler to use. Typically, this information is stored in the stream header
            in an AVI file.
            </param>
            <param name="lpbiIn">
            Pointer to the structure defining the input format. A driver handle will not be returned unless it can decompress this format.
            For images, this parameter refers to a BITMAPINFOHEADER structure.
            </param>
            <returns>None</returns>
            <remarks>
            <para>The <c>ICDrawOpen</c> macro is defined as follows:</para>
            <para>
            <code> #define ICDrawOpen(fccType, fccHandler, lpbiIn) \ ICLocate(fccType, fccHandler, lpbiIn, NULL, ICMODE_DRAW);</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawQuery(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.SafeBITMAPINFO)">
            <summary>
            The <c>ICDrawQuery</c> macro queries a rendering driver to determine if it can render data in a specific format. You can use
            this macro or explicitly call the ICM_DRAW_QUERY message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <param name="lpbiInput">Pointer to a BITMAPINFO structure containing the input format.</param>
            <returns>None</returns>
            <remarks>
            This macro differs from the ICDrawBegin macro in that it queries the driver in a general sense. <c>ICDrawBegin</c> determines if
            the driver can draw the data using the specified format under specific conditions, such as stretching the image.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawRealize(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.HDC,System.Boolean)">
            <summary>
            The <c>ICDrawRealize</c> macro notifies a rendering driver to realize its drawing palette while drawing. You can use this macro
            or explicitly call the ICM_DRAW_REALIZE message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <param name="hdc">Handle of the DC used to realize the palette.</param>
            <param name="fBackground">
            Background flag. Specify <c>TRUE</c> to realize the palette as a background task or <c>FALSE</c> to realize the palette in the foreground.
            </param>
            <returns>None</returns>
            <remarks>Drivers need to respond to this message only if the drawing palette is different from the decompressed palette.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawRenderBuffer(Vanara.PInvoke.Msvfw32.HIC)">
            <summary>
            The <c>ICDrawRenderBuffer</c> macro notifies a rendering driver to draw the frames that have been passed to it. You can use this
            macro or explicitly call the ICM_DRAW_RENDERBUFFER message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <returns>None</returns>
            <remarks>
            <para>Use this message with hardware that performs its own asynchronous decompression, timing, and drawing.</para>
            <para>
            This message is typically used to perform a seek operation when the driver must be specifically instructed to display each video
            frame passed to it rather than playing a sequence of video frames.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawSetTime(Vanara.PInvoke.Msvfw32.HIC,System.Int32)">
            <summary>
            The <c>ICDrawSetTime</c> macro provides synchronization information to a rendering driver that handles the timing of drawing
            frames. The synchronization information is the sample number of the frame to draw. You can use this macro or explicitly call the
            ICM_DRAW_SETTIME message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <param name="lTime">Sample number of the frame to render.</param>
            <returns>None</returns>
            <remarks>
            <para>
            Typically, the driver compares the specified value with the frame number associated with the time of its internal clock and
            attempts to synchronize the two if the difference is significant.
            </para>
            <para>
            Use this message when the hardware performs its own asynchronous decompression, timing, and drawing, and the hardware relies on
            an external synchronization signal (the hardware is not being used as the synchronization master).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawStart(Vanara.PInvoke.Msvfw32.HIC)">
            <summary>
            The <c>ICDrawStart</c> macro notifies a rendering driver to start its internal clock for the timing of drawing frames. You can
            use this macro or explicitly call the ICM_DRAW_START message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <returns>None</returns>
            <remarks>
            <para>This message is used by hardware that performs its own asynchronous decompression, timing, and drawing.</para>
            <para>When the driver receives this message, it should start rendering data at the rate specified with the ICM_DRAW_BEGIN message.</para>
            <para>
            The <c>ICDrawStart</c> and ICDrawStop macros do not nest. If your driver receives <c>ICDrawStart</c> before rendering is stopped
            with <c>ICDrawStop</c>, it should restart rendering with new parameters.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawStartPlay(Vanara.PInvoke.Msvfw32.HIC,System.Int32,System.Int32)">
            <summary>
            The <c>ICDrawStartPlay</c> macro provides the start and end times of a play operation to a rendering driver. You can use this
            macro or explicitly call the ICM_DRAW_START_PLAY message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <param name="lFrom">Start time.</param>
            <param name="lTo">End time.</param>
            <returns>None</returns>
            <remarks>
            <para>This message precedes any frame data sent to the rendering driver.</para>
            <para>
            Units for lFrom and lTo are specified with the ICM_DRAW_BEGIN message. For video data this is normally a frame number. For more
            information about the playback rate, see the <c>dwRate</c> and <c>dwScale</c> members of the ICDRAWBEGIN structure.
            </para>
            <para>If the end time is less than the start time, the playback direction is reversed.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawStop(Vanara.PInvoke.Msvfw32.HIC)">
            <summary>
            The <c>ICDrawStop</c> macro notifies a rendering driver to stop its internal clock for the timing of drawing frames. You can use
            this macro or explicitly call the ICM_DRAW_STOP message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <returns>None</returns>
            <remarks>This macro is used by hardware that performs its own asynchronous decompression, timing, and drawing.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawStopPlay(Vanara.PInvoke.Msvfw32.HIC)">
            <summary>
            The <c>ICDrawStopPlay</c> macro notifies a rendering driver when a play operation is complete. You can use this macro or
            explicitly call the ICM_DRAW_STOP_PLAY message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <returns>None</returns>
            <remarks>Use this message when the play operation is complete. Use the ICDrawStop macro to end timing.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawSuggestFormat(Vanara.PInvoke.Msvfw32.HIC,System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.Msvfw32.HIC)">
            <summary>The <c>ICDrawSuggestFormat</c> function notifies the drawing handler to suggest the input data format.</summary>
            <param name="hic">Handle to the driver to use.</param>
            <param name="lpbiIn">
            Pointer to a structure containing the format of the compressed data. For bitmaps, this is a BITMAPINFOHEADER structure.
            </param>
            <param name="lpbiOut">
            Pointer to a structure to return the suggested format. The drawing handler can receive and draw data from this format. For
            bitmaps, this is a BITMAPINFOHEADER structure.
            </param>
            <param name="dxSrc">Width of the source rectangle.</param>
            <param name="dySrc">Height of the source rectangle.</param>
            <param name="dxDst">Width of the destination rectangle.</param>
            <param name="dyDst">Height of the destination rectangle.</param>
            <param name="hicDecomp">Decompressor that can use the format of data in lpbiIn.</param>
            <returns>Returns <c>ICERR_OK</c> if successful or an error otherwise.</returns>
            <remarks>
            <para>
            Applications can use this function to determine alternative input formats that a drawing handler can decompress and if the
            drawing handler can stretch data. If the drawing handler cannot stretch data as requested, the application might have to stretch
            the data.
            </para>
            <para>
            If the drawing handler cannot decompress a format provided by an application, use the ICDecompress, ICDecompressEx, j,
            ICDecompressExQuery, and ICDecompressOpen functions to obtain alternate formats.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICDrawWindow(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.RECT@)">
            <summary>
            The <c>ICDrawWindow</c> macro notifies a rendering driver that the window specified for the ICM_DRAW_BEGIN message needs to be
            redrawn. The window has moved or become temporarily obscured. You can use this macro or explicitly call the ICM_DRAW_WINDOW message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <param name="prc">
            Pointer to the destination rectangle in screen coordinates. If this parameter points to an empty rectangle, drawing should be
            turned off.
            </param>
            <returns>None</returns>
            <remarks>
            <para>This message is supported by hardware that performs its own asynchronous decompression, timing, and drawing.</para>
            <para>
            Video-overlay drivers use this message to draw when the window is obscured or moved. When a window specified for ICM_DRAW_BEGIN
            is completely hidden by other windows, the destination rectangle is empty. Drivers should turn off video-overlay hardware when
            this condition occurs.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICGetBuffersWanted(Vanara.PInvoke.Msvfw32.HIC,System.UInt32@)">
            <summary>
            The <c>ICGetBuffersWanted</c> macro queries a driver for the number of buffers to allocate. You can use this macro or explicitly
            call the ICM_GETBUFFERSWANTED message.
            </summary>
            <param name="hic">Handle to a driver.</param>
            <param name="lpdwBuffers">Address to contain the number of samples the driver needs to efficiently render the data.</param>
            <returns>None</returns>
            <remarks>
            This message is used by drivers that use hardware to render data and want to ensure a minimal time lag caused by waiting for
            buffers to arrive. For example, if a driver controls a video decompression board that can hold 10 frames of video, it could
            return 10 for this message. This instructs applications to try to stay 10 frames ahead of the frame it currently needs.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICGetDefaultKeyFrameRate(Vanara.PInvoke.Msvfw32.HIC,System.UInt32@)">
            <summary>
            The <c>ICGetDefaultKeyFrameRate</c> macro queries a video compression driver for its default (or preferred) key-frame spacing.
            You can use this macro or explicitly call the ICM_GETDEFAULTKEYFRAMERATE message.
            </summary>
            <param name="hic">Handle to a compressor.</param>
            <param name="dwICValue">Address to contain the preferred key-frame spacing.</param>
            <returns>None</returns>
            <remarks>The <c>ICGetDefaultKeyFrameRate</c> macro returns the default key frame rate.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICGetDefaultQuality(Vanara.PInvoke.Msvfw32.HIC,System.UInt32@)">
            <summary>
            The <c>ICGetDefaultQuality</c> macro queries a video compression driver to provide its default quality setting. You can use this
            macro or explicitly call the ICM_GETDEFAULTQUALITY message.
            </summary>
            <param name="hic">Handle to a compressor.</param>
            <param name="dwICValue">Address to contain the default quality value. Quality values range from 0 to 10,000.</param>
            <returns>None</returns>
            <remarks>The <c>ICGetDefaultQuality</c> macro returns the default quality value.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICGetDisplayFormat(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            The <c>ICGetDisplayFormat</c> function determines the best format available for displaying a compressed image. The function also
            opens a compressor if a handle of an open compressor is not specified.
            </summary>
            <param name="hic">Handle to the compressor to use. Specify <c>NULL</c> to have VCM select and open an appropriate compressor.</param>
            <param name="lpbiIn">Pointer to BITMAPINFOHEADER structure containing the compressed format.</param>
            <param name="lpbiOut">
            Pointer to a buffer to return the decompressed format. The buffer should be large enough for a BITMAPINFOHEADER structure and
            256 color entries.
            </param>
            <param name="BitDepth">Preferred bit depth, if nonzero.</param>
            <param name="dx">Width multiplier to stretch the image. If this parameter is zero, that dimension is not stretched.</param>
            <param name="dy">Height multiplier to stretch the image. If this parameter is zero, that dimension is not stretched.</param>
            <returns>Returns a handle to a decompressor if successful or zero otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICGetInfo(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.ICINFO@,System.UInt32)">
            <summary>The <c>ICGetInfo</c> function obtains information about a compressor.</summary>
            <param name="hic">Handle to a compressor.</param>
            <param name="picinfo">Pointer to the ICINFO structure to return information about the compressor.</param>
            <param name="cb">Size, in bytes, of the structure pointed to by lpicinfo.</param>
            <returns>Returns the number of bytes copied into the structure or zero if an error occurs.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICGetState(Vanara.PInvoke.Msvfw32.HIC,System.IntPtr,System.UInt32)">
            <summary>
            The <c>ICGetState</c> macro queries a video compression driver to return its current configuration in a block of memory. You can
            use this macro or explicitly call the ICM_GETSTATE message.
            </summary>
            <param name="hic">Handle of the compressor.</param>
            <param name="pv">
            Pointer to a block of memory to contain the current configuration information. You can specify <c>NULL</c> for this parameter to
            determine the amount of memory required for the configuration information, as in ICGetStateSize.
            </param>
            <param name="cb">Size, in bytes, of the block of memory.</param>
            <returns>None</returns>
            <remarks>
            <para>The ICGetStateSize macro returns the number of bytes used by the state data.</para>
            <para>The structure used to represent configuration information is driver specific and is defined by the driver.</para>
            <para>Use ICGetStateSize before calling the <c>ICGetState</c> macro to determine the size of buffer to allocate for the call.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICGetStateSize(Vanara.PInvoke.Msvfw32.HIC,System.UInt32@)">
            <summary>
            The <c>ICGetStateSize</c> macro queries a video compression driver to determine the amount of memory required to retrieve the
            configuration information. You can use this macro or explicitly call the ICM_GETSTATE message.
            </summary>
            <param name="hic">Handle of the compressor.</param>
            <param name="size">The size, in bytes, of the buffer needed to hold state.</param>
            <returns>None</returns>
            <remarks>
            <para>The structure used to represent configuration information is driver specific and is defined by the driver.</para>
            <para>Use <c>ICGetStateSize</c> before calling the ICGetState macro to determine the size of buffer to allocate for the call.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICImageCompress(Vanara.PInvoke.Msvfw32.HIC,System.UInt32,Vanara.PInvoke.Gdi32.BITMAPINFO@,System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            The <c>ICImageCompress</c> function compresses an image to a given size. This function does not require initialization functions.
            </summary>
            <param name="hic">
            Handle to a compressor opened with the ICOpen function. Specify <c>NULL</c> to have VCM select an appropriate compressor for the
            compression format. An application can have the user select the compressor by using the ICCompressorChoose function, which opens
            the selected compressor and returns a handle of the compressor in this parameter.
            </param>
            <param name="uiFlags">Reserved; must be zero.</param>
            <param name="lpbiIn">Pointer to the BITMAPINFO structure containing the input data format.</param>
            <param name="lpBits">Pointer to input data bits to compress. The data bits exclude header and format information.</param>
            <param name="lpbiOut">
            Pointer to the BITMAPINFO structure containing the compressed output format. Specify <c>NULL</c> to have the compressor use an
            appropriate format.
            </param>
            <param name="lQuality">Quality value used by the compressor. Values range from 0 to 10,000.</param>
            <param name="plSize">
            Maximum size desired for the compressed image. The compressor might not be able to compress the data to fit within this size.
            When the function returns, this parameter points to the size of the compressed image. Image sizes are specified in bytes.
            </param>
            <returns>Returns a handle to a compressed DIB. The image data follows the format header.</returns>
            <remarks>
            To obtain the format information from the BITMAPINFOHEADER structure, use the GlobalLock function to lock the data. Use the
            GlobalFree function to free the DIB when you are finished.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICImageCompress(Vanara.PInvoke.Msvfw32.HIC,System.UInt32,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            The <c>ICImageCompress</c> function compresses an image to a given size. This function does not require initialization functions.
            </summary>
            <param name="hic">
            Handle to a compressor opened with the ICOpen function. Specify <c>NULL</c> to have VCM select an appropriate compressor for the
            compression format. An application can have the user select the compressor by using the ICCompressorChoose function, which opens
            the selected compressor and returns a handle of the compressor in this parameter.
            </param>
            <param name="uiFlags">Reserved; must be zero.</param>
            <param name="lpbiIn">Pointer to the BITMAPINFO structure containing the input data format.</param>
            <param name="lpBits">Pointer to input data bits to compress. The data bits exclude header and format information.</param>
            <param name="lpbiOut">
            Pointer to the BITMAPINFO structure containing the compressed output format. Specify <c>NULL</c> to have the compressor use an
            appropriate format.
            </param>
            <param name="lQuality">Quality value used by the compressor. Values range from 0 to 10,000.</param>
            <param name="plSize">
            Maximum size desired for the compressed image. The compressor might not be able to compress the data to fit within this size.
            When the function returns, this parameter points to the size of the compressed image. Image sizes are specified in bytes.
            </param>
            <returns>Returns a handle to a compressed DIB. The image data follows the format header.</returns>
            <remarks>
            To obtain the format information from the BITMAPINFOHEADER structure, use the GlobalLock function to lock the data. Use the
            GlobalFree function to free the DIB when you are finished.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICImageDecompress(Vanara.PInvoke.Msvfw32.HIC,System.UInt32,Vanara.PInvoke.Gdi32.BITMAPINFO@,System.IntPtr,System.IntPtr)">
            <summary>The <c>ICImageDecompress</c> function decompresses an image without using initialization functions.</summary>
            <param name="hic">
            Handle to a decompressor opened with the ICOpen function. Specify <c>NULL</c> to have VCM select an appropriate decompressor for
            the compressed image.
            </param>
            <param name="uiFlags">Reserved; must be zero.</param>
            <param name="lpbiIn">Compressed input data format.</param>
            <param name="lpBits">Pointer to input data bits to compress. The data bits exclude header and format information.</param>
            <param name="lpbiOut">Decompressed output format. Specify <c>NULL</c> to let decompressor use an appropriate format.</param>
            <returns>
            Returns a handle to an uncompressed DIB in the CF_DIB format if successful or <c>NULL</c> otherwise. Image data follows the
            format header.
            </returns>
            <remarks>
            To obtain the format information from the <c>LPBITMAPINFOHEADER</c> structure, use the <c>GlobalLock</c> function to lock the
            data. Use the <c>GlobalFree</c> function to free the DIB when you are finished.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICImageDecompress(Vanara.PInvoke.Msvfw32.HIC,System.UInt32,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>The <c>ICImageDecompress</c> function decompresses an image without using initialization functions.</summary>
            <param name="hic">
            Handle to a decompressor opened with the ICOpen function. Specify <c>NULL</c> to have VCM select an appropriate decompressor for
            the compressed image.
            </param>
            <param name="uiFlags">Reserved; must be zero.</param>
            <param name="lpbiIn">Compressed input data format.</param>
            <param name="lpBits">Pointer to input data bits to compress. The data bits exclude header and format information.</param>
            <param name="lpbiOut">Decompressed output format. Specify <c>NULL</c> to let decompressor use an appropriate format.</param>
            <returns>
            Returns a handle to an uncompressed DIB in the CF_DIB format if successful or <c>NULL</c> otherwise. Image data follows the
            format header.
            </returns>
            <remarks>
            To obtain the format information from the <c>LPBITMAPINFOHEADER</c> structure, use the <c>GlobalLock</c> function to lock the
            data. Use the <c>GlobalFree</c> function to free the DIB when you are finished.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICInfo(System.UInt32,System.UInt32,Vanara.PInvoke.Msvfw32.ICINFO@)">
            <summary>
            The <c>ICInfo</c> function retrieves information about specific installed compressors or enumerates the installed compressors.
            </summary>
            <param name="fccType">Four-character code indicating the type of compressor. Specify zero to match all compressor types.</param>
            <param name="fccHandler">
            Four-character code identifying a specific compressor or a number between zero and the number of installed compressors of the
            type specified by fccType.
            </param>
            <param name="lpicinfo">Pointer to a ICINFO structure to return information about the compressor.</param>
            <returns>Returns <c>TRUE</c> if successful or an error otherwise.</returns>
            <remarks>
            To enumerate the compressors or decompressors, specify an integer for fccHandler. This function returns information for integers
            between zero and the number of installed compressors or decompressors of the type specified for fccType.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICInstall(System.UInt32,System.UInt32,System.IntPtr,System.String,Vanara.PInvoke.Msvfw32.ICINSTALL)">
            <summary>The <c>ICInstall</c> function installs a new compressor or decompressor.</summary>
            <param name="fccType">
            Four-character code indicating the type of data used by the compressor or decompressor. Specify "VIDC" for a video compressor or decompressor.
            </param>
            <param name="fccHandler">Four-character code identifying a specific compressor or decompressor.</param>
            <param name="lParam">
            Pointer to a null-terminated string containing the name of the compressor or decompressor, or the address of a function used for
            compression or decompression. The contents of this parameter are defined by the flags set for wFlags.
            </param>
            <param name="szDesc">Reserved; do not use.</param>
            <param name="wFlags">
            <para>Flags defining the contents of lParam. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICINSTALL_DRIVER</term>
            <term>The lParam parameter contains the address of a null-terminated string that names the compressor to install.</term>
            </item>
            <item>
            <term>ICINSTALL_FUNCTION</term>
            <term>
            The lParam parameter contains the address of a compressor function. This function should be structured like the DriverProc entry
            point function used by compressors.
            </term>
            </item>
            </list>
            </param>
            <returns>Returns ICERR_OK if successful or an error otherwise.</returns>
            <remarks>
            <para>Applications must open an installed compressor or decompressor before using it.</para>
            <para>
            If your application installs a function as a compressor or decompressor, it should remove the function with the ICRemove
            function before it terminates. This prevents other applications from trying to access the function when it is not available.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICLocate(System.UInt32,System.UInt32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,Vanara.PInvoke.Msvfw32.ICMODE)">
            <summary>
            The <c>ICLocate</c> function finds a compressor or decompressor that can handle images with the specified formats, or finds a
            driver that can decompress an image with a specified format directly to hardware.
            </summary>
            <param name="fccType">
            Four-character code indicating the type of compressor or decompressor to open. For video streams, the value of this parameter is 'VIDC'.
            </param>
            <param name="fccHandler">
            Preferred handler of the specified type. Typically, the handler type is stored in the stream header in an AVI file. Specify
            <c>NULL</c> if your application can use any handler type or it does not know the handler type to use.
            </param>
            <param name="lpbiIn">
            Pointer to a BITMAPINFOHEADER structure defining the input format. A compressor handle is not returned unless it supports this format.
            </param>
            <param name="lpbiOut">
            <para>
            Pointer to a BITMAPINFOHEADER structure defining an optional decompressed format. You can also specify zero to use the default
            output format associated with the input format.
            </para>
            <para>If this parameter is nonzero, a compressor handle is not returned unless it can create this output format.</para>
            </param>
            <param name="wFlags">
            <para>Flags that describe the search criteria for a compressor or decompressor. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICMODE_COMPRESS</term>
            <term>Finds a compressor that can compress an image with a format defined by lpbiIn to the format defined by lpbiOut.</term>
            </item>
            <item>
            <term>ICMODE_DECOMPRESS</term>
            <term>Finds a decompressor that can decompress an image with a format defined by lpbiIn to the format defined by lpbiOut.</term>
            </item>
            <item>
            <term>ICMODE_DRAW</term>
            <term>Finds a decompressor that can decompress an image with a format defined by lpbiIn and draw it directly to hardware.</term>
            </item>
            <item>
            <term>ICMODE_FASTCOMPRESS</term>
            <term>
            Has the same meaning as ICMODE_COMPRESS except the compressor is used for a real-time operation and emphasizes speed over quality.
            </term>
            </item>
            <item>
            <term>ICMODE_FASTDECOMPRESS</term>
            <term>
            Has the same meaning as ICMODE_DECOMPRESS except the decompressor is used for a real-time operation and emphasizes speed over quality.
            </term>
            </item>
            </list>
            </param>
            <returns>Returns a handle to a compressor or decompressor if successful or zero otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICLocate(System.UInt32,System.UInt32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,Vanara.PInvoke.Msvfw32.ICMODE)">
            <summary>
            The <c>ICLocate</c> function finds a compressor or decompressor that can handle images with the specified formats, or finds a
            driver that can decompress an image with a specified format directly to hardware.
            </summary>
            <param name="fccType">
            Four-character code indicating the type of compressor or decompressor to open. For video streams, the value of this parameter is 'VIDC'.
            </param>
            <param name="fccHandler">
            Preferred handler of the specified type. Typically, the handler type is stored in the stream header in an AVI file. Specify
            <c>NULL</c> if your application can use any handler type or it does not know the handler type to use.
            </param>
            <param name="lpbiIn">
            Pointer to a BITMAPINFOHEADER structure defining the input format. A compressor handle is not returned unless it supports this format.
            </param>
            <param name="lpbiOut">
            <para>
            Pointer to a BITMAPINFOHEADER structure defining an optional decompressed format. You can also specify zero to use the default
            output format associated with the input format.
            </para>
            <para>If this parameter is nonzero, a compressor handle is not returned unless it can create this output format.</para>
            </param>
            <param name="wFlags">
            <para>Flags that describe the search criteria for a compressor or decompressor. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICMODE_COMPRESS</term>
            <term>Finds a compressor that can compress an image with a format defined by lpbiIn to the format defined by lpbiOut.</term>
            </item>
            <item>
            <term>ICMODE_DECOMPRESS</term>
            <term>Finds a decompressor that can decompress an image with a format defined by lpbiIn to the format defined by lpbiOut.</term>
            </item>
            <item>
            <term>ICMODE_DRAW</term>
            <term>Finds a decompressor that can decompress an image with a format defined by lpbiIn and draw it directly to hardware.</term>
            </item>
            <item>
            <term>ICMODE_FASTCOMPRESS</term>
            <term>
            Has the same meaning as ICMODE_COMPRESS except the compressor is used for a real-time operation and emphasizes speed over quality.
            </term>
            </item>
            <item>
            <term>ICMODE_FASTDECOMPRESS</term>
            <term>
            Has the same meaning as ICMODE_DECOMPRESS except the decompressor is used for a real-time operation and emphasizes speed over quality.
            </term>
            </item>
            </list>
            </param>
            <returns>Returns a handle to a compressor or decompressor if successful or zero otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICOpen(System.UInt32,System.UInt32,Vanara.PInvoke.Msvfw32.ICMODE)">
            <summary>The <c>ICOpen</c> function opens a compressor or decompressor.</summary>
            <param name="fccType">
            Four-character code indicating the type of compressor or decompressor to open. For video streams, the value of this parameter is "VIDC".
            </param>
            <param name="fccHandler">
            Preferred handler of the specified type. Typically, the handler type is stored in the stream header in an AVI file.
            </param>
            <param name="wMode">
            <para>Flag defining the use of the compressor or decompressor. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICMODE_COMPRESS</term>
            <term>Compressor will perform normal compression.</term>
            </item>
            <item>
            <term>ICMODE_DECOMPRESS</term>
            <term>Decompressor will perform normal decompression.</term>
            </item>
            <item>
            <term>ICMODE_DRAW</term>
            <term>Decompressor will decompress and draw the data directly to hardware.</term>
            </item>
            <item>
            <term>ICMODE_FASTCOMPRESS</term>
            <term>Compressor will perform fast (real-time) compression.</term>
            </item>
            <item>
            <term>ICMODE_FASTDECOMPRESS</term>
            <term>Decompressor will perform fast (real-time) decompression.</term>
            </item>
            <item>
            <term>ICMODE_QUERY</term>
            <term>Queries the compressor or decompressor for information.</term>
            </item>
            </list>
            </param>
            <returns>Returns a handle to a compressor or decompressor if successful or zero otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICOpenFunction(System.UInt32,System.UInt32,Vanara.PInvoke.Msvfw32.ICMODE,System.IntPtr)">
            <summary>The <c>ICOpenFunction</c> function opens a compressor or decompressor defined as a function.</summary>
            <param name="fccType">Type of compressor to open. For video, the value of this parameter is ICTYPE_VIDEO.</param>
            <param name="fccHandler">Preferred handler of the specified type. Typically, this comes from the stream header in an AVI file.</param>
            <param name="wMode">
            <para>Flag to define the use of the compressor or decompressor. The following values are defined.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ICMODE_COMPRESS</term>
            <term>Compressor will perform normal compression.</term>
            </item>
            <item>
            <term>ICMODE_DECOMPRESS</term>
            <term>Decompressor will perform normal decompression.</term>
            </item>
            <item>
            <term>ICMODE_DRAW</term>
            <term>Decompressor will decompress and draw the data directly to hardware.</term>
            </item>
            <item>
            <term>ICMODE_FASTCOMPRESS</term>
            <term>Compressor will perform fast (real-time) compression.</term>
            </item>
            <item>
            <term>ICMODE_FASTDECOMPRESS</term>
            <term>Decompressor will perform fast (real-time) decompression.</term>
            </item>
            <item>
            <term>ICMODE_QUERY</term>
            <term>Queries the compressor or decompressor for information.</term>
            </item>
            </list>
            </param>
            <param name="lpfnHandler">Pointer to the function used as the compressor or decompressor.</param>
            <returns>Returns a handle to a compressor or decompressor if successful or zero otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICQueryAbout(Vanara.PInvoke.Msvfw32.HIC)">
            <summary>
            The <c>ICQueryAbout</c> macro queries a video compression driver to determine if it has an About dialog box. You can use this
            macro or explicitly call the ICM_ABOUT message.
            </summary>
            <param name="hic">Handle of the compressor.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICQueryAbout(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.HWND)">
            <summary>
            The <c>ICQueryAbout</c> macro queries a video compression driver to determine if it has an About dialog box. You can use this
            macro or explicitly call the ICM_ABOUT message.
            </summary>
            <param name="hic">Handle of the compressor.</param>
            <param name="hwnd">Handle to the parent window of the displayed dialog box.</param>
            <returns>None</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICQueryConfigure(Vanara.PInvoke.Msvfw32.HIC)">
            <summary>
            The <c>ICQueryConfigure</c> macro queries a video compression driver to determine if it has a configuration dialog box. You can
            use this macro or explicitly send the ICM_CONFIGURE message.
            </summary>
            <param name="hic">Handle of the compressor.</param>
            <returns>None</returns>
            <remarks>
            This message is different from the DRV_CONFIGURE message used for hardware configuration. The dialog box for this message should
            let the user set and edit the internal state referenced by the ICM_GETSTATE and ICM_SETSTATE messages. For example, this dialog
            box can let the user change parameters affecting the quality level and other similar compression options.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICQueryConfigure(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.HWND)">
            <summary>
            The <c>ICQueryConfigure</c> macro queries a video compression driver to determine if it has a configuration dialog box. You can
            use this macro or explicitly send the ICM_CONFIGURE message.
            </summary>
            <param name="hic">Handle of the compressor.</param>
            <param name="hwnd">Handle to the parent window of the displayed dialog box.</param>
            <returns>None</returns>
            <remarks>
            This message is different from the DRV_CONFIGURE message used for hardware configuration. The dialog box for this message should
            let the user set and edit the internal state referenced by the ICM_GETSTATE and ICM_SETSTATE messages. For example, this dialog
            box can let the user change parameters affecting the quality level and other similar compression options.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICRemove(System.UInt32,System.UInt32,System.UInt32)">
            <summary>The <c>ICRemove</c> function removes an installed compressor.</summary>
            <param name="fccType">
            Four-character code indicating the type of data used by the compressor or decompressor. Specify "VIDC" for a video compressor or decompressor.
            </param>
            <param name="fccHandler">
            Four-character code identifying a specific compressor or a number between zero and the number of installed compressors of the
            type specified by fccType.
            </param>
            <param name="wFlags">Reserved; do not use.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICSendMessage(Vanara.PInvoke.Msvfw32.HIC,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>The <c>ICSendMessage</c> function sends a message to a compressor.</summary>
            <param name="hic">Handle to the compressor to receive the message.</param>
            <param name="msg">Message to send.</param>
            <param name="dw1">Additional message-specific information.</param>
            <param name="dw2">Additional message-specific information.</param>
            <returns>Returns a message-specific result.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICSendMessage(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.ICM_Message,System.IntPtr,System.IntPtr)">
            <summary>The <c>ICSendMessage</c> function sends a message to a compressor.</summary>
            <param name="hic">Handle to the compressor to receive the message.</param>
            <param name="msg">Message to send.</param>
            <param name="dw1">Additional message-specific information.</param>
            <param name="dw2">Additional message-specific information.</param>
            <returns>Returns a message-specific result.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICSendMessage(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.ICM_Message,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@)">
            <summary>The <c>ICSendMessage</c> function sends a message to a compressor.</summary>
            <param name="hic">Handle to the compressor to receive the message.</param>
            <param name="msg">Message to send.</param>
            <param name="lpbiInput">Additional message-specific information.</param>
            <param name="lpbiOutput">Additional message-specific information.</param>
            <returns>Returns a message-specific result.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICSendMessage``1(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.ICM_Message,``0@)">
            <summary>The <c>ICSendMessage</c> function sends a message to a compressor.</summary>
            <typeparam name="T">The type of the structure to pass into <paramref name="lpbiInput"/>.</typeparam>
            <param name="hic">Handle to the compressor to receive the message.</param>
            <param name="msg">Message to send.</param>
            <param name="lpbiInput">Additional message-specific information.</param>
            <returns>Returns a message-specific result.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICSeqCompressFrame(Vanara.PInvoke.Msvfw32.COMPVARS@,System.UInt32,System.IntPtr,System.Boolean@,System.Int32@)">
            <summary>The <c>ICSeqCompressFrame</c> function compresses one frame in a sequence of frames.</summary>
            <param name="pc">Pointer to a COMPVARS structure initialized with information about the compression.</param>
            <param name="uiFlags">Reserved; must be zero.</param>
            <param name="lpBits">Pointer to the data bits to compress. (The data bits exclude header or format information.)</param>
            <param name="pfKey">Returns whether or not the frame was compressed into a key frame.</param>
            <param name="plSize">
            Maximum size desired for the compressed image. The compressor might not be able to compress the data to fit within this size.
            When the function returns, the parameter points to the size of the compressed image. Images sizes are specified in bytes.
            </param>
            <returns>Returns the address of the compressed bits if successful or <c>NULL</c> otherwise.</returns>
            <remarks>
            <para>
            This function uses a COMPVARS structure to provide settings for the specified compressor and intersperses key frames at the rate
            specified by the ICSeqCompressorFrameStart function. You can specify values for the data rate for the sequence and the key-frame
            frequency by using the appropriate members of <c>COMPVARS</c>.
            </para>
            <para>Use this function instead of the ICCompress function to compress a video sequence.</para>
            <para>
            You can allow the user to specify a compressor and initialize a COMPVARS structure by using the ICCompressorChoose function. Or,
            you can initialize a <c>COMPVARS</c> structure manually.
            </para>
            <para>
            Use the ICSeqCompressFrameStart, <c>ICSeqCompressFrame</c>, and ICSeqCompressFrameEnd functions to compress a sequence of frames
            to a specified data rate and number of key frames. Use <c>ICSeqCompressFrame</c> once for each frame to be compressed.
            </para>
            <para>When finished with compression, use the ICCompressorFree function to release the resources specified by COMPVARS.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICSeqCompressFrameEnd(Vanara.PInvoke.Msvfw32.COMPVARS@)">
            <summary>
            The <c>ICSeqCompressFrameEnd</c> function ends sequence compression that was initiated by using the ICSeqCompressFrameStart and
            ICSeqCompressFrame functions.
            </summary>
            <param name="pc">Pointer to a COMPVARS structure used during sequence compression.</param>
            <returns>This function does not return a value.</returns>
            <remarks>When finished with compression, use the ICCompressorFree function to release the resources specified by COMPVARS.</remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICSeqCompressFrameStart(Vanara.PInvoke.Msvfw32.COMPVARS@,System.IntPtr)">
            <summary>
            The <c>ICSeqCompressFrameStart</c> function initializes resources for compressing a sequence of frames using the
            ICSeqCompressFrame function.
            </summary>
            <param name="pc">Pointer to a COMPVARS structure initialized with information for compression.</param>
            <param name="lpbiIn">Format of the data to be compressed.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
            <remarks>
            <para>
            This function uses a COMPVARS structure to provide settings for the specified compressor and intersperses key frames at the rate
            specified by the <c>lKey</c> member of <c>COMPVARS</c>. You can specify values for the data rate for the sequence and the
            key-frame frequency by using the appropriate members of <c>COMPVARS</c>.
            </para>
            <para>
            Use the <c>ICSeqCompressFrameStart</c>, ICSeqCompressFrame, and ICSeqCompressFrameEnd functions to compress a sequence of frames
            to a specified data rate and number of key frames.
            </para>
            <para>When finished with compression, use the ICCompressorFree function to release the resources specified in COMPVARS.</para>
            <para>
            COMPVARS needs to be initialized before you use this function. You can initialize the structure manually or you can allow the
            user to specify a compressor and initialize a <c>COMPVARS</c> structure by using the ICCompressorChoose function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICSeqCompressFrameStart(Vanara.PInvoke.Msvfw32.COMPVARS@,Vanara.PInvoke.Gdi32.BITMAPINFO@)">
            <summary>
            The <c>ICSeqCompressFrameStart</c> function initializes resources for compressing a sequence of frames using the
            ICSeqCompressFrame function.
            </summary>
            <param name="pc">Pointer to a COMPVARS structure initialized with information for compression.</param>
            <param name="lpbiIn">Format of the data to be compressed.</param>
            <returns>Returns <c>TRUE</c> if successful or <c>FALSE</c> otherwise.</returns>
            <remarks>
            <para>
            This function uses a COMPVARS structure to provide settings for the specified compressor and intersperses key frames at the rate
            specified by the <c>lKey</c> member of <c>COMPVARS</c>. You can specify values for the data rate for the sequence and the
            key-frame frequency by using the appropriate members of <c>COMPVARS</c>.
            </para>
            <para>
            Use the <c>ICSeqCompressFrameStart</c>, ICSeqCompressFrame, and ICSeqCompressFrameEnd functions to compress a sequence of frames
            to a specified data rate and number of key frames.
            </para>
            <para>When finished with compression, use the ICCompressorFree function to release the resources specified in COMPVARS.</para>
            <para>
            COMPVARS needs to be initialized before you use this function. You can initialize the structure manually or you can allow the
            user to specify a compressor and initialize a <c>COMPVARS</c> structure by using the ICCompressorChoose function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICSetState(Vanara.PInvoke.Msvfw32.HIC,System.IntPtr,System.UInt32)">
            <summary>
            The <c>ICSetState</c> macro notifies a video compression driver to set the state of the compressor. You can use this macro or
            explicitly call the ICM_SETSTATE message.
            </summary>
            <param name="hic">Handle of the compressor.</param>
            <param name="pv">
            Pointer to a block of memory containing configuration data. You can specify <c>NULL</c> for this parameter to reset the
            compressor to its default state.
            </param>
            <param name="cb">Size, in bytes, of the block of memory.</param>
            <returns>None</returns>
            <remarks>
            The information used by this message is private and specific to a given compressor. Client applications should use this message
            only to restore information previously obtained with the ICGetState and ICConfigure macros and should use the <c>ICConfigure</c>
            macro to adjust the configuration of a video compression driver.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICSetStatusProc(Vanara.PInvoke.Msvfw32.HIC,System.UInt32,System.IntPtr,System.Func{System.IntPtr,System.UInt32,System.Int32,System.Int32})">
            <summary>
            The <c>ICSetStatusProc</c> function sends the address of a status callback function to a compressor. The compressor calls this
            function during lengthy operations.
            </summary>
            <param name="hic">Handle to the compressor.</param>
            <param name="dwFlags">Applicable flags. Set to zero.</param>
            <param name="lParam">Constant specified with the status callback address.</param>
            <param name="fpfnStatus">
            Pointer to the status callback function. Specify <c>NULL</c> to indicate no status callbacks should be sent.
            </param>
            <returns>Returns ICERR_OK if successful or <c>FALSE</c> otherwise.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.StretchDIB(Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Vanara.PInvoke.Gdi32.BITMAPINFOHEADER@,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            The <c>StretchDIB</c> function copies a device independent bitmap from one memory location to another and resizes the image to
            fit the destination rectangle.
            </summary>
            <param name="biDst">Pointer to a BITMAPINFOHEADER structure that describes the destination bitmap.</param>
            <param name="lpDst">Pointer to the memory buffer that will receive the copied pixel bits.</param>
            <param name="DstX">X coordinate of the destination rectangle's origin.</param>
            <param name="DstY">Y coordinate of the destination rectangle's origin.</param>
            <param name="DstXE">Width, in pixels, of the destination rectangle.</param>
            <param name="DstYE">Height, in pixels, of the destination rectangle.</param>
            <param name="biSrc">Pointer to a BITMAPINFOHEADER structure that describes the source bitmap.</param>
            <param name="lpSrc">Pointer to the source bitmap data.</param>
            <param name="SrcX">X coordinate of the source rectangle's origin.</param>
            <param name="SrcY">Y coordinate of the source rectangle's origin.</param>
            <param name="SrcXE">Width, in pixels, of the source rectangle.</param>
            <param name="SrcYE">Height, in pixels, of the source rectangle.</param>
            <returns>None</returns>
            <remarks>
            <para>The size of the destination buffer must be large enough to accommodate any alignment bytes at the end of each pixel row.</para>
            <para>
            This function does nothing if biSrc and biDst have different values for biBitCount or if the value for biSrc. biBitCount does
            not equal 8, 16, or 24.
            </para>
            <para>
            This function performs no dithering or other smoothing. Pixel values are merely dropped or duplicated on a line-by-line,
            column-by-column basis.
            </para>
            <para>
            This function does not do any special processing based on pixel encoding except for calculating the number of bits per pixel. In
            particular this function will not generate correct results when pixels are encoded in groups of more than 1 pixel, as in the
            case of a YUV format where U and V are decimated and so are not represented equally in each pixel.
            </para>
            <para>Before including Vfw.h, you must add the following line to your code:</para>
            <para>
            <code> #define DRAWDIB_INCLUDE_STRETCHDIB</code>
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.ICSendMessage(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.ICM_Message,Vanara.PInvoke.Gdi32.SafeBITMAPINFO,Vanara.PInvoke.Gdi32.SafeBITMAPINFO)">
            <summary>The <c>ICSendMessage</c> function sends a message to a compressor.</summary>
            <param name="hic">Handle to the compressor to receive the message.</param>
            <param name="msg">Message to send.</param>
            <param name="lpbiInput">Additional message-specific information.</param>
            <param name="lpbiOutput">Additional message-specific information.</param>
            <returns>Returns a message-specific result.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.COMPVARS">
            <summary>
            The <c>COMPVARS</c> structure describes compressor settings for functions such as ICCompressorChoose, ICSeqCompressFrame, and ICCompressorFree.
            </summary>
            <remarks>
            You can let ICCompressorChoose fill the contents of this structure or you can do it manually. If you manually fill the
            structure, you must provide information for the following members: <c>cbSize</c>, <c>hic</c>, <c>lpbiOut</c>, <c>lKey</c>, and
            <c>lQ</c>. Also, you must set the <c>ICMF_COMPVARS_VALID</c> flag in the <c>dwFlags</c> member.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.cbSize">
            <summary>
            Size, in bytes, of this structure. This member must be set to validate the structure before calling any function using this structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.dwFlags">
            <summary>
            <para>Applicable flags. The following value is defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ICMF_COMPVARS_VALID</term>
            <term>
            Data in this structure is valid and has been manually entered. Set this flag before you call any function if you fill this
            structure manually. Do not set this flag if you let ICCompressorChoose initialize this structure.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.hic">
            <summary>
            Handle to the compressor to use. You can open a compressor and obtain a handle of it by using the ICOpen function. You can
            also choose a compressor by using ICCompressorChoose. <c>ICCompressorChoose</c> opens the chosen compressor and returns the
            handle of the compressor in this member. You can close the compressor by using ICCompressorFree.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.fccType">
            <summary>Type of compressor used. Currently only <c>ICTYPE_VIDEO</c> (VIDC) is supported. This member can be set to zero.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.fccHandler">
            <summary>
            Four-character code of the compressor. Specify <c>NULL</c> to indicate the data is not to be recompressed. Specify "DIB" to
            indicate the data is an uncompressed, full frame. You can use this member to specify which compressor is selected by default
            when the dialog box is displayed.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.lpbiIn">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.lpbiOut">
            <summary>
            Pointer to a BITMAPINFO structure containing the image output format. You can specify a specific format to use or you can
            specify <c>NULL</c> to use the default compressor associated with the input format. You can also set the image output format
            by using ICCompressorChoose.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.lpBitsOut">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.lpBitsPrev">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.lFrame">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.lKey">
            <summary>
            Key-frame rate. Specify an integer to indicate the frequency that key frames are to occur in the compressed sequence or zero
            to not use key frames. You can also let ICCompressorChoose set the key-frame rate selected in the dialog box. The
            ICSeqCompressFrameStart function uses the value of this member for making key frames.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.lDataRate">
            <summary>
            Data rate, in kilobytes per second. ICCompressorChoose copies the selected data rate from the dialog box to this member.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.lQ">
            <summary>
            Quality setting. Specify a quality setting of 1 to 10,000 or specify <c>ICQUALITY_DEFAULT</c> to use the default quality
            setting. You can also let ICCompressorChoose set the quality value selected in the dialog box. ICSeqCompressFrameStart uses
            the value of this member as its quality setting.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.lKeyCount">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.lpState">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.COMPVARS.cbState">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.DRAWDIBTIME">
            <summary>
            The <c>DRAWDIBTIME</c> structure contains elapsed timing information for performing a set of DrawDib operations. The DrawDibTime
            function resets the count and the elapsed time value for each operation each time it is called.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DRAWDIBTIME.timeCount">
            <summary>
            <para>Number of times the following operations have been performed since DrawDibTime was last called:</para>
            <list type="bullet">
            <item>
            <term>Draw a bitmap on the screen.</term>
            </item>
            <item>
            <term>Decompress a bitmap.</term>
            </item>
            <item>
            <term>Dither a bitmap.</term>
            </item>
            <item>
            <term>Stretch a bitmap.</term>
            </item>
            <item>
            <term>Transfer bitmap data by using the BitBlt function.</term>
            </item>
            <item>
            <term>Transfer bitmap data by using the SetDIBits function.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DRAWDIBTIME.timeDraw">
            <summary>Time to draw bitmaps.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DRAWDIBTIME.timeDecompress">
            <summary>Time to decompress bitmaps.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DRAWDIBTIME.timeDither">
            <summary>Time to dither bitmaps.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DRAWDIBTIME.timeStretch">
            <summary>Time to stretch bitmaps.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DRAWDIBTIME.timeBlt">
            <summary>Time to transfer bitmaps by using the BitBlt function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.DRAWDIBTIME.timeSetDIBits">
            <summary>Time to transfer bitmaps by using the SetDIBits function.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.HDRAWDIB">
            <summary>Provides a handle to a DrawDib DC.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HDRAWDIB.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Msvfw32.HDRAWDIB"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.Msvfw32.HDRAWDIB.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.Msvfw32.HDRAWDIB"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Msvfw32.HDRAWDIB.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HDRAWDIB.op_Explicit(Vanara.PInvoke.Msvfw32.HDRAWDIB)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Msvfw32.HDRAWDIB"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HDRAWDIB.op_Implicit(System.IntPtr)~Vanara.PInvoke.Msvfw32.HDRAWDIB">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.Msvfw32.HDRAWDIB"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HDRAWDIB.op_Inequality(Vanara.PInvoke.Msvfw32.HDRAWDIB,Vanara.PInvoke.Msvfw32.HDRAWDIB)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HDRAWDIB.op_Equality(Vanara.PInvoke.Msvfw32.HDRAWDIB,Vanara.PInvoke.Msvfw32.HDRAWDIB)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HDRAWDIB.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HDRAWDIB.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HDRAWDIB.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.HIC">
            <summary>Provides a handle to an image decompressor.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HIC.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Msvfw32.HIC"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.Msvfw32.HIC.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.Msvfw32.HIC"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Msvfw32.HIC.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HIC.op_Explicit(Vanara.PInvoke.Msvfw32.HIC)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Msvfw32.HIC"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HIC.op_Implicit(System.IntPtr)~Vanara.PInvoke.Msvfw32.HIC">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.Msvfw32.HIC"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HIC.op_Inequality(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.HIC)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HIC.op_Equality(Vanara.PInvoke.Msvfw32.HIC,Vanara.PInvoke.Msvfw32.HIC)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HIC.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HIC.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.HIC.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICCOMPRESS">
            <summary>The <c>ICCOMPRESS</c> structure contains compression parameters used with the ICM_COMPRESS message.</summary>
            <remarks>
            Drivers that perform temporal compression use data from the previous frame (found in the <c>lpbiPrev</c> and <c>lpPrev</c>
            members) to prune redundant data from the current frame.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESS.dwFlags">
            <summary>
            <para>Flags used for compression. The following value is defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ICCOMPRESS_KEYFRAME</term>
            <term>Input data should be treated as a key frame.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESS.lpbiOutput">
            <summary>
            Pointer to a BITMAPINFOHEADER structure containing the output (compressed) format. The <c>biSizeImage</c> member must
            contain the size of the compressed data.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESS.lpOutput">
            <summary>Pointer to the buffer where the driver should write the compressed data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESS.lpbiInput">
            <summary>Pointer to a BITMAPINFOHEADER structure containing the input (uncompressed) format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESS.lpInput">
            <summary>Pointer to the buffer containing input data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESS.lpckid">
            <summary>
            Address to contain the chunk identifier for data in the AVI file. If the value of this member is not <c>NULL</c>, the driver
            should specify a two-character code for the chunk identifier corresponding to the chunk identifier used in the AVI file.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESS.lpdwFlags">
            <summary>
            Address to contain flags for the AVI index. If the returned frame is a key frame, the driver should set the
            <c>AVIIF_KEYFRAME</c> flag.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESS.lFrameNum">
            <summary>Number of the frame to compress.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESS.dwFrameSize">
            <summary>
            Desired maximum size, in bytes, for compressing this frame. The size value is used for compression methods that can make
            tradeoffs between compressed image size and image quality. Specify zero for this member to use the default setting.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESS.dwQuality">
            <summary>Quality setting.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESS.lpbiPrev">
            <summary>
            Pointer to a BITMAPINFOHEADER structure containing the format of the previous frame, which is typically the same as the
            input format.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESS.lpPrev">
            <summary>Pointer to the buffer containing input data of the previous frame.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES">
            <summary>The <c>ICCOMPRESSFRAMES</c> structure contains compression parameters used with the ICM_COMPRESS_FRAMES_INFO message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.dwFlags">
            <summary>
            Applicable flags. The following value is defined: <c>ICCOMPRESSFRAMES_PADDING</c>. If this value is used, padding is used
            with the frame.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.lpbiOutput">
            <summary>Pointer to a BITMAPINFOHEADER structure containing the output format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.lOutput">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.lpbiInput">
            <summary>Pointer to a BITMAPINFOHEADER structure containing the input format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.lInput">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.lStartFrame">
            <summary>Number of the first frame to compress.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.lFrameCount">
            <summary>Number of frames to compress.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.lQuality">
            <summary>Quality setting.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.lDataRate">
            <summary>Maximum data rate, in bytes per second.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.lKeyRate">
            <summary>Maximum number of frames between consecutive key frames.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.dwRate">
            <summary>
            Compression rate in an integer format. To obtain the rate in frames per second, divide this value by the value in <c>dwScale</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.dwScale">
            <summary>Value used to scale <c>dwRate</c> to frames per second.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.dwOverheadPerFrame">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICCOMPRESSFRAMES.dwReserved2">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICDECOMPRESS">
            <summary>The <c>ICDECOMPRESS</c> structure contains decompression parameters used with the ICM_DECOMPRESS message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESS.dwFlags">
            <summary>
            <para>Applicable flags. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ICDECOMPRESS_HURRYUP</term>
            <term>
            Tries to decompress at a faster rate. When an application uses this flag, the driver should buffer the decompressed data but
            not draw the image.
            </term>
            </item>
            <item>
            <term>ICDECOMPRESS_NOTKEYFRAME</term>
            <term>Current frame is not a key frame.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_NULLFRAME</term>
            <term>Current frame does not contain data and the decompressed image should be left the same.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_PREROLL</term>
            <term>Current frame precedes the point in the movie where playback starts and, therefore, will not be drawn.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_UPDATE</term>
            <term>Screen is being updated or refreshed.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESS.lpbiInput">
            <summary>Pointer to a BITMAPINFOHEADER structure containing the input format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESS.lpInput">
            <summary>Pointer to a buffer containing the input data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESS.lpbiOutput">
            <summary>Pointer to a BITMAPINFOHEADER structure containing the output format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESS.lpOutput">
            <summary>Pointer to a buffer where the driver should write the decompressed image.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESS.ckid">
            <summary>Chunk identifier from the AVI file.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX">
            <summary>The <c>ICDECOMPRESSEX</c> structure contains decompression parameters used with the ICM_DECOMPRESSEX message</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.dwFlags">
            <summary>
            <para>Applicable flags. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ICDECOMPRESS_HURRYUP</term>
            <term>
            Tries to decompress at a faster rate. When an application uses this flag, the driver should buffer the decompressed data but
            not draw the image.
            </term>
            </item>
            <item>
            <term>ICDECOMPRESS_NOTKEYFRAME</term>
            <term>Current frame is not a key frame.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_NULLFRAME</term>
            <term>Current frame does not contain data and the decompressed image should be left the same.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_PREROLL</term>
            <term>Current frame precedes the point in the movie where playback starts and, therefore, will not be drawn.</term>
            </item>
            <item>
            <term>ICDECOMPRESS_UPDATE</term>
            <term>Screen is being updated or refreshed.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.lpbiSrc">
            <summary>Pointer to a BITMAPINFOHEADER structure containing the input format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.lpSrc">
            <summary>Pointer to a buffer containing the input data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.lpbiDst">
            <summary>Pointer to a BITMAPINFOHEADER structure containing the output format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.lpDst">
            <summary>Pointer to a buffer where the driver should write the decompressed image.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.xDst">
            <summary>The x-coordinate of the destination rectangle within the DIB specified by <c>lpbiDst</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.yDst">
            <summary>The y-coordinate of the destination rectangle within the DIB specified by <c>lpbiDst</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.dxDst">
            <summary>Width of the destination rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.dyDst">
            <summary>Height of the destination rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.xSrc">
            <summary>The x-coordinate of the source rectangle within the DIB specified by <c>lpbiSrc</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.ySrc">
            <summary>The y-coordinate of the source rectangle within the DIB specified by <c>lpbiSrc</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.dxSrc">
            <summary>Width of the source rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDECOMPRESSEX.dySrc">
            <summary>Height of the source rectangle.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICDRAW">
            <summary>
            The <c>ICDRAW</c> structure contains parameters for drawing video data to the screen. This structure is used with the ICM_DRAW message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAW.dwFlags">
            <summary>
            <para>Flags from the AVI file index. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ICDRAW_HURRYUP</term>
            <term>Data is buffered and not drawn to the screen. Use this flag for fastest decompression.</term>
            </item>
            <item>
            <term>ICDRAW_NOTKEYFRAME</term>
            <term>Current frame is not a key frame.</term>
            </item>
            <item>
            <term>ICDRAW_NULLFRAME</term>
            <term>Current frame does not contain any data, and the previous frame should be redrawn.</term>
            </item>
            <item>
            <term>ICDRAW_PREROLL</term>
            <term>
            Current frame of video occurs before playback should start. For example, if playback will begin on frame 10, and frame 0 is
            the nearest previous key frame, frames 0 through 9 are sent to the driver with this flag set. The driver needs this data to
            display frame 10 properly.
            </term>
            </item>
            <item>
            <term>ICDRAW_UPDATE</term>
            <term>Updates the screen based on data previously received. In this case, lpData should be ignored.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAW.lpFormat">
            <summary>Pointer to a structure containing the data format. For video streams, this is a BITMAPINFOHEADER structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAW.lpData">
            <summary>Pointer to the data to render.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAW.cbData">
            <summary>Number of data bytes to render.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAW.lTime">
            <summary>Time, in samples, when this data should be drawn. For video data this is normally a frame number.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN">
            <summary>The <c>ICDRAWBEGIN</c> structure contains decompression parameters used with the ICM_DRAW_BEGIN message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.dwFlags">
            <summary>
            <para>Applicable flags. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ICDRAW_ANIMATE</term>
            <term>Application can animate the palette.</term>
            </item>
            <item>
            <term>ICDRAW_BUFFER</term>
            <term>Buffers this data off-screen; it will need to be updated.</term>
            </item>
            <item>
            <term>ICDRAW_CONTINUE</term>
            <term>Drawing is a continuation of the previous frame.</term>
            </item>
            <item>
            <term>ICDRAW_FULLSCREEN</term>
            <term>Draws the decompressed data on the full screen.</term>
            </item>
            <item>
            <term>ICDRAW_HDC</term>
            <term>Draws the decompressed data to a window or a DC.</term>
            </item>
            <item>
            <term>ICDRAW_MEMORYDC</term>
            <term>DC is off-screen.</term>
            </item>
            <item>
            <term>ICDRAW_QUERY</term>
            <term>Determines if the decompressor can handle the decompression. The driver does not actually decompress the data.</term>
            </item>
            <item>
            <term>ICDRAW_RENDER</term>
            <term>Renders but does not draw the data.</term>
            </item>
            <item>
            <term>ICDRAW_UPDATING</term>
            <term>Current frame is being updated rather than played.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.hpal">
            <summary>Handle to the palette used for drawing.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.hwnd">
            <summary>Handle to the window used for drawing.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.hdc">
            <summary>Handle to the DC used for drawing. Specify <c>NULL</c> to use a DC associated with the specified window.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.xDst">
            <summary>The x-coordinate of the destination rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.yDst">
            <summary>The y-coordinate of the destination rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.dxDst">
            <summary>Width of the destination rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.dyDst">
            <summary>Height of the destination rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.lpbi">
            <summary>Pointer to a BITMAPINFOHEADER structure containing the input format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.xSrc">
            <summary>The x-coordinate of the source rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.ySrc">
            <summary>The y-coordinate of the source rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.dxSrc">
            <summary>Width of the source rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.dySrc">
            <summary>Height of the source rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.dwRate">
            <summary>
            Decompression rate in an integer format. To obtain the rate in frames per second, divide this value by the value in <c>dwScale</c>.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWBEGIN.dwScale">
            <summary>Value used to scale <c>dwRate</c> to frames per second.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICDRAWSUGGEST">
            <summary>
            The <c>ICDRAWSUGGEST</c> structure contains compression parameters used with the ICM_DRAW_SUGGESTFORMAT message to suggest an
            appropriate input format.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWSUGGEST.lpbiIn">
            <summary>Pointer to the structure containing the compressed input format.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWSUGGEST.lpbiSuggest">
            <summary>Pointer to a buffer to return a compatible input format for the renderer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWSUGGEST.dxSrc">
            <summary>Width of the source rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWSUGGEST.dySrc">
            <summary>Height of the source rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWSUGGEST.dxDst">
            <summary>Width of the destination rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWSUGGEST.dyDst">
            <summary>Height of the destination rectangle.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICDRAWSUGGEST.hicDecompressor">
            <summary>Handle to a decompressor that supports the format of data described in <c>lpbiIn</c>.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICINFO">
            <summary>
            The <c>ICINFO</c> structure contains compression parameters supplied by a video compression driver. The driver fills or updates
            the structure when it receives the ICM_GETINFO message.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINFO.dwSize">
            <summary>Size, in bytes, of the <c>ICINFO</c> structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINFO.fccType">
            <summary>
            Four-character code indicating the type of stream being compressed or decompressed. Specify "VIDC" for video streams.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINFO.fccHandler">
            <summary>A four-character code identifying a specific compressor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINFO.dwFlags">
            <summary>
            <para>Applicable flags. Zero or more of the following flags can be set:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>VIDCF_COMPRESSFRAMES</term>
            <term>
            Driver is requesting to compress all frames. For information about compressing all frames, see the ICM_COMPRESS_FRAMES_INFO message.
            </term>
            </item>
            <item>
            <term>VIDCF_CRUNCH</term>
            <term>Driver supports compressing to a frame size.</term>
            </item>
            <item>
            <term>VIDCF_DRAW</term>
            <term>Driver supports drawing.</term>
            </item>
            <item>
            <term>VIDCF_FASTTEMPORALC</term>
            <term>
            Driver can perform temporal compression and maintains its own copy of the current frame. When compressing a stream of frame
            data, the driver doesn't need image data from the previous frame.
            </term>
            </item>
            <item>
            <term>VIDCF_FASTTEMPORALD</term>
            <term>
            Driver can perform temporal decompression and maintains its own copy of the current frame. When decompressing a stream of
            frame data, the driver doesn't need image data from the previous frame.
            </term>
            </item>
            <item>
            <term>VIDCF_QUALITY</term>
            <term>Driver supports quality values.</term>
            </item>
            <item>
            <term>VIDCF_TEMPORAL</term>
            <term>Driver supports inter-frame compression.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINFO.dwVersion">
            <summary>Version number of the driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINFO.dwVersionICM">
            <summary>Version of VCM supported by the driver. This member should be set to ICVERSION.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINFO.szName">
            <summary>
            Short version of the compressor name. The name in the null-terminated string should be suitable for use in list boxes.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINFO.szDescription">
            <summary>Long version of the compressor name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICINFO.szDriver">
            <summary>Name of the module containing VCM compression driver. Normally, a driver does not need to fill this out.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICOPEN">
            <summary>
            The <c>ICOPEN</c> structure contains information about the data stream being compressed or decompressed, the version number of
            the driver, and how the driver is used.
            </summary>
            <remarks>
            This structure is passed to video capture drivers when they are opened. This allows a single installable driver to function as
            either an installable compressor or a video capture device. By examining the <c>fccType</c> member of the <c>ICOPEN</c>
            structure, the driver can determine its function. For example, a <c>fccType</c> value of "VIDC" indicates that it is opened as
            an installable video compressor.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICOPEN.dwSize">
            <summary>Size, in bytes, of the structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICOPEN.fccType">
            <summary>
            Four-character code indicating the type of stream being compressed or decompressed. Specify "VIDC" for video streams.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICOPEN.fccHandler">
            <summary>Four-character code identifying a specific compressor.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICOPEN.dwVersion">
            <summary>Version of the installable driver interface used to open the driver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICOPEN.dwFlags">
            <summary>
            <para>Applicable flags indicating why the driver is opened. The following values are defined:</para>
            <list type="table">
            <listheader>
            <term>Name</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>ICMODE_COMPRESS</term>
            <term>Driver is opened to compress data.</term>
            </item>
            <item>
            <term>ICMODE_DECOMPRESS</term>
            <term>Driver is opened to decompress data.</term>
            </item>
            <item>
            <term>ICMODE_DRAW</term>
            <term>Device driver is opened to decompress data directly to hardware.</term>
            </item>
            <item>
            <term>ICMODE_QUERY</term>
            <term>Driver is opened for informational purposes, rather than for compression.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICOPEN.dwError">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICOPEN.pV1Reserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICOPEN.pV2Reserved">
            <summary>Reserved; do not use.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICOPEN.dnDevNode">
            <summary>Device node for plug and play devices.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.ICSETSTATUSPROC">
            <summary>The <c>ICSETSTATUSPROC</c> structure contains status information used with the ICM_SET_STATUS_PROC message.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICSETSTATUSPROC.dwFlags">
            <summary>Reserved; set to zero.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICSETSTATUSPROC.lParam">
            <summary>Parameter that contains a constant to pass to the status procedure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Msvfw32.ICSETSTATUSPROC.Status">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.SafeHDRAWDIB">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.Msvfw32.HDRAWDIB"/> that is disposed using <see cref="M:Vanara.PInvoke.Msvfw32.DrawDibClose(Vanara.PInvoke.Msvfw32.HDRAWDIB)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.SafeHDRAWDIB.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Msvfw32.SafeHDRAWDIB"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.SafeHDRAWDIB.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Msvfw32.SafeHDRAWDIB"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.SafeHDRAWDIB.op_Implicit(Vanara.PInvoke.Msvfw32.SafeHDRAWDIB)~Vanara.PInvoke.Msvfw32.HDRAWDIB">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Msvfw32.SafeHDRAWDIB"/> to <see cref="T:Vanara.PInvoke.Msvfw32.HDRAWDIB"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.SafeHDRAWDIB.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Msvfw32.SafeHIC">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.Msvfw32.HIC"/> that is disposed using <see cref="M:Vanara.PInvoke.Msvfw32.ICClose(Vanara.PInvoke.Msvfw32.HIC)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.SafeHIC.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Msvfw32.SafeHIC"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.SafeHIC.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Msvfw32.SafeHIC"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.SafeHIC.op_Implicit(Vanara.PInvoke.Msvfw32.SafeHIC)~Vanara.PInvoke.Msvfw32.HIC">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Msvfw32.SafeHIC"/> to <see cref="T:Vanara.PInvoke.Msvfw32.HIC"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Msvfw32.SafeHIC.InternalReleaseHandle">
            <inheritdoc/>
        </member>
    </members>
</doc>
